{
  "hash": "1d24ed07b65d93a078fed27aa482ebf8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"La m√©thode du pivot de Gauss : r√©soudre des syst√®mes lin√©aires comme un pro !\"\ndate: \"2024-10-08\"\ncategories: [Math√©matiques, Python, Programmation]\nimage: Carl_Friedrich_Gauss_1840_by_Jensen.jpg\n---\n\n\n## C'est quoi cette histoire de pivot ?\n\nLa m√©thode du pivot de Gauss, c'est une technique super efficace pour r√©soudre des syst√®mes d'√©quations lin√©aires. L'id√©e, c'est de transformer notre syst√®me initial en un syst√®me √©quivalent, mais beaucoup plus simple √† r√©soudre. Comment ? En √©liminant progressivement les variables, une par une, jusqu'√† obtenir un syst√®me triangulaire.\n\nImaginez que vous essayez de d√©m√™ler un n≈ìud de c√¢bles. Vous commencez par un bout, vous d√©gagez un c√¢ble, puis un autre, et ainsi de suite jusqu'√† ce que tout soit bien ordonn√©. C'est exactement ce que fait la m√©thode de Gauss avec nos √©quations !\n\n## Un exemple pour mieux comprendre\n\nAllez, on se lance dans un exemple concret. On va r√©soudre un syst√®me de trois √©quations √† trois inconnues. Attachez vos ceintures, √ßa va d√©coiffer !\n\nSoit le syst√®me suivant :\n\n$$\n\\begin{cases}\n2&x &+& y &-& &z &=& 8 \\\\\n-3&x &-& y &+& 2&z &=& -11 \\\\\n-2&x &+& y &+& 2&z &=& -3\n\\end{cases}\n$$\n\n### √âtape 1 : On choisit notre pivot\n\nOn va utiliser la premi√®re √©quation comme pivot pour √©liminer $x$ dans les autres √©quations. \n\n### √âtape 2 : On √©limine $x$ dans la deuxi√®me et la troisi√®me √©quation\n\n- Pour la deuxi√®me √©quation, on ajoute 3/2 fois la premi√®re √©quation\n- Pour la troisi√®me √©quation, on ajoute 1 fois la premi√®re √©quation\n\nOn obtient le syst√®me √©quivalent :\n\n$$\n\\begin{cases}\n2&x &+& &y &-& &z &=& 8 \\\\\n& &&\\frac{1}{2}&y &+& \\frac{1}{2}&z &=& 1 \\\\\n& &&2&y &+& &z &=& 5\n\\end{cases}\n$$\n\n### √âtape 3 : On √©limine $y$ dans la troisi√®me √©quation\n\nMaintenant, on utilise la deuxi√®me √©quation comme pivot pour √©liminer $y$ dans la troisi√®me √©quation. On multiplie la deuxi√®me √©quation par $-4$ et on l'ajoute √† la troisi√®me √©quation :\n\n$$\n\\begin{cases}\n2& &+ &&y &- &&z &= 8 \\\\\n&&&\\frac{1}{2}&y &+ &\\frac{1}{2}&z &= 1 \\\\\n&& &&&-&&z &= 1\n\\end{cases}\n$$\n\n### √âtape 4 : On r√©sout !\n\nEt voil√†, on a notre syst√®me triangulaire ! C'est comme avoir d√©nou√© tous nos c√¢bles. Maintenant, on peut facilement trouver nos inconnues :\n\n1. De la derni√®re √©quation : $z = -1$\n2. De la deuxi√®me √©quation : $\\frac{1}{2}y + \\frac{1}{2}(-1) = 1$, donc $y = 3$\n3. De la premi√®re √©quation : $2x + 3 + 1 = 8$, donc $x = 2$\n\nNotre solution est donc $(x, y, z) = (2, 3, -1)$.\n\n## G√©n√©ralisation et √©quivalence des syst√®mes\n\nMaintenant que nous avons vu un exemple concret, parlons un peu de ce qui se passe en coulisses. La magie de la m√©thode du pivot de Gauss repose sur l'utilisation d'op√©rations √©l√©mentaires qui nous permettent de passer d'un syst√®me √† un autre √©quivalent.\n\nMais qu'est-ce qu'un syst√®me √©quivalent ? C'est simple : deux syst√®mes sont √©quivalents s'ils ont exactement les m√™mes solutions. En d'autres termes, peu importe lequel des deux syst√®mes, vous r√©solvez, vous obtiendrez le m√™me r√©sultat final.\n\nLes op√©rations √©l√©mentaires que nous utilisons sont :\n\n1. √âchanger deux √©quations\n2. Multiplier une √©quation par un nombre non nul\n3. Ajouter √† une √©quation un multiple d'une autre √©quation\n\nCes op√©rations sont comme des tours de magie math√©matiques : elles transforment notre syst√®me, mais sans jamais changer ses solutions. C'est un peu comme si vous r√©arrangiez les pi√®ces d'un puzzle sans changer l'image finale.\n\nPourquoi est-ce si important ? Eh bien, cela signifie que nous pouvons manipuler notre syst√®me initial pour le rendre plus simple √† r√©soudre, sans craindre de perdre ou de modifier les solutions en cours de route. C'est ce qui nous permet de passer d'un syst√®me compliqu√© √† un syst√®me triangulaire facile √† r√©soudre, comme nous l'avons fait dans notre exemple.\n\nDans le cas g√©n√©ral, pour un syst√®me de $n$ √©quations √† $n$ inconnues, nous appliquons ces op√©rations de mani√®re syst√©matique :\n\n1. On choisit un pivot (g√©n√©ralement le premier coefficient non nul de la premi√®re colonne) et on √©change l'√©quation correspondante avec la premi√®re √©quation\n2. On utilise ce pivot pour √©liminer la premi√®re variable dans toutes les √©quations suivantes\n3. On r√©p√®te le processus avec la deuxi√®me √©quation comme nouveau pivot, et ainsi de suite.\n\n√Ä chaque √©tape, nous cr√©ons un nouveau syst√®me √©quivalent, jusqu'√† obtenir un syst√®me triangulaire que nous pouvons r√©soudre facilement par substitution inverse.\n\nCette approche nous permet de r√©soudre des syst√®mes de plus en plus grands et complexes, tout en gardant la certitude que nos manipulations pr√©servent les solutions originales. C'est la beaut√© et la puissance de la m√©thode du pivot de Gauss !\n\n## Automatisons tout √ßa avec Python !\n\nMaintenant que vous √™tes des pros du pivot de Gauss, que diriez-vous d'automatiser tout √ßa avec un peu de code Python ? C'est parti !\n\nMais avant de plonger dans le code, parlons un peu de la fa√ßon dont nous allons repr√©senter notre syst√®me d'√©quations en Python.\n\n### Repr√©sentation du syst√®me en Python\n\nEn Python, nous allons utiliser un tableau NumPy pour repr√©senter notre syst√®me d'√©quations. Pourquoi NumPy ? Parce que c'est super efficace pour les calculs num√©riques et √ßa nous facilite la vie pour manipuler nos √©quations.\n\nVoici comment √ßa marche :\n\n- Chaque ligne du tableau repr√©sente une √©quation du syst√®me.\n- Les colonnes repr√©sentent les coefficients des variables et le terme constant.\n- La derni√®re colonne contient les termes constants (les nombres √† droite du signe √©gal dans nos √©quations).\n\nPar exemple, notre syst√®me initial :\n\n$$\n\\begin{cases}\n2&x& +& y& -& &z& =& 8 \\\\\n-3&x& -& y& +& 2&z& =& -11 \\\\\n-2&x& +& y& +& 2&z& =& -3\n\\end{cases}\n$$\n\nsera repr√©sent√© par le tableau NumPy suivant :\n\n```python\nsysteme = np.array([\n    [2,  1, -1,  8],\n    [-3, -1,  2, -11],\n    [-2,  1,  2, -3]\n], dtype=float)\n```\n\n### Acc√®s aux coefficients\n\nPour acc√©der aux diff√©rents coefficients dans notre tableau NumPy, on utilise l'indexation. Voici comment √ßa marche :\n\n- `systeme[i, j]` nous donne l'√©l√©ment √† la i-√®me ligne et j-√®me colonne.\n- Les indices commencent √† 0 (comme d'habitude en Python).\n- Pour un syst√®me de n √©quations √† n inconnues :\n  - `systeme[i, j]` pour i < n et j < n donne le coefficient de la (j+1)-√®me variable dans la (i+1)-√®me √©quation.\n  - `systeme[i, n]` donne le terme constant de la (i+1)-√®me √©quation.\n\nPar exemple :\n\n- `systeme[0, 0]` vaut 2 (coefficient de $x$ dans la premi√®re √©quation)\n- `systeme[1, 2]` vaut 2 (coefficient de $z$ dans la deuxi√®me √©quation)\n- `systeme[2, 3]` vaut $-3$ (terme constant de la troisi√®me √©quation).\n\nCette repr√©sentation nous permet de manipuler facilement notre syst√®me d'√©quations en utilisant les op√©rations de NumPy, ce qui rend notre impl√©mentation de la m√©thode du pivot de Gauss √† la fois simple et efficace.\n\nMaintenant que nous avons compris comment repr√©senter et manipuler notre syst√®me, passons au code !\n\n::: {#6739fac9 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\ndef echanger_equations(systeme, i, j):\n    systeme[i], systeme[j] = systeme[j].copy(), systeme[i].copy()\n\ndef multiplier_equation(systeme, i, facteur):\n    systeme[i] *= facteur\n\ndef ajouter_multiple_equation(systeme, i, j, facteur):\n    systeme[i] += facteur * systeme[j]\n\ndef pivot_gauss(systeme):\n    n, m = systeme.shape\n    for i in range(min(n, m - 1)):\n        # Trouver le pivot maximal\n        pivot = i + np.argmax(np.abs(systeme[i:, i]))\n        if systeme[pivot, i] == 0:\n            raise ValueError(\"Le syst√®me n'a pas de solution unique!\")\n        \n        # √âchanger les √©quations\n        if pivot != i:\n            echanger_equations(systeme, i, pivot)\n        \n        # √âliminer les variables\n        for j in range(i + 1, n):\n            facteur = -systeme[j, i] / systeme[i, i]\n            ajouter_multiple_equation(systeme, j, i, facteur)\n    \n    return systeme\n\n# Exemple d'utilisation\nsysteme = np.array([\n    [2, 1, -1, 8],\n    [-3, -1, 2, -11],\n    [-2, 1, 2, -3]\n], dtype=float)\n\nprint(\"Syst√®me initial :\")\nprint(systeme)\n\nresultat = pivot_gauss(systeme)\nprint(\"\\nSyst√®me apr√®s pivot de Gauss :\")\nprint(resultat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSyst√®me initial :\n[[  2.   1.  -1.   8.]\n [ -3.  -1.   2. -11.]\n [ -2.   1.   2.  -3.]]\n\nSyst√®me apr√®s pivot de Gauss :\n[[ -3.          -1.           2.         -11.        ]\n [  0.           1.66666667   0.66666667   4.33333333]\n [  0.           0.           0.2         -0.2       ]]\n```\n:::\n:::\n\n\nExpliquons un peu ce code :\n\n1. `echanger_equations`, `multiplier_equation`, et `ajouter_multiple_equation` sont nos op√©rations √©l√©mentaires sur les √©quations. Elles utilisent l'indexation NumPy pour acc√©der et modifier les coefficients.\n2. `pivot_gauss` est notre fonction principale qui applique la m√©thode du pivot de Gauss. Elle utilise `systeme.shape` pour obtenir les dimensions de notre tableau.\n3. Dans `pivot_gauss`, on utilise `np.argmax` pour trouver l'indice du coefficient de plus grande valeur absolue, ce qui nous donne notre meilleur pivot pour minimiser les erreurs d'arrondi.\n4. Les op√©rations d'√©limination utilisent l'indexation pour acc√©der aux coefficients appropri√©s et les modifier.\n\nEt voil√† ! Avec ce code, vous pouvez r√©soudre des syst√®mes lin√©aires plus rapidement qu'il n'en faut pour dire \"Carl Friedrich Gauss\" !\n\nR√©solvons par exemple le syst√®me de cinq √©quations √† cinq inconnues suivant :\n\n$$\n\\begin{cases}\n2&x& +& &y& -& &z& +& 2&w& -& 3&v& =& 8 \\\\\n-3&x& -& &y& +& 2&z& -& &w& +& 4&v& =& -11 \\\\\n-2&x& +& &y& +& 2&z& +& &w& -& 2&v& =& -3 \\\\\n&x& -& &y& +& & z& -& & w & +& & v& =& 2 \\\\\n4&x& -& 2&y& +& 3&z& -& 2&w& +& & v& =& 3\n\\end{cases}\n$$\n\n::: {#7b802c41 .cell execution_count=2}\n``` {.python .cell-code}\nsysteme = np.array([\n    [2, 1, -1, 2, -3, 8],\n    [-3, -1, 2, -1, 4, -11],\n    [-2, 1, 2, 1, -2, -3],\n    [1, -1, 1, -1, 1, 2],\n    [4, -2, 3, -2, 1, 3]\n], dtype=float)\n\nresultat = pivot_gauss(systeme)\nprint(\"Syst√®me apr√®s pivot de Gauss :\")\nprint(resultat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSyst√®me apr√®s pivot de Gauss :\n[[ 4.         -2.          3.         -2.          1.          3.        ]\n [ 0.         -2.5         4.25       -2.5         4.75       -8.75      ]\n [ 0.          0.          3.5         0.         -1.5        -1.5       ]\n [ 0.          0.          0.          1.          0.68571429 -0.11428571]\n [ 0.          0.          0.          0.         -0.45714286  2.74285714]]\n```\n:::\n:::\n\n\nIl n'y a plus qu'√† remonter les √©quations pour trouver les valeurs de $x$, $y$, $z$, $w$, et $v$.\n\nOn trouve en arrondissant les valeurs : $x=-2$, $y=-17$, $z=-3$, $w=4$, $v=-6$.\n\n## Conclusion\n\nLa m√©thode du pivot de Gauss, c'est comme avoir un super-pouvoir pour r√©soudre des syst√®mes d'√©quations. Que vous le fassiez √† la main ou avec Python, vous avez maintenant les outils pour dompter ces syst√®mes lin√©aires rebelles !\n\nAlors, la prochaine fois que quelqu'un vous parle de syst√®mes d'√©quations, vous pourrez fi√®rement dire : \"Pas de panique, j'ai Gauss de mon c√¥t√© !\" üòé\n\n![Carl Friedrich Gauss](Carl_Friedrich_Gauss_1840_by_Jensen.jpg){width=50%}\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}