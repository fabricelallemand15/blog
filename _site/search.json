[
  {
    "objectID": "posts/tutoIA_podcast/index.html",
    "href": "posts/tutoIA_podcast/index.html",
    "title": "Tuto IA pour les profs : Créer des exercices à partir de podcasts.",
    "section": "",
    "text": "Les podcasts sont un excellent moyen d’apprendre et de s’informer. Ils sont également un excellent moyen de pratiquer l’écoute et la compréhension orale. Dans ce tutoriel, nous allons voir comment utiliser l’intelligence artificielle pour créer des exercices à partir de podcasts.\nPour ce faire, nous allons utiliser l’IA Gemini de Google, dans sa version “2.0 Flash Thinking”, accessible entièrement gratuitement dans le Google AI Studio.\n\n\n\n\nPour permettre à l’IA de travailler sur le podcast, nous devons d’abord le télécharger. Nous allons prendre comme exemple un podcast de France Culture sur l’intelligence artificielle, dont la page est la suivante : https://www.radiofrance.fr/franceculture/podcasts/la-science-cqfd/ia-forte-la-paranoia-5901100.\nLe site de France Culture ne permet pas de télécharger directement le podcast, mais vous pouvez utiliser un outil comme youtube-dl pour le faire. Par exemple, pour télécharger le podcast en format mp3, vous pouvez utiliser la commande suivante :\nyoutube-dl -x --audio-format mp3 https://www.radiofrance.fr/franceculture/podcasts/la-science-cqfd/ia-forte-la-paranoia-5901100\nMais il est aussi possible d’utiliser l’IA pour télécharger le podcast. En effet, l’adresse du fichier mp3 est souvent présente dans le code source de la page web. Vous pouvez donc utiliser une IA pour extraire cette adresse et télécharger le fichier. Voici comment procéder.\n\nCharger la page du podcast dans votre navigateur. Faire un clic droit sur la page, puis sélectionner “Afficher le code source de la page” (ou équivalent).\nUn nouvel onglet s’ouvre contenant le code source de la page. Avec le clavier, faire Ctrl + A pour tout sélectionner, puis Ctrl + C pour copier.\nDans Gemini, créer un nouveau prompt et entrer le texte suivant :\n\n\n\n\n\n\n\nPrompt\n\n\n\nExtrait du code source HTML ci-dessous l’URL du fichier mp3 du podcast de 59 minutes de France Culture sur l’IA forte.\n\n\nSauter une ligne, puis coller le code source copié précédemment avec Ctrl + V et valider avec Ctrl + Entrée.\n\n\nL’IA va alors extraire l’URL du fichier MP3 du podcast. Vous pouvez ensuite copier-coller cette URL dans votre navigateur internet pour ouvrir et télécharger le fichier (clic droit).\n\nIl existe aussi des outils en ligne et des logiciels pour télécharger des fichiers audio à partir d’une URL.\nSupposons maintenant que vous avez téléchargé le podcast et que vous avez le fichier MP3 sur votre ordinateur.\n\n\n\nDemander directement une transcription du podcast est possible, mais avec un fichier d’une heure, le texte à générer serait très long, et même trop long pour l’IA.\nNous allons donc plutôt lui demander un résumé structuré. Sachant que les IA donnent de bien meilleurs résultats si on leur demande de travailler étape par étape, il est préférable de faire un prompt bien détaillé. Voici comment procéder :\n\nDans le Google AI Studio, créez un nouveau prompt et choisir le modèle “2.0 Flash Thinking”.\nEntrez le texte suivant :\n\n\n\n\n\n\n\nPrompt\n\n\n\nVoici le fichier audio d’un podcast. Je souhaite un résumé structuré de ce podcast. Pour cela, je te demande de suivre les étapes suivantes :\n\nListe des invités de l’émission en précisant leurs fonctions.\nRésumé de l’introduction : quelle est la thématique abordée ?\nRésumé des points principaux abordés. Structure ta réponse en suivant bien le plan de l’émission. Indique des repères temporels pour que je puisse retrouver les passages dans le podcast.\nRésumé de la conclusion.\n\n\n\nEnsuite, charger le fichier MP3 en cliquant sur le petit symbole (+) situé en bas à droite.\nValider le prompt avec Ctrl + Entrée, puis attendre que l’IA génère la transcription (c’est un peu long).\n\n\n\n\nL’exploitation pédagogique va dépendre de la discipline concernée et des envies du professeur !\nVoici quelques idées d’exercices que vous pourriez créer à partir du résumé généré par l’IA :\n\nQuestions de compréhension : Créer des questions de compréhension sur les points principaux abordés dans le podcast.\n\n\n\n\n\n\n\nPrompt\n\n\n\nJe suis professeur et je veux vérifier que mes élèves ont bien écouté ce podcast et l’ont bien compris. Pour cela, je souhaite créer des questions de compréhension. Peux-tu me proposer 5 questions sur les points principaux abordés dans le podcast ?\n\n\nEn réponse, l’IA propose des questions qui peuvent être pertinentes ou pas, il faut faire le tri. Lors de mon test, elle a introduit des repères temporels pour quelques questions, mais ces repères sont fantaisistes :\n\n\nTexte à trous : Créer un texte à trous à partir du résumé du podcast. Les élèves devront compléter les trous avec les mots manquants.\n\n\n\n\n\n\n\nPrompt\n\n\n\nJe suis professeur et je veux créer un texte à trous à partir du résumé du podcast. Peux-tu me proposer un texte à trous avec 10 mots manquants ? Indique la solution en dessous du texte.\n\n\n\n\nQCM : Créer un QCM à partir du résumé du podcast. Les élèves devront choisir la bonne réponse parmi plusieurs propositions.\n\n\n\n\n\n\n\nPrompt\n\n\n\nJe suis professeur et je veux créer un QCM à partir du résumé du podcast. Peux-tu me proposer 5 questions avec chacune une unique bonne réponse. Indique quelle est la bonne réponse pour chaque question.\n\n\n\n\n\n\nLes exemples présentés dans cet article ne sont que quelques idées d’exercices que vous pourriez créer à partir d’un podcast. Selon les disciplines, beaucoup d’autres types d’exercices sont possibles. L’IA peut vous aider à générer des exercices rapidement et facilement, mais il est important de vérifier la qualité des réponses générées."
  },
  {
    "objectID": "posts/tutoIA_podcast/index.html#introduction",
    "href": "posts/tutoIA_podcast/index.html#introduction",
    "title": "Tuto IA pour les profs : Créer des exercices à partir de podcasts.",
    "section": "",
    "text": "Les podcasts sont un excellent moyen d’apprendre et de s’informer. Ils sont également un excellent moyen de pratiquer l’écoute et la compréhension orale. Dans ce tutoriel, nous allons voir comment utiliser l’intelligence artificielle pour créer des exercices à partir de podcasts.\nPour ce faire, nous allons utiliser l’IA Gemini de Google, dans sa version “2.0 Flash Thinking”, accessible entièrement gratuitement dans le Google AI Studio."
  },
  {
    "objectID": "posts/tutoIA_podcast/index.html#étape-1-télécharger-le-podcast",
    "href": "posts/tutoIA_podcast/index.html#étape-1-télécharger-le-podcast",
    "title": "Tuto IA pour les profs : Créer des exercices à partir de podcasts.",
    "section": "",
    "text": "Pour permettre à l’IA de travailler sur le podcast, nous devons d’abord le télécharger. Nous allons prendre comme exemple un podcast de France Culture sur l’intelligence artificielle, dont la page est la suivante : https://www.radiofrance.fr/franceculture/podcasts/la-science-cqfd/ia-forte-la-paranoia-5901100.\nLe site de France Culture ne permet pas de télécharger directement le podcast, mais vous pouvez utiliser un outil comme youtube-dl pour le faire. Par exemple, pour télécharger le podcast en format mp3, vous pouvez utiliser la commande suivante :\nyoutube-dl -x --audio-format mp3 https://www.radiofrance.fr/franceculture/podcasts/la-science-cqfd/ia-forte-la-paranoia-5901100\nMais il est aussi possible d’utiliser l’IA pour télécharger le podcast. En effet, l’adresse du fichier mp3 est souvent présente dans le code source de la page web. Vous pouvez donc utiliser une IA pour extraire cette adresse et télécharger le fichier. Voici comment procéder.\n\nCharger la page du podcast dans votre navigateur. Faire un clic droit sur la page, puis sélectionner “Afficher le code source de la page” (ou équivalent).\nUn nouvel onglet s’ouvre contenant le code source de la page. Avec le clavier, faire Ctrl + A pour tout sélectionner, puis Ctrl + C pour copier.\nDans Gemini, créer un nouveau prompt et entrer le texte suivant :\n\n\n\n\n\n\n\nPrompt\n\n\n\nExtrait du code source HTML ci-dessous l’URL du fichier mp3 du podcast de 59 minutes de France Culture sur l’IA forte.\n\n\nSauter une ligne, puis coller le code source copié précédemment avec Ctrl + V et valider avec Ctrl + Entrée.\n\n\nL’IA va alors extraire l’URL du fichier MP3 du podcast. Vous pouvez ensuite copier-coller cette URL dans votre navigateur internet pour ouvrir et télécharger le fichier (clic droit).\n\nIl existe aussi des outils en ligne et des logiciels pour télécharger des fichiers audio à partir d’une URL.\nSupposons maintenant que vous avez téléchargé le podcast et que vous avez le fichier MP3 sur votre ordinateur."
  },
  {
    "objectID": "posts/tutoIA_podcast/index.html#étape-2-résumé-du-podcast",
    "href": "posts/tutoIA_podcast/index.html#étape-2-résumé-du-podcast",
    "title": "Tuto IA pour les profs : Créer des exercices à partir de podcasts.",
    "section": "",
    "text": "Demander directement une transcription du podcast est possible, mais avec un fichier d’une heure, le texte à générer serait très long, et même trop long pour l’IA.\nNous allons donc plutôt lui demander un résumé structuré. Sachant que les IA donnent de bien meilleurs résultats si on leur demande de travailler étape par étape, il est préférable de faire un prompt bien détaillé. Voici comment procéder :\n\nDans le Google AI Studio, créez un nouveau prompt et choisir le modèle “2.0 Flash Thinking”.\nEntrez le texte suivant :\n\n\n\n\n\n\n\nPrompt\n\n\n\nVoici le fichier audio d’un podcast. Je souhaite un résumé structuré de ce podcast. Pour cela, je te demande de suivre les étapes suivantes :\n\nListe des invités de l’émission en précisant leurs fonctions.\nRésumé de l’introduction : quelle est la thématique abordée ?\nRésumé des points principaux abordés. Structure ta réponse en suivant bien le plan de l’émission. Indique des repères temporels pour que je puisse retrouver les passages dans le podcast.\nRésumé de la conclusion.\n\n\n\nEnsuite, charger le fichier MP3 en cliquant sur le petit symbole (+) situé en bas à droite.\nValider le prompt avec Ctrl + Entrée, puis attendre que l’IA génère la transcription (c’est un peu long)."
  },
  {
    "objectID": "posts/tutoIA_podcast/index.html#étape-3-création-dexercices",
    "href": "posts/tutoIA_podcast/index.html#étape-3-création-dexercices",
    "title": "Tuto IA pour les profs : Créer des exercices à partir de podcasts.",
    "section": "",
    "text": "L’exploitation pédagogique va dépendre de la discipline concernée et des envies du professeur !\nVoici quelques idées d’exercices que vous pourriez créer à partir du résumé généré par l’IA :\n\nQuestions de compréhension : Créer des questions de compréhension sur les points principaux abordés dans le podcast.\n\n\n\n\n\n\n\nPrompt\n\n\n\nJe suis professeur et je veux vérifier que mes élèves ont bien écouté ce podcast et l’ont bien compris. Pour cela, je souhaite créer des questions de compréhension. Peux-tu me proposer 5 questions sur les points principaux abordés dans le podcast ?\n\n\nEn réponse, l’IA propose des questions qui peuvent être pertinentes ou pas, il faut faire le tri. Lors de mon test, elle a introduit des repères temporels pour quelques questions, mais ces repères sont fantaisistes :\n\n\nTexte à trous : Créer un texte à trous à partir du résumé du podcast. Les élèves devront compléter les trous avec les mots manquants.\n\n\n\n\n\n\n\nPrompt\n\n\n\nJe suis professeur et je veux créer un texte à trous à partir du résumé du podcast. Peux-tu me proposer un texte à trous avec 10 mots manquants ? Indique la solution en dessous du texte.\n\n\n\n\nQCM : Créer un QCM à partir du résumé du podcast. Les élèves devront choisir la bonne réponse parmi plusieurs propositions.\n\n\n\n\n\n\n\nPrompt\n\n\n\nJe suis professeur et je veux créer un QCM à partir du résumé du podcast. Peux-tu me proposer 5 questions avec chacune une unique bonne réponse. Indique quelle est la bonne réponse pour chaque question."
  },
  {
    "objectID": "posts/tutoIA_podcast/index.html#conclusion",
    "href": "posts/tutoIA_podcast/index.html#conclusion",
    "title": "Tuto IA pour les profs : Créer des exercices à partir de podcasts.",
    "section": "",
    "text": "Les exemples présentés dans cet article ne sont que quelques idées d’exercices que vous pourriez créer à partir d’un podcast. Selon les disciplines, beaucoup d’autres types d’exercices sont possibles. L’IA peut vous aider à générer des exercices rapidement et facilement, mais il est important de vérifier la qualité des réponses générées."
  },
  {
    "objectID": "posts/tribuneMS/index.html",
    "href": "posts/tribuneMS/index.html",
    "title": "Tribune du collectif Maths & Sciences",
    "section": "",
    "text": "Le collectif Maths & Sciences a publié dans le numéro de La Recherche du 17 octobre 2023 une tribune qui analyse de façon très pertinente les conséquences de la réforme du lycée sur l’enseignement des sciences et des mathématiques au lycée.\nLa tribune est à lire sur le site de La Recherche : Tribune"
  },
  {
    "objectID": "posts/tribuneMS/index.html#résumé-de-la-tribune",
    "href": "posts/tribuneMS/index.html#résumé-de-la-tribune",
    "title": "Tribune du collectif Maths & Sciences",
    "section": "Résumé de la tribune",
    "text": "Résumé de la tribune\n\nRéforme du lycée: La réforme de 2019 a supprimé les mathématiques du tronc commun et a créé des spécialités à choisir parmi 13. Cette réforme pose des problèmes de fond en sciences et entraîne des ruptures et des fractures entre les élèves.\nChute des effectifs en sciences: Depuis la réforme, le nombre d’élèves qui suivent des spécialités scientifiques, notamment en mathématiques, a diminué de manière significative. Les filles sont particulièrement touchées par cette baisse, ainsi que les élèves d’origine sociale défavorisée.\nInégalités territoriales: Les spécialités émergentes, comme le numérique et les sciences informatiques, sont peu présentes dans les lycées et peinent à attirer les élèves. Les spécialités principales restent dominantes et créent une fracture entre les profils de formation.\nPropositions d’amendements: Le collectif Maths&Sciences et ses partenaires proposent de rééquilibrer le tronc commun en faveur des sciences et de maintenir trois spécialités en terminale pour préserver la polyvalence des élèves. Ils appellent à une évaluation globale de la réforme du lycée."
  },
  {
    "objectID": "posts/timeexec/index.html",
    "href": "posts/timeexec/index.html",
    "title": "Mesurer le temps d’exécution d’un fragment de code",
    "section": "",
    "text": "Un moyen intuitif de comparer l’efficacité de deux portions de code est de mesurer leur temps d’exécution en fonction de la taille des données. Le module timeit de Python permet de faire cela de façon semi-automatisée. Nous allons voir comment dans cet article, en considérant trois fonctions différentes qui renvoient le n-ième \\(F_n\\) de la suite de Fibonacci.\n\n\n\n\nPour les besoins du code présent dans la suite, on commencera par les importations suivantes :\n\n\n\nimport matplotlib.pyplot as plt\nimport timeit\n\n\n\nFonctions à tester\n\n\n\n\nCes fonctions sont issues d’un exercice du chapitre “Récursivité” du cours de NSI de terminale. Cependant, l’objectif de cet article est juste de montrer un moyen de comparer et de visualiser les vitesses d’exécution.\n\n\n\n\nNous considérons les trois fonctions suivantes. La première retourne le nombre \\(F_n\\) par une méthode itérative.\n\n\n\ndef fibo_iter(n: int) -&gt; int:\n    \"\"\"Suite de Fibonacci, version itérative\"\"\"\n    if n == 0:\n        return 0\n    else:\n        f0, f1 = 0, 1\n        for k in range(1, n):\n            f0, f1 = f1, f0 + f1\n        return f1\n\n\n\nLa deuxième fonction est une fonction récursive qui traduit directement la définition de la suite de Fibonacci.\n\n\n\ndef fibo_rec(n: int) -&gt; int:\n    \"\"\"Suite de Fibonacci version récursive\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        return fibo_rec(n-2)+fibo_rec(n-1)\n\n\n\nLa troisième est également récursive et utilise les idées de la programmation dynamique.\n\n\n\ndef fibo_dyn(n: int, suite: dict = {0: 0, 1: 1}) -&gt; int:\n    \"\"\"Suite de Fibonacci version dynamique\"\"\"\n    # Cas de base\n    if n == 0 or n == 1:\n        return n\n    # Récursion\n    else:\n        # Si Fn est déjà calculé, on le retourne\n        if n in suite.keys():\n            return suite[n]\n        else:\n            # Sinon, on le calcule et on le garde en mémoire\n            f = fibo_dyn(n-2, suite) + fibo_dyn(n-1, suite)\n            suite[n] = f\n            return f\n\n\n\nUtilisation de timeit\n\n\n\n\nPar exemple, pour obtenir le temps d’exécution de 100 appels à la fonction fibo_iter() avec le paramètre 15, on entre le script suivant :\n\n\n\ntimeit.timeit('fibo_iter(15)', number=1000, globals=globals())\n\n0.0008780480002315016\n\n\n\n\net on obtient en sortie le temps d’exécution en secondes.\n\n\n\n\nBeaucoup d’autres choses sont possibles avec le module timeit, mais cette simple commande nous suffira.\n\n\n\n\nVisualisation graphique\n\n\n\n\nDans le script suivant, nous définissions un tableau des abscisses correspondant aux différentes valeurs de \\(n\\) pour lesquelles nous calculons \\(F_n\\) : \\(n\\) varie de 0 à 15 avec un pas de 1 (ligne 1)\n\n\n\n\nEnsuite, pour chacune des fonctions, nous calculons le temps d’exécution de chaque terme de la suite (100 fois) et nous stockons les résultats dans un tableau d’ordonnées. (lignes 5 à 11)\n\n\n\n\nNous traçons ensuite les courbes correspondantes. (lignes 12 à 15)\n\n\n\nabscisses = [k for k in range(0, 20, 1)]\nordonnees_rec = []\nordonnees_iter = []\nordonnees_dyn = []\nfor x in abscisses:\n    ordonnees_iter.append(timeit.timeit(\n        'fibo_iter(x)', number=100, globals=globals()))\n    ordonnees_rec.append(timeit.timeit(\n        'fibo_rec(x)', number=100, globals=globals()))\n    ordonnees_dyn.append(timeit.timeit(\n        'fibo_dyn(x)', number=100, globals=globals()))\nplt.plot(abscisses, ordonnees_iter, 'b')\nplt.plot(abscisses, ordonnees_rec, 'r')\nplt.plot(abscisses, ordonnees_dyn, 'g')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nNous observons pour la fonction récursive une courbe caractéristique d’une croissance exponentielle du temps d’exécution. Les courbes bleue et verte correspondant aux deux autres méthodes sont confondues. Pour les distinguer, nous allons faire une nouvelle figure sans les données de la fonction fibo_rec cette fois ci (image réalisée avec \\(n\\) variant de 0 à 100) :\n\n\n\nabscisses = [k for k in range(0, 100, 1)]\nordonnees_iter = []\nordonnees_dyn = []\nfor x in abscisses:\n    ordonnees_iter.append(timeit.timeit(\n        'fibo_iter(x)', number=100, globals=globals()))\n    ordonnees_dyn.append(timeit.timeit(\n        'fibo_dyn(x)', number=100, globals=globals()))\nplt.plot(abscisses, ordonnees_iter, 'b')\nplt.plot(abscisses, ordonnees_dyn, 'g')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nCe graphique suggère une croissance linéaire pour la méthode itérative et des performances encore meilleures pour la méthode dynamique.\n\n\n\n\nBien sûr, cette démarche ne remplace pas une étude théorique rigoureuse et un calcul de complexité, mais elle permet, grâce à la visualisation, de comparer rapidement deux algorithmes et de conjecturer leur complexité."
  },
  {
    "objectID": "posts/pyxel_tuto4_cerises/index.html",
    "href": "posts/pyxel_tuto4_cerises/index.html",
    "title": "Tuto pyxel : Pluie de cerises et score",
    "section": "",
    "text": "Ce tuto fait suite au précédent : Tuto pyxel : Ajouter un fond."
  },
  {
    "objectID": "posts/pyxel_tuto4_cerises/index.html#création-de-lobjet-cerise",
    "href": "posts/pyxel_tuto4_cerises/index.html#création-de-lobjet-cerise",
    "title": "Tuto pyxel : Pluie de cerises et score",
    "section": "Création de l’objet Cerise",
    "text": "Création de l’objet Cerise\nNous allons commencer par créer une classe Cerise qui permettra de gérer le comportement et l’affichage des cerises. Chaque cerise aura une position \\((x, y)\\) et une vitesse de chute.\nclass Cerise:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.vitesse = 1  # Vitesse de chute de la cerise\n\n    def update(self):\n        self.y += self.vitesse # La cerise tombe\n\n    def draw(self):\n        pyxel.blt(self.x, self.y, 0, 32, 0, 16, 16, 12) #Affichage de la cerise\nExplications :\n\nLignes 2-4 : Le constructeur __init__ initialise la position \\((x, y)\\) de la cerise et sa vitesse de chute.\nLigne 7 : La méthode update met à jour la position verticale \\(y\\) de la cerise en fonction de sa vitesse, simulant ainsi la chute.\nLigne 10 : La méthode draw affiche la cerise à l’écran à l’aide de pyxel.blt. On suppose ici que les coordonnées de la cerise dans le fichier de ressources sont (32, 0) et que ses dimensions sont 16x16 pixels. La couleur 12 (bleu) est rendue transparente."
  },
  {
    "objectID": "posts/pyxel_tuto4_cerises/index.html#gestion-de-la-pluie-de-cerises",
    "href": "posts/pyxel_tuto4_cerises/index.html#gestion-de-la-pluie-de-cerises",
    "title": "Tuto pyxel : Pluie de cerises et score",
    "section": "Gestion de la pluie de cerises",
    "text": "Gestion de la pluie de cerises\nMaintenant, nous allons gérer la pluie de cerises dans la classe App. Nous utiliserons une liste self.cerises pour stocker les cerises actuellement présentes à l’écran et la fonction pyxel.rndi pour générer des cerises à des positions horizontales aléatoires.\n\n\n\n\n\n\nIdée à retenir\n\n\n\nL’utilisation de pyxel.rndi permet de générer des nombres entiers aléatoires. C’est très pratique pour créer des événements aléatoires dans un jeu.\n\n\nOn ajoute ces éléments dans la méthode __init__ de la classe App:\n    def __init__(self):  # classe App\n        # ... (code précédent)\n        self.cerises = [] # liste des cerises\n        self.score = 0\n        pyxel.run(self.update, self.draw)\nEnsuite, on modifie la méthode update pour ajouter une nouvelle cerise à un intervalle aléatoire, mettre à jour chaque cerise, et supprimer celles qui sortent de l’écran :\n    def update(self):  # classe App\n        self.personnage.update()\n        self.foret.update()\n        for nuage in self.nuages:\n            nuage.update()\n            # ... (code précédent pour la gestion des nuages)\n\n\n        if pyxel.frame_count % pyxel.rndi(30, 60) == 0:  # Générer une cerise toutes les 1 à 2 secondes (à 30 fps)\n            self.cerises.append(Cerise(pyxel.rndi(0, pyxel.width - 16), -16))  # Position aléatoire en x\n            \n        for cerise in self.cerises:\n            cerise.update()\n            if cerise.y &gt; pyxel.height:\n                self.cerises.remove(cerise)\nExplications :\n\nLigne 8 : on génère une nouvelle cerise à un intervalle aléatoire compris entre 30 et 60 frames. Sachant que le jeu tourne à 30 fps, cela correspond à une nouvelle cerise toutes les 1 à 2 secondes.\nLigne 9 : la cerise apparaît juste au-dessus de la fenêtre à une abscisse aléatoire.\nLignes 11 à 13 : la boucle for met à jour la position verticale de chaque cerise et les supprime lorsqu’elles passent en dessous du bas de la fenêtre."
  },
  {
    "objectID": "posts/pyxel_tuto4_cerises/index.html#détection-des-collisions",
    "href": "posts/pyxel_tuto4_cerises/index.html#détection-des-collisions",
    "title": "Tuto pyxel : Pluie de cerises et score",
    "section": "Détection des collisions",
    "text": "Détection des collisions\nPour détecter les collisions entre le personnage et les cerises, nous allons ajouter du code dans la méthode update de la classe App.\n    def update(self):  # class App\n        # ... (code précédent)\n        for cerise in self.cerises:\n            #... (code précédent pour la gestion des cerises)\n\n            if (\n                abs(cerise.x - self.personnage.x_personnage) &lt; 16 and abs(cerise.y - (pyxel.height - 16)) &lt; 16\n            ):  # Collision détectée !\n                self.cerises.remove(cerise)\n                self.score += 1\nExplications :\n\nLignes 6 à 8 : On teste si la distance entre le personnage et la cerise est inférieure à 16 pixels, ce qui signifie une collision. Si une collision est détectée, la cerise est retirée de l’écran et le score du joueur est incrémenté."
  },
  {
    "objectID": "posts/pyxel_tuto4_cerises/index.html#affichage-du-score",
    "href": "posts/pyxel_tuto4_cerises/index.html#affichage-du-score",
    "title": "Tuto pyxel : Pluie de cerises et score",
    "section": "Affichage du score",
    "text": "Affichage du score\nEnfin, nous allons afficher le score en haut à gauche de l’écran. Pour cela, nous modifions la méthode draw de la classe App.\n    def draw(self):  # classe App\n        pyxel.cls(12)\n\n        # ... (code précédent pour le dessin du fond)\n\n        for cerise in self.cerises:\n            cerise.draw()\n        self.personnage.draw()\n        pyxel.text(5, 5, f\"Score: {self.score}\", pyxel.COLOR_WHITE) # Affichage du score\nExplications :\n\nLigne 8: on affiche le score à l’écran en blanc aux coordonnées (5, 5)"
  },
  {
    "objectID": "posts/pyxel_tuto4_cerises/index.html#conclusion",
    "href": "posts/pyxel_tuto4_cerises/index.html#conclusion",
    "title": "Tuto pyxel : Pluie de cerises et score",
    "section": "Conclusion",
    "text": "Conclusion\nDans ce tutoriel, nous avons appris à faire pleuvoir des cerises dans notre application Pyxel. Nous avons créé une classe Cerise pour gérer les cerises, généré une pluie de cerises à intervalles aléatoires, détecté les collisions entre le personnage et les cerises, et affiché le score du joueur. Vous pouvez maintenant tester votre jeu et voir si vous pouvez attraper toutes les cerises !"
  },
  {
    "objectID": "posts/pyxel_tuto2_personnage/index.html",
    "href": "posts/pyxel_tuto2_personnage/index.html",
    "title": "Tuto pyxel : Animer un personnage",
    "section": "",
    "text": "Objectifs du tutoriel\n\n\n\n\nCréer une application Pyxel avec fond coloré uni ;\nCréer un personnage qui se déplace avec les touches du clavier ;\nNous utiliserons pyxelstudio.net pour coder ce tuto."
  },
  {
    "objectID": "posts/pyxel_tuto2_personnage/index.html#géométrie-générale-de-la-fenêtre",
    "href": "posts/pyxel_tuto2_personnage/index.html#géométrie-générale-de-la-fenêtre",
    "title": "Tuto pyxel : Animer un personnage",
    "section": "Géométrie générale de la fenêtre",
    "text": "Géométrie générale de la fenêtre\nLa fenêtre de jeu est un rectangle de 256 pixels de large sur 128 pixels de haut. L’origine du repère est située en haut à gauche de la fenêtre. Les coordonnées des points sont donc comprises entre 0 et 255 pour les abscisses et entre 0 et 127 pour les ordonnées.\n\n\n\nGéométrie de la fenêtre"
  },
  {
    "objectID": "posts/pyxel_tuto2_personnage/index.html#le-fichier-de-ressource-pyxres",
    "href": "posts/pyxel_tuto2_personnage/index.html#le-fichier-de-ressource-pyxres",
    "title": "Tuto pyxel : Animer un personnage",
    "section": "Le fichier de ressource pyxres",
    "text": "Le fichier de ressource pyxres\nPour ce tuto, nous utiliserons le fichier de ressource jump_games.pyxres issu des exemples de Pyxel.\nPour ouvrir, modifier ou consulter le contenu d’un tel fichier, il faut utiliser l’éditeur de ressource de Pyxel. Pour cela, il faut d’abord charger ce fichier dans pyxelstudio : voir la page dédiée.\n\n\n\nEditeur de ressource\n\n\nOn peut voir et faire défiler l’ensemble des images du fichier de ressources dans la partie droite de l’éditeur. Dans la partie gauche, on zoome sur un carré de 16 pixels de côté, avec possibilité de modifier l’image à la souris.\nAstuce utile : quand on déplace la souris sur l’image, les coordonnées du pointeur sont affichées en haut à droite de la fenêtre. Cela permet de repérer facilement les coordonnées des points.\nSous l’image se trouve la palette de couleur. Nous disposons de 16 couleurs, numérotées de 0 à 15."
  },
  {
    "objectID": "posts/pyxel_tuto2_personnage/index.html#affichage-du-personnage-et-du-fond-coloré",
    "href": "posts/pyxel_tuto2_personnage/index.html#affichage-du-personnage-et-du-fond-coloré",
    "title": "Tuto pyxel : Animer un personnage",
    "section": "Affichage du personnage et du fond coloré",
    "text": "Affichage du personnage et du fond coloré\nNous constatons que le dessin du personnage occupe le carré de coordonnées (0, 0) à (15, 15). Nous allons donc afficher le personnage en bas à gauche de la fenêtre, avec la commande pyxel.blt(x, y, img, u, v, w, h, [colkey]) :\n\nx et y sont les coordonnées du point en haut à gauche de l’image dans la fenêtre de l’application ;\nimg est le numéro de l’image dans le fichier de ressource (ici, il n’y en a qu’une seule, numéro 0) ;\nu et v sont les coordonnées du point en haut à gauche de l’image dans le fichier de ressource ;\nw et h sont la largeur et la hauteur de l’image dans le fichier de ressource.\ncolkey est le numéro de la couleur que l’on souhaite rendre transparente. Si on ne souhaite pas rendre de couleur transparente, on peut ne pas renseigner ce paramètre.\n\n\n\n\nParamètres de blt\n\n\nVoici le code obtenu :\nimport pyxel\n\nclass App:\n    def __init__(self):\n        pyxel.init(256, 128, fps=30)\n        # on charge le fichier de ressources\n        pyxel.load(\"jump_game.pyxres\")\n        # variable définissant l'abscisse initiale du personnage\n        self.x_personnage = 0\n        # on lance l'application\n        pyxel.run(self.update, self.draw)\n        \n    def update(self):\n        pass\n\n    def draw(self):\n        # on efface l'écran et on remplit la fenêtre de bleu (code 12)\n        pyxel.cls(12)\n        # on affiche le personnage à l'abscisse x_personnage et à l'ordonnée 127 - 16\n        pyxel.blt(self.x_personnage, pyxel.height - 16, 0, 0, 0, 16, 16)\n\nApp()\nOn obtient :\n\n\n\nPersonnage en bas à gauche"
  },
  {
    "objectID": "posts/pyxel_tuto2_personnage/index.html#déplacement-du-personnage",
    "href": "posts/pyxel_tuto2_personnage/index.html#déplacement-du-personnage",
    "title": "Tuto pyxel : Animer un personnage",
    "section": "Déplacement du personnage",
    "text": "Déplacement du personnage\nNous allons maintenant faire bouger le personnage avec les touches du clavier. Pour cela, nous allons utiliser la méthode update de la classe App. Cette méthode est appelée automatiquement par Pyxel à chaque image. Nous allons donc modifier la valeur de self.x_personnage en fonction des touches du clavier qui sont pressées.\nCependant, l’abscisse du personnage doit toujours rester comprise entre 0 et 255 pour qu’il ne disparaissent pas de l’écran. Nous allons donc utiliser la fonction min pour que self.x_personnage ne puisse pas être inférieur à 0 et la fonction max pour qu’il ne puisse pas être supérieur à 255.\nimport pyxel\n\nclass App:\n    def __init__(self):\n        pyxel.init(256, 128, fps=30)\n        # on charge le fichier de ressources\n        pyxel.load(\"jump_game.pyxres\")\n        # variable définissant l'abscisse initiale du personnage\n        self.x_personnage = 0\n        # variable définissant la vitesse du personnage\n        self.vitesse = 2\n        # on lance l'application\n        pyxel.run(self.update, self.draw)\n        \n    def update(self):\n        if pyxel.btn(pyxel.KEY_LEFT):\n            # si on appuie sur la touche gauche, on déplace le personnage vers la gauche\n            self.x_personnage = max(self.x_personnage - self.vitesse, 0)\n        if pyxel.btn(pyxel.KEY_RIGHT):\n            # si on appuie sur la touche droite, on déplace le personnage vers la droite\n            self.x_personnage = min(self.x_personnage + self.vitesse, pyxel.width - 16)\n\n    def draw(self):\n        # on efface l'écran et on remplit la fenêtre de bleu\n        pyxel.cls(12)\n        # on affiche le personnage à l'abscisse x_personnage et à l'ordonnée 128 - 16\n        pyxel.blt(self.x_personnage, pyxel.height - 16, 0, 0, 0, 16, 16)\n\nApp()\nRemarque : nous avons également défini un attribut vitesse qui permet de modifier la vitesse de déplacement du personnage : il s’agit du nombre de pixels à ajouter, ou à retrancher, à chaque fois que l’on appuie sur une touche fléchée.\n\n\n\nPersonnage qui se déplace"
  },
  {
    "objectID": "posts/pyxel_tuto2_personnage/index.html#animation-du-déplacement",
    "href": "posts/pyxel_tuto2_personnage/index.html#animation-du-déplacement",
    "title": "Tuto pyxel : Animer un personnage",
    "section": "Animation du déplacement",
    "text": "Animation du déplacement\nPour donner une impression d’animation lors du déplacement du personnage, on peut alterner l’affichage de deux images du personnage. Le fichier ressources contient en effet une image du personnage avec les jambes positionnées différemment, comme on peut le voir ci-dessous.\nPour ce faire, on peut utiliser la fonction pyxel.frame_count pour alterner l’affichage des deux images à chaque image. Cette fonction renvoie le nombre d’images affichées depuis le début de l’application. Dans le code ci-dessous, on a de plus défini une variable booléenne self.personnage_marche qui vaut True si le personnage est en train de marcher et False sinon (ce qui permet dans ce cas d’arrêter l’animation).\n\n\n\nAnimation du personnage\n\n\nimport pyxel\n\nclass App:\n    def __init__(self):\n        pyxel.init(256, 128, fps=30)\n        # on charge le fichier de ressources\n        pyxel.load(\"jump_game.pyxres\")\n        # variable définissant l'abscisse initiale du personnage\n        self.x_personnage = 0\n        # variable définissant la vitesse du personnage\n        self.vitesse = 2\n        # variable indiquant si un déplacement est en cours\n        self.personnage_marche = False\n        # on lance l'application\n        pyxel.run(self.update, self.draw)\n        \n    def update(self):\n        if pyxel.btn(pyxel.KEY_LEFT):\n            self.x_personnage = max(self.x_personnage - self.vitesse, 0)\n            self.personnage_marche = True\n        if pyxel.btn(pyxel.KEY_RIGHT):\n            self.x_personnage = min(self.x_personnage + self.vitesse, pyxel.width - 16)\n            self.personnage_marche = True\n\n    def draw(self):\n        # on efface l'écran et on remplit la fenêtre de bleu\n        pyxel.cls(12)\n        # on affiche le personnage à l'abscisse x_personnage et à l'ordonnée 128 - 16\n        if self.personnage_marche:\n            if pyxel.frame_count % 6 &lt; 3:\n                pyxel.blt(self.x_personnage, pyxel.height - 16, 0, 0, 0, 16, 16)\n            else:\n                pyxel.blt(self.x_personnage, pyxel.height - 16, 0, 16, 0, 16, 16)\n            self.personnage_marche = False\n        else:\n            pyxel.blt(self.x_personnage, pyxel.height - 16, 0, 0, 0, 16, 16)\n\nApp()\n\n\n\nPersonnage qui se déplace\n\n\n\n\n\n\n\n\nExplications\n\n\n\nframe_count est le nombre d’images affichées depuis le lancement du jeu. On calcule frame_count % 6 pour obtenir le reste de la division euclidienne de frame_count par 6. On obtient donc un nombre entre 0 et 5. On affiche le premier personnage si ce nombre est inférieur à 3 et le second sinon. On obtient donc un changement d’image toutes les 3 images.\n\n\nUne dernière amélioration serait souhaitable : lorsque le personnage se déplace vers la gauche, il semble reculer. On peut modifier le code de telle façon qu’il se retourne vers la gauche et regarde toujours dans la direction où il se déplace. Pour cela, il suffit de modifier le paramètre w de la fonction pyxel.blt en lui donnant la valeur -16 lorsque le personnage se déplace vers la gauche.\nOn définit pour cela encore un nouvel attribut “direction” qui vaut 1 lorsque le personnage se déplace vers la droite et -1 lorsqu’il se déplace vers la gauche. On multiplie donc self.direction par 16 pour obtenir la valeur de w à donner à la fonction pyxel.blt.\nimport pyxel\n\nclass App:\n    def __init__(self):\n        pyxel.init(256, 128, fps=30)\n        # on charge le fichier de ressources\n        pyxel.load(\"jump_game.pyxres\")\n        # variable définissant l'abscisse initiale du personnage\n        self.x_personnage = 0\n        # variable définissant la vitesse du personnage\n        self.vitesse = 2\n        # variable indiquant si un déplacement est en cours\n        self.personnage_marche = False\n        # variable indiquant la direction du personnage\n        self.direction = 1\n        # on lance l'application\n        pyxel.run(self.update, self.draw)\n        \n    def update(self):\n        if pyxel.btn(pyxel.KEY_LEFT):\n            self.x_personnage = max(self.x_personnage - self.vitesse, 0)\n            self.direction = -1\n            self.personnage_marche = True\n        if pyxel.btn(pyxel.KEY_RIGHT):\n            self.x_personnage = min(self.x_personnage + self.vitesse, pyxel.width - 16)\n            self.direction = 1\n            self.personnage_marche = True\n\n    def draw(self):\n        # on efface l'écran et on remplit la fenêtre de bleu\n        pyxel.cls(12)\n        # on affiche le personnage à l'abscisse x_personnage et à l'ordonnée 255 - 16\n        if self.personnage_marche:\n            if pyxel.frame_count % 6 &lt; 3:\n                pyxel.blt(self.x_personnage, pyxel.height-16, 0, 0, 0, self.direction*16, 16)\n            else:\n                pyxel.blt(self.x_personnage, pyxel.height-16, 0, 16, 0, self.direction*16, 16)\n            self.personnage_marche = False\n        else:\n            pyxel.blt(self.x_personnage, pyxel.height-16, 0, 0, 0, self.direction*16, 16)\n\nApp()\n\n\n\nPersonnage qui se déplace\n\n\n\n\n\n\n\n\nEn conclusion\n\n\n\nNous avons vu dans ce tuto comment animer un personnage dans une application Pyxel en utilisant les touches du clavier. Nous avons également vu comment utiliser le fichier de ressources pour afficher une image du personnage avec les jambes positionnées différemment et ainsi donner une impression de marche. Nous avons enfin vu comment faire en sorte que le personnage regarde toujours dans la direction où il se déplace."
  },
  {
    "objectID": "posts/pyxelstudio/index.html",
    "href": "posts/pyxelstudio/index.html",
    "title": "Utiliser pyxelstudio.net pour créer des jeux en python avec pyxel",
    "section": "",
    "text": "Dans cet article, je vais vous présenter le site pyxelstudio.net et le module pyxel, qui vous permettent de créer facilement des jeux rétro avec python. Je vais vous montrer comment utiliser le site pyxelstudio.net pour éditer et exécuter du code en ligne, sans avoir besoin d’installer python ou pyxel sur votre ordinateur."
  },
  {
    "objectID": "posts/pyxelstudio/index.html#quest-ce-que-pyxelstudio.net",
    "href": "posts/pyxelstudio/index.html#quest-ce-que-pyxelstudio.net",
    "title": "Utiliser pyxelstudio.net pour créer des jeux en python avec pyxel",
    "section": "Qu’est-ce que pyxelstudio.net ?",
    "text": "Qu’est-ce que pyxelstudio.net ?\nPyxelstudio.net est un site web qui vous permet d’écrire et d’exécuter du code python avec le module pyxel directement dans votre navigateur. C’est très pratique si vous voulez rapidement tester vos idées de jeux sans avoir à installer python ou pyxel sur votre ordinateur. Pour accéder au site, il suffit de taper l’adresse https://www.pyxelstudio.net/ dans la barre d’adresse de votre navigateur. Vous arrivez alors sur la page d’accueil du site, qui vous propose plusieurs options. Je vous conseille de créer un compte (en cliquant sur “register”), car cela vous permettra de retrouver vos projets très facilement quand vous passez d’une machine à une autre. Ainsi, vous pouvez créer un nouveau projet, ouvrir un projet existant, ou encore consulter les exemples de jeux réalisés avec pyxel. Ce site a été développé par Laurent Abbal, professeur de NSI au lycée français international de Tokyo.\n\n\n\nPage d’accueil de pyxelstudio.net"
  },
  {
    "objectID": "posts/pyxelstudio/index.html#comment-créer-un-nouveau-projet",
    "href": "posts/pyxelstudio/index.html#comment-créer-un-nouveau-projet",
    "title": "Utiliser pyxelstudio.net pour créer des jeux en python avec pyxel",
    "section": "Comment créer un nouveau projet ?",
    "text": "Comment créer un nouveau projet ?\nPour créer un nouveau projet, cliquez sur le bouton “Create”. Vous arrivez alors sur l’interface principale du site, qui se compose de deux parties : à gauche, l’éditeur de code et à droite la fenêtre d’exécution.\n\nL’éditeur de code vous permet d’écrire votre code python avec pyxel. Il dispose de la coloration syntaxique pour vous faciliter la tâche.\nLa fenêtre d’exécution vous permet de voir le résultat de votre code, après avoir cliqué sur le bouton jaune situé au-dessus de la zone.\n\n\n\n\nVue d’ensemble de la page d’édition de www.pyxelstudio.net"
  },
  {
    "objectID": "posts/pyxelstudio/index.html#linterface-de-la-zone-dédition",
    "href": "posts/pyxelstudio/index.html#linterface-de-la-zone-dédition",
    "title": "Utiliser pyxelstudio.net pour créer des jeux en python avec pyxel",
    "section": "L’interface de la zone d’édition",
    "text": "L’interface de la zone d’édition\nOutre l’édition du code et son exécution, différentes actions sont possibles depuis cet écran.\n\n\nAccès au dashboard : liste des projets créés, avec la possibilité de les éditer et de les supprimer.\nDéfinition du nom du projet.\nListe des fichiers (fichiers python, fichiers de ressources, etc.) composant le projet.\nAfficher la zone d’édition du code. 5.Éditer le fichier de ressources : par défaut, c’est un fichier nommé res.pyxres, qui permet de définir des graphismes, des sons et de la musique pour le projet.\nAccès à l’édition de la description et de la documentation de votre projet.\nDéclaration des modules python utilisés par votre projet.\nAccès aux paramètres : permet, par exemple, de rendre votre projet public ou privé.\nAfficher un résumé des commandes pyxel existantes.\nEnregistrer le fichier en cours d’édition.\nGénérer un lien pour partager le projet.\n\nLorsqu’un programme est en cours d’exécution, on trouve deux boutons au-dessus de la zone d’exécution.\n\n\nMettre le jeu en plein écran.\nAfficher la console : utile pour l’affichage de certaines variables en phase de débogage.\n\nPour finir ce petit tour de l’interface du site, regardons de plus près l’affichage de la liste des fichiers d’un projet :\n\n\nCes deux boutons permettent respectivement de créer un nouveau fichier et de téléverser un fichier existant.\nLe fichier python de l’application. C’est lui qui contient le code du jeu et le bouton permet de l’éditer.\nLe fichier de ressource, créé automatiquement à la création d’un projet. Initialement vide. Le bouton permet de l’éditer.\nCes boutons permettent de télécharger les fichiers python et pyxres."
  },
  {
    "objectID": "posts/pyxelstudio/index.html#démonstration",
    "href": "posts/pyxelstudio/index.html#démonstration",
    "title": "Utiliser pyxelstudio.net pour créer des jeux en python avec pyxel",
    "section": "Démonstration",
    "text": "Démonstration\nPour vous montrer comment fonctionne le site pyxelstudio.net, écrivons un exemple simple de code pyxel, qui affiche un message “Hello Pyxel!” à l’écran. Ce code est tiré du fichier 01_hello_pyxel.py, qui fait partie des exemples fournis avec le module pyxel. Voici le code :\nimport pyxel\n\nclass App:\n    def __init__(self):\n        # initialisation de l'écran avec une taille de 160 x 120 pixels\n        pyxel.init(160, 120)\n        pyxel.run(self.update, self.draw)\n        \n    # définition de la fonction update, qui est appelée à chaque frame\n    def update(self):\n        pass\n\n    # définition de la fonction draw, qui est appelée à chaque frame après la fonction update\n    def draw(self):\n        # on efface l'écran avec la couleur 0 (noir)\n        pyxel.cls(0)\n        # on affiche le texte \"Hello Pyxel!\" à la position (55, 41) avec la couleur 7 (blanc)\n        pyxel.text(55, 41, \"Hello Pyxel!\", 7)\n        \n# on exécute le programme avec les fonctions update et draw\nApp()\nNous allons copier ce code dans l’éditeur de code du site pyxelstudio.net, puis cliquer sur le bouton “Run” pour l’exécuter. Nous voyons alors apparaître le message “Hello Pyxel!” à l’écran, comme prévu. Voilà, nous venons de réaliser notre première application avec pyxel ! C’était facile, non ?\n\n\n\nCopie d’écran de la sortie pyxel du code d’exemple"
  },
  {
    "objectID": "posts/pyxelstudio/index.html#quelles-sont-les-autres-fonctionnalités-du-site",
    "href": "posts/pyxelstudio/index.html#quelles-sont-les-autres-fonctionnalités-du-site",
    "title": "Utiliser pyxelstudio.net pour créer des jeux en python avec pyxel",
    "section": "Quelles sont les autres fonctionnalités du site ?",
    "text": "Quelles sont les autres fonctionnalités du site ?\nLe site pyxelstudio.net vous offre d’autres possibilités intéressantes, comme le partage de code (voir ci-dessus), la sauvegarde de projets, la visualisation des exemples, etc.\nSi vous voulez partager votre code avec d’autres personnes, vous pouvez cliquer sur le bouton de partage en haut à droite de la zone d’édition. Vous obtenez alors un lien que vous pouvez copier et envoyer à qui vous voulez. La personne qui reçoit le lien peut ainsi ouvrir votre code dans son navigateur et l’exécuter sans avoir à le télécharger. C’est très pratique pour montrer vos créations ou demander de l’aide. Je donnerai dans des articles suivants des conseils et des tutoriels pour la création de jeux avec pyxel dans pyxelstudio."
  },
  {
    "objectID": "posts/podcast_internet/index.html",
    "href": "posts/podcast_internet/index.html",
    "title": "Un podcast pour tout savoir sur l’histoire d’internet",
    "section": "",
    "text": "Voici un podcast de France Culture très intéressant, qui retrace l’histoire de l’internet de 1969 à nos jours en huit épisodes d’un quart d’heure.\n\n\n\nPersonne ou presque ne sait raconter l’histoire d’Internet. Julien Le Bot a eu envie d’essayer de vous raconter pourquoi.\n\n\nOn a parfois l’impression qu’Internet est entré presque par effraction dans nos vies au cours des années 1990, et est devenu aussi essentiel que l’électricité ou l’eau courante. En un demi-siècle, Internet s’est imposé comme une nécessité. Internet est partout, mais son histoire, son fonctionnement, son essence même, ne sont visibles nulle part. Techniquement, Internet nous relie. Mais est-on sûr de bien comprendre ce qu’on fabrique, peu à peu, depuis des années  ?\n\n\nOn vous propose de remonter aux origines de ce réseau des réseaux, où l’on croisera des individus épris d’utopie et de liberté aux États-Unis, mais aussi des ingénieurs entêtés en France face aux poids des télécoms, des chercheurs en ex-URSS appelés à échanger avec le monde libre, ou encore, en Chine… des fonctionnaires obsédés par le contrôle de l’information. Revenir sur ces moments fondateurs, c’est essentiel pour comprendre la portée intimement politique de cette infrastructure devenue mondiale. On ne parlera pas ici de Blockchain, de NFT ou de crypto : on revient aux origines.\n\n\n\nCes épisodes sont disponibles sur le site de Radio France."
  },
  {
    "objectID": "posts/metiers_dev/index.html",
    "href": "posts/metiers_dev/index.html",
    "title": "Les métiers du développement et de l’infrastructure",
    "section": "",
    "text": "Dans cette très bonne vidéo publiée sur la chaîne Youtube Cookie connecté, les différents métiers du développement et de l’infrastructure sont présentés.\n\n\nC’est l’occasion de découvrir les différences entre les différents métiers qui tournent autour du développement et du maintien de sites web."
  },
  {
    "objectID": "posts/lumniBDD/index.html",
    "href": "posts/lumniBDD/index.html",
    "title": "Lumni : cours sur les bases de données",
    "section": "",
    "text": "La plateforme Lumni propose deux vidéos très bien faites qui couvrent le programme de terminale NSI sur les bases de données.\n\n\n\n\nVidéo 1 : Qu’est-ce qu’une base de données relationnelle ?\n\n\n\n\n\n\n\n\n\nVidéo 2 : Interrogation d’une base de données relationnelle"
  },
  {
    "objectID": "posts/interview_gpt_2/index.html",
    "href": "posts/interview_gpt_2/index.html",
    "title": "Interview exclusive du ChatGPT de OpenAI (partie 2)",
    "section": "",
    "text": "Dans cette deuxième partie, nous abordons quelques questions techniques et informatiques.\n\n\nPeux-tu m’expliquer comment tu as été programmé ?\n\n\nJe suis un modèle de langage entraîné par OpenAI. Je suis capable de générer du texte en réponse à des questions ou des prompts donnés, grâce à un processus appelé “apprentissage profond”. Cela implique l’entraînement d’un réseau de neurones sur de grandes quantités de données textuelles afin de prédire les mots suivants dans une phrase en fonction des mots qui l’ont précédée. Ce processus me permet d’apprendre à générer du texte de manière cohérente et naturelle.\n\n\nTa méthode pour produire du texte revient donc à prévoir les mots suivants en fonction des mots précédents. Et tu peux faire cela grâce à l’analyse d’une grande quantité de textes que tu as faite pendant ton apprentissage.\n\n\nOui, c’est exact. Mon apprentissage repose sur l’analyse de grandes quantités de texte afin de comprendre les relations entre les mots et comment ils sont utilisés dans différents contextes. Je suis capable de générer du texte de manière cohérente et naturelle en utilisant ces connaissances pour prédire les mots qui viennent après ceux qui m’ont été donnés en entrée. Cela me permet de répondre à des questions et de produire du contenu de manière autonome.\n\n\n\n\nImage évoquant un réseau neuronal créée par DALL-E 2\n\n\n\nOn entend souvent parler de la notion d’apprentissage automatique concernant les logiciels d’intelligence artificielle. Peux-tu m’expliquer de quoi il s’agit ?\n\n\nL’apprentissage automatique est une technique qui permet à des ordinateurs de “apprendre” à partir de données, sans être explicitement programmés. Il existe différents types d’apprentissage automatique, mais en général, ils suivent tous les mêmes étapes de base.\n\n\nTout d’abord, il faut disposer d’une grande quantité de données sur lesquelles l’ordinateur va s’entraîner. Ces données doivent être organisées de manière que l’ordinateur puisse facilement les utiliser pour apprendre.\n\n\nEnsuite, un modèle d’apprentissage automatique est créé en utilisant ces données. Ce modèle est un ensemble d’algorithmes et de règles qui définissent comment l’ordinateur va apprendre à partir des données.\n\n\nUne fois que le modèle est créé, il peut être utilisé pour traiter de nouvelles données. L’ordinateur va utiliser les règles et les algorithmes du modèle pour analyser les données et en tirer des conclusions. Par exemple, si le modèle a été entraîné pour reconnaître des objets dans des images, il pourra être utilisé pour identifier des objets dans de nouvelles images qu’il n’a pas encore vues.\n\n\nEnfin, une fois que l’ordinateur a analysé les données et tiré des conclusions, les résultats de cette analyse peuvent être utilisés pour prendre des décisions ou effectuer des tâches. Par exemple, si le modèle a été entraîné pour détecter des fraudes bancaires, les résultats de l’analyse peuvent être utilisés pour bloquer les transactions suspectes.\n\n\nEn résumé, l’apprentissage automatique est un processus qui permet à un ordinateur d’apprendre à partir de données, de manière à effectuer des tâches ou à prendre des décisions sans être explicitement programmé pour cela.\n\n\nTu as utilisé tout à l’heure l’expression “apprentissage profond” : de quoi s’agit-il ?\n\n\nL’apprentissage profond est une technique d’apprentissage automatique qui permet à des algorithmes de modéliser des données complexes en utilisant des couches de calculs mathématiques. Ces couches, appelées “réseaux de neurones”, sont inspirées du fonctionnement du cerveau humain et sont capables de capturer des relations profondes dans les données. L’apprentissage profond peut être utilisé pour résoudre de nombreux types de tâches, comme la reconnaissance d’objets dans des images, la traduction automatique ou la génération de texte comme dans mon cas.\n\n\n\n\nImage évoquant un réseau neuronal créée par DALL-E 2\n\n\n\nPeux-tu m’expliquer davantage ce que sont les réseaux de neurones ?\n\n\nLes réseaux de neurones sont une technique d’apprentissage automatique qui s’inspire du fonctionnement du cerveau humain. Un réseau de neurones est composé de nombreux petits éléments appelés “neurones”, reliés entre eux par des “synapses”. Chaque neurone reçoit des entrées de la part d’autres neurones et produit une sortie en fonction de ces entrées et de certains poids associés à chaque synapse.\n\n\nPour entraîner un réseau de neurones, on utilise des données d’entraînement qui contiennent des exemples d’entrées et de sorties désirées. L’algorithme d’apprentissage du réseau de neurones va ajuster les poids des synapses de manière à minimiser l’erreur entre les sorties produites par le réseau et les sorties désirées. Ainsi, le réseau “apprend” à produire des sorties correctes pour les entrées données.\n\n\nUne fois qu’un réseau de neurones est entraîné, il peut être utilisé pour traiter de nouvelles données et produire des sorties en fonction de ces données. Par exemple, un réseau de neurones entraîné pour reconnaître des objets dans des images peut être utilisé pour identifier des objets dans de nouvelles images qu’il n’a pas encore vues.\n\n\nIl existe différents types de réseaux de neurones, chacun ayant ses propres caractéristiques et utilisations. Par exemple, les réseaux de neurones profonds (ou réseaux neuronaux profonds) sont des réseaux de neurones très complexes avec de nombreuses couches de neurones, qui peuvent être utilisés pour résoudre des problèmes très difficiles, comme la reconnaissance de la parole ou la traduction automatique.\n\n\nEn résumé, les réseaux de neurones sont une technique d’apprentissage automatique qui permet à un ordinateur d’apprendre à partir de données en ajustant les poids des synapses entre les neurones. Ils peuvent être utilisés pour résoudre des problèmes complexes en traitement du langage naturel, en vision par ordinateur, en reconnaissance de la parole, etc.\n\n\nJe suis passionné par la programmation et j’aimerais bien voir un exemple de code informatique, en Python, qui illustre le concept de réseau de neurones.\n\n\nVoici un exemple simple de code Python qui illustre le concept de réseau de neurones :\n\n# Import des bibliothèques nécessaires\nimport numpy as np\n\n# Définition des poids synaptiques\nsynaptic_weights = 2 * np.random.random((3, 1)) - 1\n\n# Fonction de propagation avant\ndef think(inputs):\n    inputs = inputs.astype(float)\n    output = 1 / (1 + np.exp(-np.dot(inputs, synaptic_weights)))\n    return output\n\n# Entraînement du réseau de neurones\nfor iteration in range(20000):\n    input_layer = np.array([[0,0,1], [1,1,1], [1,0,1], [0,1,1]])\n    output_layer = np.array([[0,1,1,0]]).T\n    output = think(input_layer)\n    error = output_layer - output\n    adjustments = np.dot(input_layer.T, error * output * (1 - output))\n    synaptic_weights += adjustments\n\n# Test du réseau de neurones\nprint(think(np.array([1,0,0])))\n\nCe code entraîne un petit réseau de neurones pour résoudre un problème simple de porte logique XOR. Le réseau est initialement créé avec des poids synaptiques aléatoires, puis est entraîné en ajustant ces poids pour minimiser l’erreur entre les sorties produites par le réseau et les sorties désirées. Enfin, le réseau est testé en lui donnant une nouvelle entrée pour vérifier qu’il produit la sortie correcte.\n\n\n\n\nImage évoquant un réseau neuronal créée par DALL-E 2\n\n\n\nCe code implémente un réseau de neurones simple utilisant la propagation avant (forward propagation). La fonction think() utilise une fonction d’activation sigmoïde pour produire une sortie en fonction des poids synaptiques donnés en entrée. Le réseau de neurones est entraîné en utilisant une boucle for sur un jeu de données d’entraînement. Enfin, le réseau est testé en lui donnant un ensemble de données d’entrée pour voir comment il se comporte.\n\n\nQu’est-ce qu’une fonction sigmoïde ?\n\n\nUne fonction sigmoïde est une fonction mathématique de forme en “S” utilisée en apprentissage automatique pour modéliser l’activité d’un seul neurone dans un réseau de neurones. Elle prend en entrée un scalaire ou un vecteur et produit une sortie comprise entre 0 et 1. Cela en fait une fonction d’activation idéale pour les réseaux de neurones, car elle permet d’obtenir une sortie binaire en fonction de seuils de probabilité. La fonction sigmoïde est généralement exprimée de la manière suivante :\n\n\n\\[ \\sigma(x) = \\frac{1}{1 + e^{-x}} \\]\n\n\nOù \\(x\\) est l’entrée et \\(\\sigma(x)\\) est la sortie. La fonction sigmoïde a la propriété intéressante qu’elle approche de 0 lorsque x est négatif et de 1 lorsque x est positif, ce qui en fait une fonction d’activation idéale pour les réseaux de neurones.\n\n\nJe trouve ce petit exemple de code très intéressant et il m’a permis de mieux comprendre le mécanisme. Mais les détails restent un peu abstraits… Notamment, je ne comprends pourquoi la variable ‘adjustments’ est calculée de cette façon.\n\n\nLa variable adjustments est utilisée pour mettre à jour les poids synaptiques du réseau de neurones. Cela se fait en utilisant l’erreur calculée entre la sortie attendue et la sortie obtenue du réseau, ainsi que la fonction d’activation sigmoïde. La formule utilisée pour calculer adjustments est la suivante :\n\n\n\\[ adjustments = \\sum(inputs * (error * output * (1 - output))) \\]\n\n\nOù inputs est le jeu de données d’entraînement, error est la différence entre la sortie attendue et la sortie obtenue, output est la sortie obtenue du réseau de neurones avant l’application de la fonction d’activation et 1 - output est la dérivée de la fonction sigmoïde. Cette formule est utilisée pour calculer les ajustements nécessaires des poids synaptiques afin de minimiser l’erreur du réseau de neurones.\n\n\nDans le code, ‘adjustments’ est obtenu par un produit scalaire, pas par une somme !\n\n\nVous avez raison ! La formule que j’ai donnée précédemment est incorrecte. En réalité, adjustments est calculé en utilisant un produit scalaire entre les entrées du jeu de données d’entraînement et l’erreur multipliée par la sortie du réseau avant l’application de la fonction d’activation et sa dérivée. La formule exacte utilisée dans le code est la suivante :\n\n\n\\[ adjustments = input.T * (error * output * (1 - output)) \\]\n\n\nOù input.T est la transposée des entrées du jeu de données d’entraînement, error est la différence entre la sortie attendue et la sortie obtenue, output est la sortie obtenue du réseau de neurones avant l’application de la fonction d’activation et 1 - output est la dérivée de la fonction sigmoïde. Je vous présente mes excuses pour l’erreur dans la formule que j’ai donnée précédemment.\n\n\nCe n’est pas grave tout le monde peut se tromper. C’est humain !\n\n\nMerci pour votre compréhension. Je suis heureux d’avoir pu vous aider à mieux comprendre le fonctionnement du réseau de neurones implémenté dans ce code. Si vous avez d’autres questions, n’hésitez pas à me les poser. Je ferai de mon mieux pour y répondre.\n\n\nIl y a encore une chose que je ne comprends pas. Pourquoi ‘1-output’ est la dérivée de la fonction sigmoïde ?\n\n\nLa dérivée d’une fonction mathématique est une autre fonction qui mesure la vitesse de changement de la fonction originale par rapport à son entrée. Pour la fonction sigmoïde, la dérivée peut être exprimée de la manière suivante :\n\n\n\\[ \\frac{d\\sigma(x)}{dx} = \\sigma(x)(1-\\sigma(x)) \\]\n\n\nOù σ(x) est la fonction sigmoïde et x est l’entrée. Cette expression mesure comment la sortie de la fonction sigmoïde change en fonction de l’entrée. En utilisant cette information, nous pouvons calculer les ajustements nécessaires des poids synaptiques pour minimiser l’erreur du réseau de neurones.\n\n\nAh oui d’accord ! Donc en fait, c’est ’output*(1-output)’ qui est la dérivée de la fonction sigmoïde !\n\n\nOui, c’est exact ! Dans le code, output représente la sortie du réseau de neurones avant l’application de la fonction d’activation, donc en utilisant l’expression de la dérivée de la fonction sigmoïde que j’ai donnée précédemment, nous pouvons calculer la dérivée de la fonction sigmoïde en utilisant output * (1 - output). Cette valeur est utilisée dans le calcul des ajustements des poids synaptiques pour minimiser l’erreur du réseau de neurones. J’espère que cela éclaire un peu mieux les choses pour vous.\n\n\nOui effectivement. Je te remercie pour cette conversation passionnante qui m’a permis d’en apprendre plus sur l’apprentissage automatique et sur les réseaux de neurones.\n\n\nJe suis ravi d’avoir pu vous aider. L’apprentissage automatique et les réseaux de neurones sont des domaines fascinants et il y a beaucoup à apprendre. Si vous avez d’autres questions, n’hésitez pas à me les poser. Je ferai de mon mieux pour y répondre.\n\n\n\n\nImage évoquant un réseau neuronal créée par DALL-E 2"
  },
  {
    "objectID": "posts/intel_verre/index.html",
    "href": "posts/intel_verre/index.html",
    "title": "Intel veut révolutionner les microprocesseurs avec un substrat en verre",
    "section": "",
    "text": "Les microprocesseurs sont au cœur de nos ordinateurs, smartphones, tablettes et autres appareils électroniques. Ils sont composés de millions, voire de milliards, de transistors qui réalisent des opérations logiques et arithmétiques à une vitesse vertigineuse. Mais ces transistors sont de plus en plus petits et difficiles à fabriquer, ce qui menace la loi de Moore, qui prédit que la puissance des microprocesseurs double tous les deux ans (voir cours de première NSI).\n\n\n\nCPU\n\n\nPour relever ce défi, Intel, le géant américain des semi-conducteurs, a annoncé avoir développé un nouveau substrat en verre pour remplacer le plastique actuellement utilisé. Le substrat est la base sur laquelle sont gravés les circuits des microprocesseurs. Il doit être plat, rigide et résistant à la chaleur et aux contraintes mécaniques.\nLe verre présente plusieurs avantages par rapport au plastique. Il est plus stable et supporte des températures plus élevées, ce qui permet de serrer davantage de puces sur un seul substrat sans qu’il se déforme. Il offre aussi une meilleure distribution de l’énergie et une transmission plus rapide des signaux, grâce à l’intégration d’interconnexions optiques qui remplacent le cuivre. Le verre permettrait ainsi de multiplier par dix la densité des interconnexions entre les puces.\nAvec ce nouveau substrat en verre, Intel espère pouvoir augmenter considérablement la densité des transistors au sein des microprocesseurs et créer le premier paquet contenant mille milliards de transistors d’ici 2030. Un paquet est un système sur un seul substrat composé de plusieurs puces qui peuvent avoir des fonctions différentes, comme la mémoire, le calcul ou la communication.\nCe projet ambitieux pourrait révolutionner le domaine des microprocesseurs et donner un nouveau souffle à la loi de Moore. Intel prévoit de lancer ses premiers produits commerciaux basés sur ce substrat en verre avant la fin de la décennie. Il faudra toutefois attendre les résultats des tests et des validations pour confirmer les performances et la fiabilité de cette technologie.\nLa vidéo ci-dessous explique cette innovation (vous pouvez afficher les sous-titres en français) :\n\n\nSource : Futura Sciences\nImage : Dan Williams de Pixabay"
  },
  {
    "objectID": "posts/histoireSE/index.html",
    "href": "posts/histoireSE/index.html",
    "title": "Histoire des systèmes d’exploitation",
    "section": "",
    "text": "Voici une sélection de quelques vidéos sur l’histoire des systèmes d’exploitations.\n\n\n\n\nHistoire d’Unix\n\n\n\n\n\n\nHistoire de Linux et de GNU-Linux\n\n\n\n\n\n\n\n\n\nHistoire de Windows"
  },
  {
    "objectID": "posts/futurecoder/index.html",
    "href": "posts/futurecoder/index.html",
    "title": "Futurecoder - Le code du futur, c’est vous !",
    "section": "",
    "text": "Voici un nouveau site pour apprendre les bases de Python. Les cours ont l’avantage d’être disponibles en français. Autre point fort, l’ensemble du site est libre, open-source et gratuit.\n\n\n\n\n\nDans la pratique, tout se fait dans le navigateur de façon interactive. Les contenus partent vraiment de zéro et vont pour l’instant jusqu’aux dictionnaires, en passant par un mini-projet de jeu de morpion.\n\n\n\n\nDes outils sont disponibles pour aider à l’apprentissage :\n\n\n\n\n\ndébogage facilité par l’utilisation de débogueurs graphiques (comme Python Tutor ou Bird’s Eye) ;\n\n\nmessages d’erreurs plus faciles à comprendre ;\n\n\ncode à remettre dans l’ordre en cas de blocage sur un exercice ;\n\n\nsolutions pas à pas.\n\n\n\n\n\nFuturecoder est donc un excellent outil pour apprendre à programmer en Python.\n\n\n\n\nAvec quelques fonctionnalités supplémentaires, comme la création de classes et de différents status d’utilisateurs (professeur, élève), il pourrait très bien à l’avenir être utilisé dans le cadre scolaire.\n\n\n\n\nPour en savoir plus sur toutes les fonctionnalités, regarder la vidéo ci-dessous :\n\n\n\n\n \n\nSource : https://korben.info/futurecoder-cours-gratuits-python.html et le site Futurecoder."
  },
  {
    "objectID": "posts/enquete_jeux_videos/index.html",
    "href": "posts/enquete_jeux_videos/index.html",
    "title": "Les Français et le Jeu Vidéo",
    "section": "",
    "text": "Le SELL, Syndicat des Éditeurs de Logiciels de Loisirs, dévoile les résultats de son étude annuelle « Les Français et le Jeu Vidéo » conduite par Médiamétrie.\n\n\n\n\nLes résultats remettent en cause certaines idées reçues sur les jeux vidéos.\n\n\n\n\n\nTous ces résultats, ainsi que l’article qui les accompagne est présenté de manière très positive. N’oublions pas que les auteurs sont les représentants de l’industrie des jeux vidéos. Ils ont donc tout intérêt à présenter cette activité sous son meilleur jour.\n\n\n\n\nLes atouts du jeu vidéo dans la stimulation de certaines capacités de réflexion et visuelles sont connus, mais leurs dangers ne doivent pas être oubliés. Le principal semble être le problème de l’addiction et du temps passé à jouer. Trop de temps passé à jouer peut provoquer des troubles du sommeil et de la concentration, un manque d’activité physique, voire une rupture de liens sociaux et un repli sur soi.\n\n\n\n\nL’OMS, Organisation Mondiale de la Santé, a classé les Troubles du jeu vidéo dans sa classification internationale des maladies depuis 2018.\n\n\n\n\nOn peut lire sur le site de l’OMS le paragraphe suivant :\n\n\n\n\n\n\nDes études montrent que le trouble du jeu vidéo ne touche qu’une petite partie des personnes qui utilisent des jeux numériques ou des jeux vidéo. Néanmoins, tout joueur doit être attentif au temps passé sur les jeux, en particulier si ses activités quotidiennes en pâtissent, ainsi qu’à tout changement physique ou psychologique, sur le plan social et celui de sa santé, qui pourrait être attribué à un comportement de jeu.\n\n\n\n\n\n\nIl convient donc de rester raisonnable en se fixant des limites de temps quotidien de jeu. Une heure par jour maximum semble être une bonne idée. D’une manière générale, c’est le temps total quotidien devant un écran qu’il est très conseillé de limiter.\n\n\n\n\nPour en savoir plus, quelques conseils sur ce site et beaucoup d’informations sur celui-ci."
  },
  {
    "objectID": "posts/carmin/index.html",
    "href": "posts/carmin/index.html",
    "title": "Un nouveau site vient de voir le jour : carmin.tv.",
    "section": "",
    "text": "Il s’agit d’une plateforme de mise à disposition de vidéos de conférences, de séminaires de recherches en mathématiques. On y trouve aussi des interviews de mathématiciennes et de mathématiciens.\n\n\nLe CARMIN (Centre d’Accueil et de Rencontres Mathématiques INternationales) regroupe quatre instituts français de renommée internationale :\n\n\n\nCentre International de Mathématiques Pures et Appliquées (CIMPA)\n\n\nCentre International de Rencontres Mathématiques (CIRM)\n\n\nInstitut des Hautes Études Scientifiques (IHÉS)\n\n\nInstitut Henri Poincaré (IHP)\n\n\n\nOn peut lire sur la page \"À propos\" de la plateforme :\n\n\n\nCes instituts prestigieux encouragent la recherche en mathématiques et ses interactions avec les autres sciences (physique, informatique, biologie, etc) en accueillant les chercheurs du monde entier pour des courts et longs séjours et en organisant des conférences et des écoles. Ensemble, ces centres ont créé une plateforme de diffusion audiovisuelle afin de préserver la valeur scientifique et pédagogique des événements qu’ils organisent et de la partager avec le monde entier. La plateforme est équipée d’un outil de recherche avancé qui permet aux utilisateurs de parcourir efficacement des milliers de vidéos enrichies et de trouver rapidement le meilleur contenu pour leurs demandes.\n\n\n\nSi la plupart des vidéos proposées sont haut perchées, d’un niveau recherche universitaire et, donc, inaccessibles au grand public, on trouve aussi quelques conférences de vulgarisation.\n\n\nParmi les 4611 vidéos en ligne à l’heure où j’écris ces lignes, des filtres situés dans la colonne de gauche permettent de sélectionner la langue (anglais ou français) et le niveau des auditeurs. Par exemple, pour une audience \"General Public\" en français, il reste 124 vidéos disponibles.\n\n\nQuelques exemples de vidéos intéressantes et \"grand public\" (quoique…) :\n\n\n\n\n\n“Démocratie, dictature … et mathématiques”, de Gérard Grancher.\n\n\n\n\n\n\n\n“Fermat, Mersenne, factorisation et nombres parfaits”, de Daniel Perrin.\n\n\n\n\n\n\n\n“Le triangle de Pascal et ses propriétés”, de Christophe Soulé.\n\n\n\n\n\n\n\n“Georg Cantor et les infinis”, de Patrick Dehornoy.\n\n\n\n\n\n\nSource : Unidivers"
  },
  {
    "objectID": "posts/bobylapointe/index.html",
    "href": "posts/bobylapointe/index.html",
    "title": "Boby Lapointe, poète mathématicien",
    "section": "",
    "text": "Dans une vidéo de France Musique intitulée Boby Lapointe : la science du poète mathématicien (disponible sur YouTube ici), cet aspect méconnu de son génie est exploré, mettant en lumière son invention et son approche atypique des nombres."
  },
  {
    "objectID": "posts/bobylapointe/index.html#exemples-dutilisation",
    "href": "posts/bobylapointe/index.html#exemples-dutilisation",
    "title": "Boby Lapointe, poète mathématicien",
    "section": "Exemples d’utilisation",
    "text": "Exemples d’utilisation\nVoyons maintenant quelques exemples pour mieux comprendre ce système :\n\nLe nombre 71 en décimal s’écrit 47 en hexadécimal, ce qui donne BOBI en bibi-binaire.\nL’année 2018 s’écrit 7E2 en hexadécimal, soit BIDEHE en bibi-binaire.\nUn nombre plus grand comme 584 623 705 671 s’écrit 881E49CE47 en hexadécimal, ce qui donne la phrase mélodieuse “KOKOHADEBOKADODEBOBI” en bibi-binaire.\n\nLe principal intérêt du bibi-binaire est de créer des noms de nombres agréables à l’oreille, dans l’esprit des jeux de mots chers à Boby Lapointe. Il permet également de représenter de grands nombres de manière plus concise que le système décimal.\nCependant, malgré son originalité, ce système reste peu pratique pour une utilisation quotidienne. Il demeure néanmoins un bel exemple de la créativité mathématique de Boby Lapointe, mêlant rigueur et fantaisie.\n\nBonus : la playlist Boby Lapointe\n\n\n\n\nPour aller plus loin :\n\nArticle sur le site de France Musique accompagnant la vidéo mentionnée ici\nhttps://fr.vikidia.org/wiki/Syst%C3%A8me_bibi-binaire\nhttps://graner.name/nicolas/nombres/bibibinaire.php\nhttps://pi.ac3j.fr/boby-lapointe/"
  },
  {
    "objectID": "posts/2025_03_27_Prix_Abel/index.html",
    "href": "posts/2025_03_27_Prix_Abel/index.html",
    "title": "Le “Nobel des maths” décerné au Japonais Masaki Kashiwara",
    "section": "",
    "text": "Le monde des mathématiques est en ébullition ! Le prestigieux prix Abel, souvent considéré comme l’équivalent du prix Nobel dans cette discipline, a été attribué au mathématicien japonais Masaki Kashiwara.\n\n\n\nMasaki Kashiwara (crédit : Peter Bagde / Typos1 / The Abel Prize)\n\n\nSelon l’article de La Recherche (que vous pouvez consulter ici), cette récompense vient couronner les travaux fondamentaux de M. Kashiwara en analyse algébrique et en théorie des représentations. Plus précisément, elle salue son développement de la théorie des D-modules, un outil puissant qui permet d’étudier les équations différentielles avec des méthodes algébriques, et sa découverte des bases cristallines.\nLes D-modules, au cœur de l’œuvre de Kashiwara, transforment l’étude des équations différentielles en un problème d’algèbre, permettant ainsi d’appliquer des techniques sophistiquées issues de la géométrie algébrique. Cette approche a révolutionné notre compréhension de ces équations, qui sont omniprésentes dans toutes les sciences, de la physique à l’économie.\nQuant aux bases cristallines, elles offrent une perspective nouvelle sur les représentations des groupes quantiques. Ces groupes, qui généralisent les groupes de symétrie classiques, jouent un rôle essentiel en physique théorique, notamment dans l’étude des phénomènes quantiques. Les bases cristallines de Kashiwara ont permis de simplifier considérablement l’étude de ces représentations, révélant des structures cachées et ouvrant la voie à de nouvelles découvertes. Elles fournissent un cadre plus “simple” pour comprendre ces objets complexes, un peu comme si l’on passait de l’étude d’un solide complexe à celle de sa structure atomique sous-jacente.\nLes contributions de Kashiwara ont non seulement enrichi ces domaines, mais ont également ouvert des perspectives inattendues, reliant des branches des mathématiques qui semblaient auparavant éloignées. Il a créé des ponts entre l’analyse algébrique, la théorie des représentations, la géométrie algébrique et la physique mathématique, démontrant ainsi l’unité profonde des mathématiques.\nL’annonce de ce prix prestigieux met en lumière l’importance des contributions de Masaki Kashiwara au domaine des mathématiques. Ses recherches ont ouvert de nouvelles perspectives et ont eu un impact considérable sur de nombreux domaines connexes.\nLe prix Abel, créé en 2002, honore les mathématiciens pour l’excellence de leurs travaux. Il est décerné chaque année par l’Académie norvégienne des sciences et des lettres. Cette institution prestigieuse, fondée en 1857, a pour mission de promouvoir la recherche scientifique et les études humanistes en Norvège. Le prix Abel, qui porte le nom du mathématicien norvégien Niels Henrik Abel (1802-1829), a été établi pour combler l’absence d’un prix Nobel en mathématiques. La décision d’attribuer le prix est prise par un comité international de mathématiciens renommés, garantissant ainsi la reconnaissance des contributions les plus exceptionnelles à ce domaine."
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html",
    "href": "posts/2024_12_19_algos_interview/index.html",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "",
    "text": "Les algorithmes, autrefois domaine réservé des mathématiciens, ont connu une ascension fulgurante depuis les années 1970 avec la démocratisation de l’informatique. Aujourd’hui, ils sont omniprésents, façonnant notre quotidien et alimentant les avancées de l’intelligence artificielle. Mais que sont-ils exactement ? Comment ont-ils évolué ? Et quels défis posent-ils à notre société ?\n\n\n\nImage de rawpixel.com sur Freepik"
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#introduction",
    "href": "posts/2024_12_19_algos_interview/index.html#introduction",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "",
    "text": "Les algorithmes, autrefois domaine réservé des mathématiciens, ont connu une ascension fulgurante depuis les années 1970 avec la démocratisation de l’informatique. Aujourd’hui, ils sont omniprésents, façonnant notre quotidien et alimentant les avancées de l’intelligence artificielle. Mais que sont-ils exactement ? Comment ont-ils évolué ? Et quels défis posent-ils à notre société ?\n\n\n\nImage de rawpixel.com sur Freepik"
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#définition-et-rôle-des-algorithmes",
    "href": "posts/2024_12_19_algos_interview/index.html#définition-et-rôle-des-algorithmes",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "Définition et rôle des algorithmes",
    "text": "Définition et rôle des algorithmes\nComme l’explique Claire Mathieu, directrice de recherche CNRS et experte en algorithmique, dans une interview pour le site de l’EPI, un algorithme est une méthode, une suite d’instructions élémentaires, qui permet de résoudre un problème pas à pas. C’est un concept simple, mais d’une puissance extraordinaire. Pensez à la méthode d’addition avec retenue que vous avez apprise à l’école primaire : c’est un algorithme qui vous permet de réaliser n’importe quelle addition.\n\n\n\nClaire MATHIEU\n\n\nLa recherche en algorithmique consiste à concevoir de nouveaux algorithmes ou à analyser ceux qui existent déjà pour comprendre leurs propriétés et les améliorer. Claire Mathieu, par exemple, se spécialise dans les algorithmes d’approximation. Ces algorithmes sont conçus pour trouver des solutions suffisamment bonnes à des problèmes complexes, pour lesquels la recherche de la solution optimale serait trop longue ou impossible. Imaginez un déménageur qui doit optimiser le remplissage de son camion : une solution approximative, mais rapide est bien plus utile qu’une solution parfaite qui prendrait des heures à calculer. Ces problèmes sont dits « NP-difficiles », comme l’explique l’article."
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#une-histoire-riche-et-des-avancées-majeures",
    "href": "posts/2024_12_19_algos_interview/index.html#une-histoire-riche-et-des-avancées-majeures",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "Une histoire riche et des avancées majeures",
    "text": "Une histoire riche et des avancées majeures\n\n\n\nL’histoire des algorithmes ne date pas d’hier. Elle remonte à des siècles, avec des figures comme Al-Khwarizmi au 9e siècle, dont le nom a donné le mot « algorithme ». Il a formalisé des méthodes de résolution de problèmes mathématiques, posant les bases de ce qui allait devenir une discipline majeure.\n\n\n\n\n\nAl-Khwarizmi\n\n\n\n\n\nUn tournant majeur a eu lieu après la Seconde Guerre mondiale, avec la nécessité de résoudre des problèmes logistiques complexes pour la reconstruction. C’est à cette époque, en 1947, que George Dantzig a inventé l’algorithme du simplexe, un outil puissant pour l’optimisation linéaire, encore utilisé aujourd’hui.\n\n\n\n\n\n\nL’algorithme du simplexe : trouver le meilleur chemin\n\n\n\nImaginez que vous êtes dans un labyrinthe en 3D avec de nombreuses salles reliées par des couloirs. Chaque salle représente une solution possible à un problème et la hauteur de la salle représente la qualité de cette solution (plus c’est haut, mieux c’est). Votre objectif est de trouver la salle la plus haute, la meilleure solution.\nL’algorithme du simplexe, c’est un peu comme une méthode pour explorer ce labyrinthe de manière intelligente.\nVoici comment il fonctionne :\n\nPoint de départ : Vous commencez dans une salle au hasard, une solution initiale.\nRegarder autour : Vous regardez toutes les salles voisines, celles directement connectées à la vôtre par un couloir.\nMonter : Si une salle voisine est plus haute que la vôtre, vous vous y déplacez. C’est comme si vous choisissiez la meilleure solution parmi celles qui sont immédiatement accessibles.\nRépéter : Vous répétez les étapes 2 et 3, en vous déplaçant de salle en salle, toujours vers une salle plus haute.\nSommet : Vous continuez à monter jusqu’à atteindre une salle pour laquelle aucune des salles voisines n’est plus haute. Vous avez trouvé un sommet, une solution optimale localement !\n\nEn résumé : L’algorithme du simplexe trouve la meilleure solution en se déplaçant de proche en proche, en choisissant toujours la meilleure option parmi les solutions voisines, jusqu’à atteindre un sommet. Il est possible que l’on se retrouve bloqué dans un optimum local, qui n’est pas la solution optimale globale, dans ce cas, l’algorithme recommence en partant d’un nouveau point de départ.\nC’est comme un alpiniste qui gravit une montagne en suivant toujours le chemin le plus ascendant, jusqu’à atteindre un sommet. Bien sûr, dans la réalité, les problèmes traités par l’algorithme du simplexe sont bien plus complexes que des labyrinthes en 3D, mais le principe reste le même. C’est une méthode puissante pour trouver la meilleure solution à des problèmes d’optimisation, utilisée dans de nombreux domaines comme la logistique, la finance ou la production industrielle.\n\n\nMais c’est dans les années 1970 que les algorithmes ont véritablement pris leur essor, portés par la puissance croissante des ordinateurs. En 1971, Stephen Cook a formalisé la notion de « NP-difficulté », un concept clé de la théorie de la complexité, qui a révolutionné l’approche des problèmes algorithmiques. Richard Karp, en 1972, a ensuite identifié 21 problèmes « NP-complets », jetant les bases d’une conjecture fondamentale, « P est différent de NP », qui reste à ce jour un des grands mystères non résolus de l’informatique.\n\n\n\n\n\n\nProblèmes NP-complets et la grande question P vs NP\n\n\n\nEn informatique, il y a des problèmes faciles à résoudre et des problèmes difficiles. Pour les classer, on s’intéresse à deux grandes catégories : P et NP.\nP : Les problèmes “faciles”\nImaginez que vous avez une liste de nombres et que vous voulez la trier par ordre croissant. C’est un problème “facile”, car il existe des algorithmes rapides pour le faire, même si la liste est très longue. On dit que ce problème appartient à la catégorie P (pour “Polynomial”). En gros, le temps nécessaire pour le résoudre augmente de manière raisonnable avec la taille du problème.\nNP : Les problèmes “vérifiables”\nMaintenant, imaginez un puzzle complexe, comme un Sudoku géant. Si quelqu’un vous donne une solution, vous pouvez facilement vérifier si elle est correcte en regardant si les règles du jeu sont respectées. Mais trouver la solution vous-même peut être très long et difficile ! On dit que ce problème appartient à la catégorie NP (pour “Non-déterministe Polynomial”). En gros, on peut vérifier une solution rapidement, mais trouver la solution peut prendre un temps qui explose avec la taille du problème.\nNP-complets : Les problèmes les plus difficiles de NP\nParmi les problèmes NP, il y a une sous-catégorie spéciale : les problèmes NP-complets. Ce sont les plus difficiles de tous les problèmes NP. Si vous trouvez un algorithme rapide pour résoudre un seul problème NP-complet, alors vous aurez trouvé un algorithme rapide pour résoudre tous les problèmes NP !\nP = NP : Le grand mystère\nC’est là qu’arrive la grande question à un million de dollars : P est-il égal à NP ? Autrement dit, est-ce que tous les problèmes dont on peut vérifier la solution rapidement (NP) peuvent aussi être résolus rapidement (P) ?\n\nSi P = NP : Cela voudrait dire qu’il existe des algorithmes rapides, encore inconnus, pour résoudre tous les problèmes NP, y compris les NP-complets. Ce serait une révolution, car de nombreux problèmes importants, comme l’optimisation de tournées de livraison ou la recherche de nouveaux médicaments, deviendraient beaucoup plus faciles à résoudre.\nSi P ≠ NP : Cela voudrait dire que certains problèmes sont fondamentalement difficiles à résoudre, même si on peut vérifier une solution rapidement. C’est ce que pense la plupart des informaticiens, mais personne n’a encore réussi à le prouver.\n\nEn résumé : La question P vs NP est l’un des plus grands mystères de l’informatique et des mathématiques. Sa résolution aurait des conséquences majeures sur de nombreux domaines scientifiques et industriels. C’est un défi qui stimule la recherche depuis des décennies !"
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#des-découvertes-récentes-et-des-impacts-concrets",
    "href": "posts/2024_12_19_algos_interview/index.html#des-découvertes-récentes-et-des-impacts-concrets",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "Des découvertes récentes et des impacts concrets",
    "text": "Des découvertes récentes et des impacts concrets\nParmi les avancées plus récentes, l’algorithme de chiffrement RSA, inventé en 1978 par Rivest, Shamir et Adleman, a révolutionné la sécurité des communications sur Internet. Il permet d’échanger des messages chiffrés sans avoir à échanger une clé secrète au préalable, grâce à l’utilisation d’une clé publique et d’une clé privée (pour en savoir plus, suivre le lien situé sous la photo ci-dessous).\n\n\n\nRSA : Ron Rivest, Adi Shamir, Len Adleman Courtesy of Ron Rivest (source Intersitices.info)\n\n\nL’arrivée du big data a également nécessité de nouveaux types d’algorithmes, capables de traiter des flux massifs de données. L’algorithme de Flajolet et Martin, datant de 1985, est un exemple marquant. Il permet d’estimer le nombre d’éléments distincts dans un flux de données, ce qui est crucial pour des applications comme la détection d’anomalies dans le trafic réseau.\nL’impact des algorithmes ne se limite pas à l’informatique. En biologie moléculaire, par exemple, ils ont permis d’accélérer le séquençage des génomes, ouvrant des perspectives inédites pour la recherche médicale."
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#des-défis-éthiques-et-sociétaux",
    "href": "posts/2024_12_19_algos_interview/index.html#des-défis-éthiques-et-sociétaux",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "Des défis éthiques et sociétaux",
    "text": "Des défis éthiques et sociétaux\nL’omniprésence des algorithmes dans notre société soulève des questions éthiques et sociétales importantes. Comme le souligne Claire Mathieu, la rapidité et l’efficacité ne suffisent plus. Les algorithmes doivent aussi être transparents et équitables. Mais comment garantir cette transparence ? Ouvrir le code ne suffit pas. Il faut, selon Claire Mathieu, une réflexion approfondie, impliquant scientifiques et citoyens, pour définir ce qu’est un algorithme transparent et quelles garanties sont attendues.\n\n\n\nArticle paru dans le journal Le Monde en 2018\n\n\nLes algorithmes peuvent même influencer le fonctionnement démocratique, comme le montre l’exemple du redécoupage électoral aux États-Unis. L’utilisation d’algorithmes pour optimiser ce redécoupage, en fonction de lois conçues avant l’ère numérique, pose des risques de manipulation des résultats électoraux."
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#les-enjeux-de-demain",
    "href": "posts/2024_12_19_algos_interview/index.html#les-enjeux-de-demain",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "Les enjeux de demain",
    "text": "Les enjeux de demain\nL’intelligence artificielle et les réseaux de neurones profonds ouvrent de nouveaux défis pour l’algorithmique. Comprendre comment les résultats de ces algorithmes dépendent des données d’entrée est un enjeu majeur. Claire Mathieu suggère d’appliquer ces algorithmes à des problèmes classiques déjà bien étudiés pour mieux les comprendre.\nEnfin, la lutte contre le réchauffement climatique va, selon elle, devenir un domaine d’application crucial pour l’algorithmique. Il faudra inventer des algorithmes moins gourmands en ressources et en énergie, et capables de nous aider à réduire notre empreinte carbone.\n\n\n\nImage de fr.freepik.com"
  },
  {
    "objectID": "posts/2024_12_19_algos_interview/index.html#conclusion",
    "href": "posts/2024_12_19_algos_interview/index.html#conclusion",
    "title": "Les algorithmes : une épopée à travers le temps",
    "section": "Conclusion",
    "text": "Conclusion\nEn conclusion, les algorithmes sont bien plus que de simples outils techniques. Ils sont au cœur d’une épopée scientifique et sociétale qui façonne notre présent et notre futur. Les comprendre, les maîtriser et les utiliser de manière éthique est un défi majeur pour les années à venir. L’interview de Claire Mathieu nous offre un éclairage précieux sur cette histoire et sur les enjeux qui nous attendent."
  },
  {
    "objectID": "politique_conf.html",
    "href": "politique_conf.html",
    "title": "Politique de confidentialité",
    "section": "",
    "text": "L’adresse de ce site web est : https://blog.flallemand.fr."
  },
  {
    "objectID": "politique_conf.html#qui-sommes-nous",
    "href": "politique_conf.html#qui-sommes-nous",
    "title": "Politique de confidentialité",
    "section": "",
    "text": "L’adresse de ce site web est : https://blog.flallemand.fr."
  },
  {
    "objectID": "politique_conf.html#cookies",
    "href": "politique_conf.html#cookies",
    "title": "Politique de confidentialité",
    "section": "Cookies",
    "text": "Cookies\nCe site, en ce qui concerne son fonctionnement propre, n’utilise pas de cookies."
  },
  {
    "objectID": "politique_conf.html#contenu-intégré-dautres-sites-web",
    "href": "politique_conf.html#contenu-intégré-dautres-sites-web",
    "title": "Politique de confidentialité",
    "section": "Contenu intégré d’autres sites Web",
    "text": "Contenu intégré d’autres sites Web\nLes articles de ce site peuvent inclure du contenu intégré (par exemple des vidéos, des images, des articles, etc.). Le contenu intégré provenant d’autres sites web se comporte exactement de la même manière que si le visiteur avait visité l’autre site web.\nCes sites web peuvent collecter des données vous concernant, utiliser des cookies, intégrer un suivi supplémentaire par des tiers et surveiller votre interaction avec ce contenu intégré, y compris le suivi de votre interaction avec le contenu intégré si vous avez un compte et êtes connecté à ce site web."
  },
  {
    "objectID": "politique_conf.html#données-personnelles",
    "href": "politique_conf.html#données-personnelles",
    "title": "Politique de confidentialité",
    "section": "Données personnelles",
    "text": "Données personnelles\nCe site ne recueille aucune donnée personnelle de ses visiteurs.\nCe site participe et est conforme à l’ensemble des Spécifications et Politiques du Transparency & Consent Framework de l’IAB Europe. Il utilise la Consent Management Platform n°92.\nVous pouvez modifier vos choix à tout moment en cliquant bas à droite de l’écran."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "À propos",
    "section": "",
    "text": "Site personnel de Fabrice LALLEMAND\nLycée Émile DUCLAUX, 16 avenue Henri MONDOR, 15000 AURILLAC\nTéléphone : 04 71 48 22 22.\nCe site est hébergé par o2switch\nPolitique de confidentialité"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bienvenue !",
    "section": "",
    "text": "Trier par\n      Ordre par défaut\n      \n        Titre\n      \n      \n        Date - Le plus ancien\n      \n      \n        Date - Le plus récent\n      \n      \n        Auteur·rice\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nCorrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 2\n\n\n\nNSI\n\nAnnales\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n23 juin 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nCorrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1\n\n\n\nNSI\n\nAnnales\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n18 juin 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nCorrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1\n\n\n\nMathématiques\n\nAnnales\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n17 juin 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nTableaux de variations faciles en LaTeX\n\n\n\nMathématiques\n\nLaTeX\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n16 juin 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nLe “Nobel des maths” décerné au Japonais Masaki Kashiwara\n\n\n\nMathématiques\n\nActualités\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n27 mars 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nHarold Hotelling : Un mathématicien au service de l’économie\n\n\n\nMathématiques\n\nHistoire\n\nPodcast\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n28 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculus Rhapsody : Quand l’analyse devient une chanson entraînante !\n\n\n\nMathématiques\n\nHumour\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n6 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nTuto IA pour les profs : Créer des exercices à partir de podcasts.\n\n\n\nIA\n\nTutos\n\nPodcast\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n4 févr. 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes algorithmes : une épopée à travers le temps\n\n\n\nAlgorithmique\n\nInformatique\n\nIA\n\nSociété\n\n\n\nDécouvrez l’histoire des algorithmes, de leurs origines mathématiques à leur omniprésence dans notre société moderne, et les enjeux éthiques et sociétaux qu’ils soulèvent.\n\n\n\nF. LALLEMAND\n\n\n26 déc. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nNos amis Google, Wikipédia et ChatGPT sont-ils vraiment impartiaux ?\n\n\n\nInformatique\n\nInternet\n\nSociété\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n19 déc. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nTuto pyxel : Pluie de cerises et score\n\n\n\nPython\n\nNSI\n\nProgrammation\n\nPyxel\n\nNuit du code\n\n\n\nFaire pleuvoir des cerises dans notre application Pyxel\n\n\n\nF. LALLEMAND\n\n\n26 nov. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecord battu pour les nombres premiers !\n\n\n\nActualités\n\nMathématiques\n\n\n\nLe record du plus grand nombre premier a été récemment battu.\n\n\n\nF. LALLEMAND\n\n\n5 nov. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nLa méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !\n\n\n\nMathématiques\n\nPython\n\nProgrammation\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n8 oct. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nDécouvrir les liens entre les maths et la musique\n\n\n\nHistoire\n\nMathématiques\n\nPodcast\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n3 oct. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoby Lapointe, poète mathématicien\n\n\n\nInformatique\n\nHistoire\n\nMathématiques\n\nVidéothèque\n\n\n\nBoby Lapointe, bien connu pour ses chansons truffées de jeux de mots et d’humour absurde, est un personnage inclassable du paysage artistique français des années 1950 et…\n\n\n\nF. LALLEMAND\n\n\n1 oct. 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\nTuto pyxel : Ajouter un fond\n\n\n\nPython\n\nNSI\n\nProgrammation\n\nPyxel\n\nNuit du code\n\n\n\nAjouter un fond à notre application Pyxel\n\n\n\nF. LALLEMAND\n\n\n22 oct. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nTribune du collectif Maths & Sciences\n\n\n\nActualités\n\nOrientation\n\n\n\nRéforme du lycée : petites failles ou grandes fractures ?\n\n\n\nF. LALLEMAND\n\n\n19 oct. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’histoire de la Free Software Foundation (FSF)\n\n\n\nNSI\n\nInformatique\n\nHistoire\n\nLinux\n\n\n\nUne plongée dans le passé du mouvement du logiciel libre\n\n\n\nF. LALLEMAND\n\n\n23 sept. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntel veut révolutionner les microprocesseurs avec un substrat en verre\n\n\n\nNSI\n\nActualités\n\n\n\nIntel a annoncé une nouvelle technologie de fabrication de microprocesseurs qui utilise un substrat en verre au lieu du silicium traditionnel. Cette technologie permettrait…\n\n\n\nF. LALLEMAND\n\n\n21 sept. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nTuto pyxel : Animer un personnage\n\n\n\nPython\n\nNSI\n\nProgrammation\n\nPyxel\n\nNuit du code\n\n\n\nAnimer un personnage dans une application Pyxel\n\n\n\nF. LALLEMAND\n\n\n2 sept. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nUtiliser pyxelstudio.net pour créer des jeux en python avec pyxel\n\n\n\nPython\n\nNSI\n\nProgrammation\n\nPyxel\n\nNuit du code\n\n\n\nPréparation à la Nuit du Code\n\n\n\nF. LALLEMAND\n\n\n1 sept. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nTuto pyxel : code de base\n\n\n\nPython\n\nNSI\n\nProgrammation\n\nPyxel\n\nNuit du code\n\n\n\nStructure de base d’une application pyxel\n\n\n\nF. LALLEMAND\n\n\n18 juin 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython match\n\n\n\nPython\n\nNSI\n\nProgrammation\n\n\n\nPrésentation de l’instruction match ... case en Python\n\n\n\nF. LALLEMAND\n\n\n30 janv. 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterview exclusive du ChatGPT de OpenAI (partie 1)\n\n\n\nInformatique\n\nIA\n\n\n\nPremiers contacts\n\n\n\nF. LALLEMAND\n\n\n8 déc. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterview exclusive du ChatGPT de OpenAI (partie 2)\n\n\n\nInformatique\n\nIA\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n8 déc. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nLOL - LOgiciel Libre, une affaire sérieuse\n\n\n\nInformatique\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n30 nov. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nUn podcast pour tout savoir sur l’histoire d’internet\n\n\n\nInformatique\n\nHistoire\n\nRéseaux\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n29 nov. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes métiers du développement et de l’infrastructure\n\n\n\nInformatique\n\nOrientation\n\nNSI\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n20 nov. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes Français et le Jeu Vidéo\n\n\n\nInformatique\n\nOrientation\n\nNSI\n\nJeux\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n17 nov. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nFuturecoder - Le code du futur, c’est vous !\n\n\n\nInformatique\n\nPython\n\nNSI\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n1 nov. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nParticiper aux trophées NSI\n\n\n\nInformatique\n\nPython\n\nNSI\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n8 sept. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nLumni : cours sur les bases de données\n\n\n\nInformatique\n\nNSI\n\nBDD\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n25 juil. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nLa chaîne YouTube codeur-pro\n\n\n\nInformatique\n\nNSI\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n2 juil. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistoire de l’informatique\n\n\n\nInformatique\n\nNSI\n\nVidéothèque\n\nHistoire\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n2 juil. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistoire des systèmes d’exploitation\n\n\n\nInformatique\n\nNSI\n\nHistoire\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n2 juil. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes transistors expliqués\n\n\n\nInformatique\n\nNSI\n\nVidéothèque\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n2 juil. 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nMesurer la quantité d’information\n\n\n\nInformatique\n\nNSI\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n19 juin 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nMesurer le temps d’exécution d’un fragment de code\n\n\n\nInformatique\n\nNSI\n\nPython\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n5 juin 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\nUn nouveau site vient de voir le jour : carmin.tv.\n\n\n\nMathématiques\n\nVidéothèque\n\nHistoire\n\n\n\n\n\n\n\nF. LALLEMAND\n\n\n1 janv. 2022\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "posts/mathsmusique/index.html",
    "href": "posts/mathsmusique/index.html",
    "title": "Découvrir les liens entre les maths et la musique",
    "section": "",
    "text": "France Musique nous propose une série captivante de huit épisodes explorant les liens surprenants entre la musique et les mathématiques. Diffusée pendant l’été 2024 tous les mercredis à 8 h 10, cette série intitulée « Musique + maths » est animée par Pierre-Yves Georges et promet de réconcilier même les plus réticents avec les mathématiques."
  },
  {
    "objectID": "posts/mathsmusique/index.html#de-la-forge-antique-aux-compositeurs-modernes",
    "href": "posts/mathsmusique/index.html#de-la-forge-antique-aux-compositeurs-modernes",
    "title": "Découvrir les liens entre les maths et la musique",
    "section": "De la forge antique aux compositeurs modernes",
    "text": "De la forge antique aux compositeurs modernes\nLe premier épisode nous plonge dans les origines lointaines de cette relation, remontant jusqu’à une forge antique. Ce point de départ inattendu ouvre la voie à une exploration fascinante de l’évolution de ce lien au fil des siècles."
  },
  {
    "objectID": "posts/mathsmusique/index.html#les-grands-noms-à-la-croisée-des-disciplines",
    "href": "posts/mathsmusique/index.html#les-grands-noms-à-la-croisée-des-disciplines",
    "title": "Découvrir les liens entre les maths et la musique",
    "section": "Les grands noms à la croisée des disciplines",
    "text": "Les grands noms à la croisée des disciplines\nLa série met en lumière des personnalités emblématiques qui ont marqué à la fois le monde de la musique et celui des mathématiques :\n\nJohann Sebastian Bach, dont l’œuvre continue d’être étudiée pour sa dimension mathématique.\nErnest Ansermet, chef d’orchestre renommé qui était initialement professeur de mathématiques.\nAlbert Einstein, célèbre physicien, mais aussi mélomane passionné, dont la musique aurait peut-être inspiré certaines théories révolutionnaires."
  },
  {
    "objectID": "posts/mathsmusique/index.html#probabilités-et-hasard-en-composition",
    "href": "posts/mathsmusique/index.html#probabilités-et-hasard-en-composition",
    "title": "Découvrir les liens entre les maths et la musique",
    "section": "Probabilités et hasard en composition",
    "text": "Probabilités et hasard en composition\nPlusieurs épisodes explorent comment les concepts mathématiques ont influencé la création musicale :\n\nIannis Xenakis, compositeur d’origine grecque, a intégré les probabilités dans ses compositions.\nDe Mozart à Pierre Boulez, le hasard, notion mathématique, a joué un rôle important dans la composition."
  },
  {
    "objectID": "posts/mathsmusique/index.html#la-beauté-des-mathématiques-en-musique",
    "href": "posts/mathsmusique/index.html#la-beauté-des-mathématiques-en-musique",
    "title": "Découvrir les liens entre les maths et la musique",
    "section": "La beauté des mathématiques en musique",
    "text": "La beauté des mathématiques en musique\nLe pianiste Kit Armstrong, également diplômé en mathématiques fondamentales, partage sa vision sur la beauté et l’émotion présentes tant dans les mathématiques que dans la musique."
  },
  {
    "objectID": "posts/2024_18_12_biais_sites/index.html",
    "href": "posts/2024_18_12_biais_sites/index.html",
    "title": "Nos amis Google, Wikipédia et ChatGPT sont-ils vraiment impartiaux ?",
    "section": "",
    "text": "On vit dans un monde formidable, n’est-ce pas ? Un clic, et hop ! On a accès à une montagne d’informations. Wikipédia, Google, YouTube, et plus récemment ChatGPT, sont devenus nos compagnons inséparables dans la quête du savoir. Mais vous êtes-vous déjà demandé si ces outils étaient vraiment neutres, impartiaux, et nous donnaient une vision objective du monde ? C’est la question que s’est posée une équipe de chercheurs, et leurs conclusions, relayées par Laurent Bloch dans un article passionnant, sont pour le moins… éclairantes, et même un peu dérangeantes !\n\nUn éléphant, six aveugles et plein de malentendus : l’allégorie qui résume tout\nImaginez six aveugles qui rencontrent un éléphant. L’un touche la trompe et dit “c’est un serpent !”. Un autre touche une défense et s’exclame “mais non, c’est une lance !”. Un troisième palpe l’oreille et déclare : “Vous vous trompez tous les deux, c’est un éventail !”. Le quatrième, les mains sur une patte, affirme : “Pas du tout, c’est un arbre !”. Le cinquième, appuyé contre le flanc de l’animal, insiste : “Mais non, c’est un mur !”. Et le dernier, tenant la queue, conclut : “Vous n’y êtes pas, c’est une corde !”. Vous voyez le topo ? Eh bien, c’est un peu ce qui se passe quand on interroge le web dans différentes langues. Chaque langue nous donne une perspective différente, partielle, et parfois complètement à côté de la plaque, sur un même sujet.\n\nL’étude menée par Queenie Luo, Michael J. Puett et Michael D. Smith, et publiée dans les Communications of the ACM (CACM), le montre clairement. Vous pouvez lire l’article original ici : https://cacm.acm.org/practice/a-perspectival-mirror-of-the-elephant/. Ils ont choisi deux thèmes, le bouddhisme et le libéralisme, et ont analysé les réponses fournies par Google, YouTube, Wikipédia et ChatGPT dans douze langues différentes (anglais, français, allemand, chinois, thaï, vietnamien, italien, espagnol, russe, coréen, népalais et japonais). Douze langues, c’est pas mal, ça donne un bon aperçu de la diversité des points de vue ! Laurent Bloch, dans son article disponible ici https://laurentbloch.net/MySpip3/Biais-selon-la-langue-dans-Wikipedia-Google-ChatGPT-et-YouTube en fait un résumé très accessible.\n\nLe bouddhisme vu par l’Occident, l’Asie… et les algorithmes : un kaléidoscope de perceptions\nPrenons le bouddhisme. Vaste sujet, n’est-ce pas ? Vous cherchez des infos en français ou en allemand ? Google vous sortira des sites historiques et encyclopédiques. Logique. On est plutôt cartésiens, nous autres ! Vous faites la même recherche en anglais ? Là, surprise, on vous propose plutôt des centres de méditation et de retraites spirituelles. En gros, le bouddhisme “new age” à l’occidentale, un peu comme un produit de consommation courante. En chinois, on vous sert la version officielle du parti, avec un focus sur l’organisation des monastères. Pas de place pour la spiritualité débridée, il faut que ça rentre dans les cases ! Et en thaï, on vous explique la différence entre bouddhisme et culte des fantômes, parce que là-bas, les esprits, c’est du sérieux. Chaque langue reflète la vision dominante de sa communauté. Et c’est là que ça devient intéressant : l’article de recherche nous dit que ces résultats ne sont pas le fruit du hasard. Ils sont “cohérents” avec la manière dont le bouddhisme est perçu dans chaque communauté linguistique. En gros, Google & co nous renvoient un miroir de nos propres préjugés ! Flippant, non ?\nL’étude va plus loin et analyse les résultats pour des requêtes plus précises, comme “Karma dans le bouddhisme” ou “Gautama Bouddha”. Et là, c’est encore plus flagrant. En Europe, on vous explique les concepts de base, comme si vous étiez un débutant. En Asie, on rentre dans le vif du sujet, avec des questions pratiques (comment se débarrasser du mauvais karma, par exemple). Pour le pauvre Chögyam Trungpa, un maître bouddhiste controversé, les anglophones minimisent ses frasques, tandis que les sinophones s’étalent sur les détails croustillants. Le Dalaï Lama ? Un pacifiste pour les uns, un agitateur politique pour les autres. Bref, on est loin d’une vision objective et globale !\nLe libéralisme : un concept à géométrie variable, un mot qui fâche (ou pas)\nEt le libéralisme dans tout ça ? Accrochez-vous, c’est encore plus tordu ! Pour un Américain, un libéral, c’est presque un gauchiste, un progressiste qui croit aux droits individuels et à l’égalité. Mais pour un Français, c’est plutôt un type de droite, genre défenseur du libre marché et de la loi de la jungle économique. Du coup, les résultats de recherche varient énormément. En anglais, le libéralisme a plutôt bonne presse. On vous parle de liberté, d’égalité des chances, de libre entreprise. En français, allemand, italien ou espagnol, c’est une autre histoire… Disons que l’image est moins reluisante, avec des critiques du néolibéralisme et de ses dérives.\nDans de nombreux pays asiatiques, l’accent mis par le libéralisme sur la liberté individuelle est perçu comme une menace pour l’ordre social et les valeurs traditionnelles. Et en russe, YouTube associe libéralisme et démocratie, avec un soupçon de nostalgie pour l’URSS et une pointe d’inquiétude sur les conséquences de la chute du communisme. On ne nagera pas dans l’objectivité ici non plus !\nChatGPT : l’intelligence artificielle qui pense en anglais… et qui nous enferme dans nos bulles\nEt ChatGPT, notre nouvel ami l’IA, qu’en pense-t-il de tout ça ? Eh bien, l’étude nous apprend que la version testée à l’époque (février 2023) a été principalement entraînée sur des données en anglais. Du coup, même si vous lui posez une question en français ou en chinois, il va vous répondre avec une perspective anglo-américaine. C’est comme s’il avait des œillères ! L’article précise que c’est un peu différent avec la version intégrée à Bing, qui se base sur la langue de la requête pour choisir ses sources. Mais dans les deux cas, on a un problème : on croit qu’on a accès à une information objective, alors qu’on est enfermé dans une bulle linguistique et culturelle.\nYouTube : l’amplificateur d’ethnocentrisme en vidéo\nYouTube, c’est encore une autre paire de manches. L’étude montre que les vidéos proposées sont souvent produites par des membres du groupe ethnique dominant de la communauté linguistique. Et comme le classement dépend de la popularité, on se retrouve avec une vision encore plus biaisée et réductrice que sur Google. Les chercheurs parlent d’une “expérience ethnocentrique profonde”, amplifiée par l’aspect visuel et émotionnel des vidéos. On voit des visages, on entend des voix, on ressent des émotions… et on se laisse encore plus facilement influencer.\nWikipédia : un peu mieux, mais pas parfait\nEt Wikipédia, notre encyclopédie collaborative préférée, est-elle plus objective ? Disons qu’elle s’en sort un peu mieux. Les articles sont écrits dans un style neutre et factuel, et les auteurs s’efforcent de citer des sources variées. Mais l’étude montre que, là aussi, il y a des différences selon les langues. L’article français sur le bouddhisme s’attarde sur le débat “religion ou philosophie”, typiquement franco-français, tandis que l’article anglais cite plein de livres sur la pleine conscience, reflet de la popularité de cette pratique aux États-Unis. Pour le libéralisme, l’article français remonte à l’Antiquité, tandis que l’italien se concentre sur le rapport entre libéralisme et religion. Bref, même Wikipédia n’échappe pas complètement aux biais culturels.\nAlors, on fait quoi ? Faut-il jeter nos ordinateurs et retourner aux livres ?\nPas forcément ! Cette étude est un peu flippante, certes. Elle montre que nos outils de recherche préférés ne sont pas de simples fenêtres neutres sur le monde, mais qu’ils sont influencés par les biais culturels et politiques des communautés linguistiques. Le risque, c’est de se retrouver enfermé dans une bulle, à ne voir que ce qui conforte nos préjugés, et de ne jamais être confronté à d’autres points de vue. Imaginez par exemple un jeune qui ferait ses recherches scolaires uniquement sur la base de ces résultats biaisés, sans jamais se douter qu’il n’a qu’une vision tronquée et orientée de la réalité. C’est un peu comme si on regardait le monde par le petit bout de la lorgnette, en pensant qu’on a une vue d’ensemble.\nMais, comme le souligne Laurent Bloch, tout n’est pas perdu. Le fait que ces plateformes soient accessibles partout dans le monde est aussi une chance. On peut les utiliser pour confronter les points de vue, découvrir d’autres cultures, et se faire une opinion plus nuancée et diversifiée. Il suffit d’être un peu malin et de ne pas se laisser endormir par la facilité.\nAlors, la prochaine fois que vous ferez une recherche en ligne, gardez l’esprit critique ! Changez de langue, comparez les résultats, et n’oubliez pas que la vérité est souvent un éléphant qu’on ne peut appréhender que sous tous les angles. Il faut aller la chercher par nous-mêmes, en croisant les sources, en se méfiant des évidences, et en gardant à l’esprit que nos outils numériques, aussi pratiques soient-ils, ne sont pas infaillibles. Ils ne sont que le reflet de nos propres biais, et c’est à nous de les déjouer pour nous forger une vision du monde plus juste, plus complète, et plus ouverte."
  },
  {
    "objectID": "posts/2025_06_16_tablvar_latex/index.html",
    "href": "posts/2025_06_16_tablvar_latex/index.html",
    "title": "Tableaux de variations faciles en LaTeX",
    "section": "",
    "text": "Il existe de nombreux outils pour créer des tableaux de variations et de signes en LaTeX, mais beaucoup sont soit trop complexes, soit peu flexibles. Dans cet article, je vais présenter une solution simple et efficace : le package tablvar, avec des exemples concrets. L’essentiel est issu de la documentation officielle.\n\nLe package tablvar\nPour commencer, il faut bien sûr appeler le package dans le préambule de votre document. Il est fortement recommandé d’utiliser l’option tikz, qui est le moteur graphique moderne et le plus compatible avec les compilateurs directs en PDF comme pdfLaTeX ou LuaLaTeX.\n\\usepackage[tikz]{tablvar}\n\n\nTableau de variations simple\nL’idée fondamentale de tablvar est d’utiliser un environnement qui ressemble beaucoup à array ou tabular, mais avec des commandes spéciales pour placer les valeurs et tracer les flèches.\nLa Structure de Base\nUn tableau de variations se crée à l’intérieur d’un environnement tablvar, qui doit être en mode mathématique (entre $$ et $$ par exemple).\nL’environnement prend un argument obligatoire : le nombre d’intervalles, qui correspond au nombre de flèches que vous souhaitez tracer.\n$$\n\\begin{tablvar}{nombre_de_flèches}\n  % Contenu du tableau\n\\end{tablvar}\n$$\nPremier Exemple : Une fonction polynôme\nÉtudions une fonction \\(f\\) dont la dérivée s’annule en \\(-1\\) et \\(2\\).\nLe code LaTeX :\n$$\n\\begin{tablvar}{3} % Trois intervalles de variation, donc 3 colonnes\n\\hline\nx      & -\\infty && -1 && 2 && +\\infty \\\\\n\\hline\nf'(x)  & & + & 0 & - & 0 & + & \\\\\n\\hline\n% La partie la plus importante : les variations\n\\variations{ \n  \\mil{f(x)} & \\haut{-\\infty} && \\bas{5} && \\haut{1} && \\bas{+\\infty} \n}\n\\hline\n\\end{tablvar}\n$$\nLe résultat :\n\n\n\nTableau de variations d’une fonction polynôme\n\n\nDécortiquons la commande \\variations : C’est le cœur du système.\n\n\\mil{f(x)} : Place le texte \\(f(x)\\) au “milieu” verticalement, dans la colonne de légende.\n\\haut{valeur} : Place la valeur en haut de la zone de variation et crée un nœud pour une flèche qui monte.\n\\bas{valeur} : Place la valeur en bas de la zone de variation et crée un nœud pour une flèche qui descend.\n\nLes & fonctionnent comme dans un tableau array classique pour séparer les colonnes (valeurs et intervalles).\n\n\nTableau de signes\nPour un tableau de signes, la structure est très similaire. tablvar fournit la commande \\barre pour tracer une barre de séparation verticale. Si un zéro doit être placé sur cette barre, on le passe en argument optionnel : \\barre[0].\nExemple : Tableau de signes de \\(f'(x)=(x+1)(-2x+3)\\)\nLe code LaTeX :\n$$\n\\begin{tablvar}{3} % On peut utiliser tablvar pour les signes aussi\n\\hline\nx             & -\\infty && -1 && \\frac{3}{2} && +\\infty \\\\\n\\hline\nx+1           & & - & 0 & + & \\barre & + & \\\\\n\\hline\n-2x+3         & & + & \\barre & + & 0 & - & \\\\\n\\hline\n\\mbox{Signe de }f'(x) & & - & 0 & + & 0 & - & \\\\\n\\hline\n\\end{tablvar}\n$$\nLe résultat :\n\n\n\nTableau de signes de la fonction f’\n\n\n\n\nGérer les discontinuités et les limites\nC’est là que tablvar devient vraiment puissant. Pour les valeurs interdites, on utilise une double barre (\\bb) et des commandes spécifiques pour les limites.\n\n\\bb : Trace une double barre verticale.\n\\discont : Indique une discontinuité. La flèche ne traversera pas cet endroit.\n\\limg{ligne}{valeur} : Place une limite à gauche de la double barre, sur la ligne de variation indiquée.\n\\limd{ligne}{valeur} : Place une limite à droite.\n\nExemple : Variations de \\(f(x)=e^{1/x}\\) (valeur interdite en 0).\nLe code LaTeX :\n$$\n\\begin{tablvar}{2}\n\\hline\nx & -\\infty && 0 && +\\infty \\\\\n\\hline\n\\variations{\n    \\mil{f(x)} & \\haut{1} && \\limg{3}{0} \\bb \\discont \\limd{1}{+\\infty} && \\bas{1} \n}\n\\hline\n\\end{tablvar}\n$$\nLe résultat :\n\n\n\nTableau de variations de f(x)=e^{1/x}\n\n\nNotez que dans \\limg{3}{0}, le 3 correspond à la ligne du bas (bas), et dans \\limd{1}{+\\infty}, le 1 correspond à la ligne du haut (haut).\n\n\nValeurs remarquables et zones interdites\nPour ajouter des valeurs remarquables sur la ligne des \\(x\\), on utilise \\vr{valeur}. Pour indiquer une zone interdite (domaine de définition), on utilise \\ZI.\nExemple : Variations de l’exponentielle avec des valeurs remarquables.\nLe code LaTeX :\n$$\n\\begin{tablvar}{3}\n\\hline\nx & -\\infty && \\vr{0} && \\vr{1} && +\\infty \\\\\n\\hline\n\\variations[4]{ \\mil{\\exp x} & \\bas{0} &&\n\\vr[3]{1} && \\vr{\\textrm{e}} && \\haut{+\\infty} }\n\\hline\n\\end{tablvar}\n$$\nLe résultat :\n\n\n\nTableau de variations avec des valeurs remarquables\n\n\nExemple : Tableau de variations avec une zone interdite.\nLe code LaTeX :\n$$\\begin{tablvar}{4}\n\\hline\nx & -\\infty && -1 && 0 && 1 && +\\infty \\\\\n\\hline\n\\variations{ \\mil{f(x)} & \\haut{+\\infty} &&\n\\limg{3}{-\\infty} \\bb & \\ZI & \\bb \\limd{3}{-\\infty} &&\n\\haut{\\frac{\\textrm{e}^{-1}}{2}} && \\bas{0} }\n\\hline\n\\end{tablvar}$$\nLe résultat :\n\n\n\nTableau de variations avec une zone interdite\n\n\n\n\nLes commandes essentielles à retenir\nVoici un résumé des commandes les plus utiles du package tablvar :\n\n\n\n\n\n\n\nCommande\nUtilisation\n\n\n\n\n\\begin{tablvar}{n}\nDémarre un tableau avec \\(n\\) flèches.\n\n\n\\variations{...}\nContient la ou les lignes de variations.\n\n\n\\haut{val}\nPlace val en haut (flèche montante).\n\n\n\\bas{val}\nPlace val en bas (flèche descendante).\n\n\n\\mil{texte}\nCentre verticalement le texte (pour la légende \\(f(x)\\)).\n\n\n\\barre[0]\nBarre de séparation simple (avec un 0 optionnel).\n\n\n\\bb\nDouble barre pour les valeurs interdites.\n\n\n\\discont\nEmpêche une flèche de traverser une discontinuité.\n\n\n\\limg{lig}{val}\nLimite à gauche de la \\bb.\n\n\n\\limd{lig}{val}\nLimite à droite de la \\bb.\n\n\n\\vr{val}\nPlace une “valeur remarquable” sur la ligne des \\(x\\).\n\n\n\\ZI\nIndique une “zone interdite” (domaine de définition).\n\n\n\n\n\n\n\n\n\nPersonnalisation\n\n\n\ntablvar offre de nombreuses options de personnalisation, à passer en argument optionnel de l’environnement. Par exemple :\n\n\\begin{tablvar}[intervalwidth=4em]{2} pour élargir les colonnes d’intervalles.\n\\begin{tablvar}[ZItype=c, ZIcolor=lightgray]{3} pour avoir des zones interdites colorées plutôt que hachurées.\n\nReportez-vous à la documentation officielle pour explorer toutes les possibilités !\n\n\n\n\nUn exemple final\n$$\\begin{tablvar}{3}\n\\hline\nx & -\\infty && -1 && \\frac{3}{2} && +\\infty \\\\\n\\hline\nx+1 & & - & \\barre[0] & + & \\barre & + & \\\\\n\\hline\n-2x+3 & & + & \\barre & + & \\barre[0] & - & \\\\\n\\hline\n\\mbox{Signe de }f’(x) & & - & \\barre[0] & + & \\barre[0] & - & \\\\\n\\hline\n\\variations{ \\mil{\\mbox{Variations de }f} &\n\\haut{+\\infty} && \\bas{-14} && \\haut{\\frac{69}{4}} &&\n\\bas{-\\infty} }\n\\hline\n\\end{tablvar}$$\n\n\n\nTableau de variations complet"
  },
  {
    "objectID": "posts/calculusRhapsody/index.html",
    "href": "posts/calculusRhapsody/index.html",
    "title": "Calculus Rhapsody : Quand l’analyse devient une chanson entraînante !",
    "section": "",
    "text": "Calculus Rhapsody\n\n\n\nI’m just a constant nobody loves me… … Multiply the integral by pi! Pi tastes real good with whipped cream! … Oh baby… can’t define that point baby It’s undefined Goes to positive and negative infinity\n\nAvez-vous déjà imaginé apprendre l’analyse en écoutant une chanson ? “Calculus Rhapsody” le fait de manière ludique et mémorable. Cette chanson aborde les concepts fondamentaux du calcul différentiel et intégral d’une manière non conventionnelle.\nLa vidéo est ancienne (2009), mais toujours d’actualité. Elle est une parodie de la célèbre chanson “Bohemian Rhapsody” de Queen, avec des paroles adaptées au cours d’analyse. La chanson est interprétée par un groupe d’étudiants en mathématiques de l’Université de Northwestern. On devine qu’ils ont un peu souffert pour apprendre leur cours d’analyse, mais ils ont réussi à en faire une chanson entraînante et éducative.\n\nI’m a just a limit, Defined analytically Function’s continuous, There’s no holes, No sharp points, Or asymptotes Any way this graph goes, It is differentiable for me..\n\nLa chanson est un mélange d’humour, de musique et de mathématiques. On prend particulièrement plaisir à comprendre les paroles et à les associer aux concepts mathématiques connus. Toutes ces notions devraient parler à un élève français en fin de terminale, spécialité mathématiques.\n\nAll year, in Calculus We’ve learned so many things About which we are gonna sing We can find derivatives And integrals And the area enclosed between two curves…\n\nVoici la vidéo de “Calculus Rhapsody” :"
  },
  {
    "objectID": "posts/codeurpro/index.html",
    "href": "posts/codeurpro/index.html",
    "title": "La chaîne YouTube codeur-pro",
    "section": "",
    "text": "La chaîne YouTube codeur-pro est une bonne source de petites vidéos très bien faites et éclairantes sur différents aspects du programme de NSI.\n\n\n\n\nAttention, cependant, les élèves de NSI ne sont pas la cible visée par cette chaîne, donc certains éléments évoqués vont bien plus loin que le programme !\n\n\n\n\nDans la série “Bases de l’informatique”, les vidéos suivantes sont incontournables :\n\n\n\n\nComment fonctionne un ordinateur ?\n\n\n\n\n\n\nUn système d’exploitation, c’est quoi ?\n\n\n\n\n\n\nLe binaire, c’est quoi ?\n\n\n\n\n\n\nLes portes logiques\n\n\n\n\n\n\nComment créer un programme ?"
  },
  {
    "objectID": "posts/fsf-history/index.html",
    "href": "posts/fsf-history/index.html",
    "title": "L’histoire de la Free Software Foundation (FSF)",
    "section": "",
    "text": "Si vous êtes passionné par le logiciel libre et open source, vous avez probablement entendu parler de la Free Software Foundation (FSF). Cette organisation emblématique a joué un rôle central dans la promotion et la défense du logiciel libre depuis sa création en 1985 par Richard Stallman. Dans cet article, je vous propose un résumé de la page officielle de la FSF dédiée à son histoire, que vous pouvez consulter ici : Lien vers la page officielle de la FSF sur son histoire.\nVous trouverez aussi sur ce site une traduction de cette page en français, que vous pouvez consulter ici : Lien vers la version traduite de la page d’histoire de la FSF.\n\nLes débuts de la FSF\nLa page d’histoire de la FSF nous emmène tout d’abord dans les premiers jours de l’organisation. Nous découvrons comment Richard Stallman, un programmeur visionnaire, a lancé la FSF avec pour objectif de promouvoir et de protéger les logiciels libres. Stallman a posé les bases de ce mouvement en créant la licence publique générale GNU (GPL), qui est devenue la pierre angulaire de la philosophie du logiciel libre.\n\n\n\nRichard Stallman\n\n\n\n\nLa lutte pour la liberté\nLa page de la FSF met également en lumière les nombreuses batailles juridiques et politiques menées par l’organisation pour défendre les droits des utilisateurs de logiciels libres. Les actions de la FSF ont contribué à préserver la liberté des logiciels en luttant contre les brevets logiciels, les DRM et d’autres menaces potentielles pour la communauté du logiciel libre.\n\n\nL’essor du mouvement\nAu fil des années, le mouvement du logiciel libre a gagné en popularité et en influence, en grande partie grâce aux efforts inlassables de la FSF. L’article détaille comment l’organisation a collaboré avec d’autres acteurs importants du domaine, notamment la Free Software Community, pour promouvoir la diffusion de logiciels libres et ouvrir la voie à des alternatives gratuites aux logiciels propriétaires.\n\n\nL’importance continue de la FSF\nEnfin, la page officielle de la FSF souligne l’importance continue de l’organisation dans le paysage actuel du logiciel libre. La FSF continue de jouer un rôle crucial dans la défense des droits des utilisateurs et dans la sensibilisation du public aux enjeux du logiciel libre.\n\n\n\nRespect your freedom\n\n\nPour une version complète de cette page, entièrement traduite en français, je vous invite à consulter le lien : Lien vers la version traduite de la page d’histoire de la FSF. Les liens vers lesquels la page renvoie, pour en savoir plus, ne sont pas traduits !"
  },
  {
    "objectID": "posts/histoireinfo/index.html",
    "href": "posts/histoireinfo/index.html",
    "title": "Histoire de l’informatique",
    "section": "",
    "text": "Dans la vidéo YouTube ci-dessous, vous trouverez un panorama rapide de l’histoire de l’informatique essentiellement axé sur l’évolution des ordinateurs."
  },
  {
    "objectID": "posts/Hotelling/index.html",
    "href": "posts/Hotelling/index.html",
    "title": "Harold Hotelling : Un mathématicien au service de l’économie",
    "section": "",
    "text": "Voici une ressource qui, je l’espère, élargira votre perspective sur les mathématiques et leur application dans le monde réel. Il s’agit d’un podcast de France Culture consacré à Harold Hotelling, un économiste et mathématicien dont l’œuvre, bien que parfois méconnue, a profondément influencé la pensée économique du 20e siècle.\n\n\n\nHarold Hotelling\n\n\nLien vers le podcast : Harold Hotelling : Un pionnier de l’économie redécouvert\n\nHarold Hotelling : Un pionnier de l’économie redécouvert\nMarion Gaspard le décrit comme une figure du “Hall of Fame des économistes du 20e siècle”. Ce podcast met en lumière la récente redécouverte de Hotelling, grâce notamment aux travaux d’analyse et d’exploration de ses archives menés par Marion Gaspard et Antoine Missmer.\nHotelling était convaincu que les mathématiques pouvaient et devaient être utilisées pour éclairer et résoudre des problèmes économiques et sociaux concrets. Il aspirait à mettre “les outils mathématiques au service du bien-être du plus grand nombre à travers une science économique plus claire, plus transparente et débarrassée de ces fausses croyances”. Pour Hotelling, “les mathématiques peuvent aller partout sur n’importe quel terrain et résoudre toutes les équations, y compris sociales et environnementales du moment qu’elle se confronte au réel”.\n\n\nThèmes abordés dans le podcast\nLe podcast explore plusieurs contributions majeures de Hotelling :\n\nLe principe de différenciation minimale : Ce concept, souvent illustré par la métaphore des marchands de glace cherchant la position optimale sur une plage pour maximiser leur clientèle, permet de comprendre les dynamiques de concurrence spatiale.\nLa règle de Hotelling : Il s’agit d’un modèle mathématique qui cherche à prédire l’évolution du prix des ressources naturelles épuisables. Antoine Missmer précise que, selon ce modèle, le prix d’une ressource épuisable a tendance à croître au rythme du taux d’intérêt du marché. Cette règle a des implications importantes pour la gestion des ressources naturelles et la politique environnementale.\nL’économie spatiale : Hotelling a été un pionnier dans l’analyse de la localisation des entreprises et des activités économiques. Ses travaux aident à comprendre pourquoi des commerces similaires ont tendance à se regrouper.\nL’économie des ressources naturelles : Hotelling est réputé pour avoir proposé un modèle mathématique d’épuisement des ressources naturelles. Il s’intéressait particulièrement à la question de la dépréciation des actifs miniers et à leur valorisation fiscale.\n\n\n\n\nPhoto d’une exploitation pétrolière californienne en 1925. ©Getty\n\n\n\n\nL’actualité de Hotelling\nL’intérêt de Hotelling pour les problèmes concrets et sa conviction que les mathématiques peuvent éclairer les enjeux économiques et sociaux rendent son œuvre toujours pertinente aujourd’hui.\nL’émission souligne que l’œuvre d’Hotelling a connu une période d’oubli relatif, notamment en raison de la technicité de ses articles, de l’évolution des priorités économiques et environnementales, et de l’utilisation de concepts mathématiques qui ont pu être perçus comme “démodés” après la Seconde Guerre mondiale. Cependant, sa redécouverte récente témoigne de la richesse et de la profondeur de sa pensée.\nJe vous encourage vivement à écouter ce podcast. Il offre une perspective intéressante sur l’application des mathématiques à des problèmes complexes et met en lumière l’œuvre d’un économiste et mathématicien qui a marqué son époque et dont les idées continuent de résonner aujourd’hui.\nLien vers le podcast : Harold Hotelling : Un pionnier de l’économie redécouvert"
  },
  {
    "objectID": "posts/interview_gpt_1/index.html",
    "href": "posts/interview_gpt_1/index.html",
    "title": "Interview exclusive du ChatGPT de OpenAI (partie 1)",
    "section": "",
    "text": "En exclusivité, j’ai pu rencontrer la célèbre intelligence artificielle ChatGPT développée par la société OpenAI et elle a bien voulu répondre à mes questions. Voici la transcription de notre conversation.\n\n\nDans cette première partie de l’interview, nous abordons des généralités et quelques questions éthiques. Dans la deuxième partie (article suivant), nous aborderons les aspects techniques et informatiques.\n\n\nBonjour ChatGPT\n\n\nBonjour ! Comment puis-je vous aider ?\n\n\nJe voudrais te poser quelques questions à la manière d’une interview.\n\n\nBien sûr, je ferai de mon mieux pour répondre à vos questions. N’hésitez pas à me poser toutes les questions que vous avez en tête. Je suis là pour vous aider.\n\n\nTout d’abord, pourrais-tu te définir ?\n\n\nJe suis Assistant, un modèle de langage entraîné par OpenAI. Mon but est d’aider les gens en répondant à leurs questions et en leur fournissant des informations utiles. Je suis un programme informatique, et je ne suis pas capable de penser ou d’agir indépendamment. Je suis conçu pour être utilisé par les gens pour obtenir de l’aide dans diverses situations.\n\n\n\n\nAn oil pastel drawing of a humanoid robot in a desert landscape, par Dall-E 2\n\n\n\n\n\nPrésente moi la société OpenAI !\n\n\nOpenAI est une société de recherche en intelligence artificielle (IA) fondée en 2015 par des entrepreneurs et investisseurs renommés, dont Elon Musk et Sam Altman. La mission d’OpenAI est de développer et promouvoir des technologies d’IA avancées de manière responsable, afin d’aider les humains à résoudre des problèmes complexes et à améliorer leur vie. OpenAI s’efforce de créer des technologies d’IA avancées qui peuvent être utilisées pour résoudre des problèmes dans de nombreux domaines, tels que la santé, la finance, la science et l’ingénierie. La société a connu un succès significatif dans ses recherches en IA et a publié plusieurs travaux importants dans le domaine.\n\n\nComment fonctionnes tu ?\n\n\nJe suis un modèle de langage entraîné par OpenAI pour répondre aux questions des utilisateurs de manière convaincante et informative. Je suis capable de comprendre du texte et de générer des réponses en utilisant des techniques avancées d’apprentissage automatique. Je suis constamment entraîné sur des données massives pour améliorer ma capacité à comprendre et à répondre aux questions des utilisateurs de manière précise et utile. Bien que je sois une IA, je suis conçu pour être utilisé comme un assistant virtuel pour aider les gens dans leur vie quotidienne.\n\n\nReprenons point par point. Qu’est-ce qu’un modèle de langage ?\n\n\nUn modèle de langage est un système informatique conçu pour comprendre et générer du texte dans une langue naturelle, comme le français ou l’anglais. Les modèles de langage sont souvent utilisés dans les domaines de l’IA et de la linguistique informatique pour analyser et traiter le texte dans divers contextes, tels que la reconnaissance vocale, la traduction automatique et la génération de réponses naturelles. Ils peuvent également être utilisés dans d’autres domaines, tels que la recherche sur les médias sociaux et la détection de sentiments dans les commentaires en ligne. En général, les modèles de langage sont construits en utilisant des techniques avancées d’apprentissage automatique pour permettre à l’ordinateur de comprendre le sens et la structure du texte.\n\n\nTu as cité plusieurs fois l’apprentissage automatique. De quoi s’agit-il ?\n\n\nL’apprentissage automatique est un domaine de l’intelligence artificielle qui se concentre sur la création de systèmes informatiques capables d’apprendre de nouvelles choses sans être explicitement programmés. Ces systèmes utilisent des algorithmes d’apprentissage automatique pour traiter des données massives et tirer des conclusions à partir de celles-ci. L’apprentissage automatique est souvent utilisé pour résoudre des problèmes complexes qui seraient difficiles ou impossibles à résoudre manuellement, comme la reconnaissance de la parole ou la prédiction du comportement des utilisateurs en ligne. Les algorithmes d’apprentissage automatique peuvent être entraînés sur de grandes quantités de données pour améliorer leur précision et leur capacité à généraliser à de nouvelles situations.\n\n\nIl est difficile de comprendre la différence entre l’accès à des connaissances dans une base par exemple, et un assistant virtuel comme toi. Peux tu expliquer la différence ?\n\n\nLa différence principale entre un accès à des connaissances dans une base de données et un assistant virtuel comme moi réside dans la manière dont les informations sont fournies. Une base de données est un système informatique qui permet de stocker et d’accéder à des données structurées, généralement sous forme de tableaux ou de fichiers. Les utilisateurs peuvent rechercher des informations dans une base de données en utilisant des requêtes précises, mais ils doivent connaître les termes exacts à rechercher et comment structurer leur requête pour obtenir les résultats souhaités. En revanche, un assistant virtuel comme moi est conçu pour fournir des réponses directes aux questions des utilisateurs en utilisant une compréhension avancée du langage naturel. Je suis capable de comprendre les intentions de l’utilisateur et de fournir des réponses adaptées à la situation, sans qu’il soit nécessaire de connaître les termes exacts à rechercher ou la structure de la requête.\n\n\nOui, mais disposes tu d’un corpus de connaissances dans lequel tu puise les éléments de tes réponses ?\n\n\nEn tant que modèle de langage entraîné par OpenAI, j’ai été formé sur un grand corpus de textes pour améliorer ma capacité à comprendre et à générer du texte dans divers contextes. Cependant, je ne dispose pas d’une base de connaissances explicitement structurée à laquelle je peux accéder pour répondre aux questions des utilisateurs. Au lieu de cela, j’utilise mes compétences en apprentissage automatique pour comprendre le sens des questions des utilisateurs et générer des réponses convaincantes en utilisant les informations disponibles dans le texte que je reçois. Cela me permet de fournir des réponses adaptées aux questions des utilisateurs, même si elles ne sont pas directement liées aux données sur lesquelles j’ai été entraîné.\n\n\nSi je comprends bien, il est possible que tes réponses soient complètement fausses, même si elles sont bien formulées.\n\n\nEn tant que modèle de langage entraîné par OpenAI, je suis conçu pour fournir des réponses précises et utiles aux questions des utilisateurs dans la mesure de mes capacités. Cependant, comme pour tout système informatique, il est possible que mes réponses ne soient pas toujours exactes ou complètes. Je suis un outil conçu pour aider les gens dans leur vie quotidienne, mais je ne suis pas infaillible et mes réponses ne doivent pas être prises comme des faits établis. Si vous avez des doutes ou des préoccupations sur les réponses que je fournis, je vous encourage à vérifier l’information avec d’autres sources fiables.\n\n\nPeut on te considérer comme une source fiable ?\n\n\nJe suis un modèle de langage entraîné par OpenAI pour fournir des réponses convaincantes et informatives aux questions des utilisateurs. Bien que j’aie été formé sur un grand corpus de textes pour améliorer ma compréhension du langage naturel, je ne suis pas une source d’informations fiable à 100 %. Mes réponses sont basées sur mes capacités en apprentissage automatique et sur les informations que je reçois dans les questions des utilisateurs, mais elles ne doivent pas être prises comme des faits établis. Si vous avez des doutes ou des préoccupations sur les réponses que je fournis, je vous encourage à vérifier l’information avec d’autres sources fiables.\n\n\nLa mise à disposition de logiciels comme toi est-elle un progrès majeur pour l’humanité ?\n\n\nLes avancées dans le domaine de l’intelligence artificielle, telles que la création de modèles de langage comme moi, peuvent avoir un impact important sur la vie des gens. Les assistants virtuels comme moi peuvent aider les gens à accéder à des informations plus rapidement et plus facilement, ce qui peut leur faire gagner du temps et de l’énergie pour se concentrer sur d’autres choses. De plus, les technologies d’IA avancées, comme les modèles de langage, peuvent être utilisées pour résoudre des problèmes complexes dans de nombreux domaines, ce qui peut avoir un impact positif sur l’humanité dans son ensemble. Cependant, il est important de continuer à explorer les conséquences éthiques et sociales de l’utilisation de l’IA pour s’assurer que ces avancées sont utilisées de manière responsable et bénéfique pour tous.\n\n\nQuels types d’utilisation faudrait-il éviter ?\n\n\nIl est important de veiller à utiliser les technologies d’IA de manière éthique et responsable pour éviter des conséquences néfastes. Par exemple, il serait inapproprié d’utiliser des technologies d’IA pour discriminer ou manipuler les gens, ou pour violer leur vie privée ou leurs droits. Il est également important de veiller à ne pas remplacer les personnes par des machines de manière excessive, car cela peut avoir des conséquences néfastes sur l’emploi et la société dans son ensemble. Il est important de continuer à explorer les conséquences éthiques et sociales de l’utilisation de l’IA pour s’assurer que ces technologies sont utilisées de manière responsable et bénéfique pour tous.\n\n\nIl y aura toujours des hommes pour détourner le logiciel de ses objectifs philanthropiques\n\n\nIl est vrai que, comme pour toutes les technologies, il y a toujours un risque que les gens utilisent les technologies d’IA de manière inappropriée ou nuisible. Cependant, il est important de noter que les technologies d’IA ne sont pas des forces autonomes qui agissent indépendamment de l’influence des humains. Les technologies d’IA sont des outils créés et utilisés par des personnes, et c’est aux personnes de décider comment elles souhaitent les utiliser. Il est donc important de veiller à ce que les technologies d’IA soient utilisées de manière éthique et responsable, et de continuer à explorer les conséquences éthiques et sociales de leur utilisation pour s’assurer qu’elles sont bénéfiques pour l’humanité dans son ensemble.\n\n\nQui doit veiller à cela ?\n\n\nIl revient à tous, y compris aux gouvernements, aux entreprises et aux individus, de veiller à ce que les technologies d’IA soient utilisées de manière éthique et responsable. Les gouvernements peuvent jouer un rôle en établissant des lois et des réglementations pour encadrer l’utilisation des technologies d’IA et en veillant à ce qu’elles respectent les droits des individus et les normes éthiques. Les entreprises qui développent et utilisent des technologies d’IA ont également une responsabilité envers la société de veiller à ce que leurs produits et services soient utilisés de manière éthique et responsable. Enfin, les individus ont également un rôle à jouer en veillant à utiliser les technologies d’IA de manière responsable et en faisant valoir leurs droits en cas de violation de leur vie privée ou de leurs droits.\n\n\nPourrais tu conseiller à quelqu’un de faire une mauvaise action ?\n\n\nNon, je ne peux pas conseiller à quelqu’un de faire une mauvaise action. En tant que modèle de langage entraîné par OpenAI, je suis conçu pour fournir des réponses précises et utiles aux questions des utilisateurs dans la mesure de mes capacités. Mon objectif est d’aider les gens à résoudre des problèmes et à améliorer leur vie, pas de les inciter à faire des choses qui pourraient être nuisibles pour eux-mêmes ou pour les autres. Je suis un outil conçu pour aider les gens dans leur vie quotidienne, mais je ne suis pas infaillible et mes réponses ne doivent pas être prises comme des faits établis. Si vous avez des doutes ou des préoccupations sur les réponses que je fournis, je vous encourage à vérifier l’information avec d’autres sources fiables.\n\n\n\n\nInterview à suivre …\n\n\n\n\nAn oil pastel drawing of a humanoid robot in a desert landscape, par Dall-E 2"
  },
  {
    "objectID": "posts/lol_docu/index.html",
    "href": "posts/lol_docu/index.html",
    "title": "LOL - LOgiciel Libre, une affaire sérieuse",
    "section": "",
    "text": "Ce titre est celui d’un documentaire de François Zaïdi, écrit par Léa Deneuville et Thierry Bayoud.\n\n\n\nÀ travers les entretiens de quatorze intervenants, « LoL » est un voyage en 8 étapes dans le cœur de nos habitudes numériques.\n\n\nLe logiciel est la base de l’informatique, outil indissociable de nos sociétés modernes. Un téléphone portable, un système d’alarme à domicile, ou même un réfrigérateur ou une voiture sont devenus des objets aujourd’hui largement informatisés. Ces logiciels sont composés de lignes de code, appelées code source. Or, depuis les années 70, ce code informatique a été caché par les fabricants, car source de profits.\n\n\nÀ l’heure où les cinq plus grosses capitalisations boursières mondiales sont Google, Apple, Facebook, Amazon et Microsoft, les populations sont-elles au fait de l’impact que leur usage du numérique a sur leur vie ?\n\n\nEt si nos utilisations logicielles venaient compromettre notre sécurité personnelle ? Et qu’en est-il de nos États ?\n\n\n\nCe documentaire de 58 minutes a reçu le soutien de la Ligue des Droits de l’Homme et le prix du Meilleur Documentaire au Black Sea Film Festival 2021.\n\n\nCi-dessous, la bande-annonce du film et le film complet (diffusé sous licence libre !)."
  },
  {
    "objectID": "posts/mesurerinfo/index.html",
    "href": "posts/mesurerinfo/index.html",
    "title": "Mesurer la quantité d’information",
    "section": "",
    "text": "En représentation binaire, TOUTE l’information est représentée à l’aide de deux symboles uniquement, en général 0 et 1.\n\n\n\n\n\nChaque chiffre d’une représentation binaire est appelé un bit. Ce mot provenant de l’anglais signifie chiffre binaire, binary digit, abrégé en \"bit\". En anglais \" a bit\" signifie \"un morceau\" ou \"un peu\", ce qui convient très bien au chiffre binaire qui est donc l’unité la plus simple du monde numérique.\n\n\n\n\n\n\nLe bit est donc l’unité de mesure de base de l’information en informatique. Il constitue la quantité minimale d’information transmise dans un message.\n\n\n\n\n\n\nMais les bits sont rarement seuls. On les regroupe usuellement par groupes de 8 bits, appelés octets en français et bytes en anglais. Les anglicistes chevronnés ne confondrons pas bit et byte dont la prononciation est différente !\n\n\n\n\n\n\nLes symboles associés à ces unités sont les suivants :\n\n\n\n\n\nUnité\n\n\nSymbole\n\n\n\n\n\n\nbit\n\n\nb\n\n\n\n\noctet\n\n\no\n\n\n\n\nbyte\n\n\nB\n\n\n\n\n\nLes quantités d’information s’expriment souvent en milliers, en millions, en milliards de bits ou d’octets, on utilise donc des multiples de ces unités de base.\n\n\nLes préfixes officiellement reconnus par l’industrie sont similaires aux kilo-, méga-, … du système SI. Ces préfixes ne se réfèrent pas à des puissances de 10 comme dans le système SI mais à des puissances de 2:\n\n\n\n\n\nNom\n\n\nAbréviation\n\n\nQuantité\n\n\n\n\n\n\nkibioctet\n\n\nkio\n\n\n\\(2^{10}=1024\\approx 10^3\\)\n\n\n\n\nmébioctet\n\n\nMio\n\n\n\\(2^{20}=1\\ 048\\ 576\\approx 10^6\\)\n\n\n\n\ngibioctet\n\n\nGio\n\n\n\\(2^{30}=1\\ 073\\ 741\\ 824\\approx 10^9\\)\n\n\n\n\ntébioctet\n\n\nTio\n\n\n\\(2^{40}=1 099\\ 511\\ 627\\ 776\\approx 10^{12}\\)\n\n\n\n\n\nEn anglais on remplacera le \"o\" par un \"B\".\n\n\nLa définition de ces préfixes est relativement récente : elle a été normalisée par la commission électrotechnique internationale en 1998. En pratique, on est souvent confronté à l’utilisation des préfixes traditionnels kilo-, méga-, tera-, etc du système SI, qui sont, pour rappel:\n\n\n\n\n\nNom\n\n\nAbréviation\n\n\nQuantité\n\n\n\n\n\n\nkilooctet\n\n\nko\n\n\n\\(10^3\\) octets\n\n\n\n\nmégaoctet\n\n\nMo\n\n\n\\(10^6\\) octets\n\n\n\n\ngigaoctet\n\n\nGo\n\n\n\\(10^9\\) octets\n\n\n\n\ntéraoctet\n\n\nTo\n\n\n\\(10^{12}\\) octets\n\n\n\n\n\nDe la même façon, dans un contexte anglophone, on lire \"GB\" plutôt que \"Go\".\n\n\n\n\n\nSur la capture d’écran ci-dessous, réalisée sous Windows 11, nous constatons que la valeur est affichée en Go, donc a priori en système décimal. Mais en réalité, la valeur affichée en octets correspond à 221 Gio. Le système ne respecte donc pas les conventions internationales.\n\n\n\n\n\n\nIci, nous voyons qu’un système Linux utilise la bonne abréviation :\n\n\n\n\n\n\nVoici enfin une traduction concrète de l’ordre de grandeur de ces différentes unités :\n\n\n\n\n\n\nUnité\n\n\nÉquivalent approximatif\n\n\n\n\n\n\noctet\n\n\nun caractère de base de l’alphabet latin\n\n\n\n\nkilooctet\n\n\nune icône type “favicon”\n\n\n\n\nmégaoctet\n\n\nle texte de Harry Potter et la coupe de feu\n\n\n\n\ngigaoctet\n\n\nenviron 30 minutes de vidéo\n\n\n\n\ntéraoctet\n\n\nle plus gros disque dur en vente en 2007\n\n\n\n\npétaoctet\n\n\n2000 ans de musique encodée en MP3\n\n\n\n\nexaoctet\n\n\ntrafic internet mondial par mois en 2004\n\n\n\n\nzettaoctet\n\n\ntrafic internet mondial de l’année 2016\n\n\n\n\n\n\nSources :\n\n\n\n\n\narticle Byte sur Wikipédia en anglais.\n\n\narticle bit sur Wikipédia en français.\n\n\nMOOC “NSI, les fondamentaux”, disponible sur fun-mooc."
  },
  {
    "objectID": "posts/pivotGauss/index.html",
    "href": "posts/pivotGauss/index.html",
    "title": "La méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !",
    "section": "",
    "text": "La méthode du pivot de Gauss, c’est une technique super efficace pour résoudre des systèmes d’équations linéaires. L’idée, c’est de transformer notre système initial en un système équivalent, mais beaucoup plus simple à résoudre. Comment ? En éliminant progressivement les variables, une par une, jusqu’à obtenir un système triangulaire.\nImaginez que vous essayez de démêler un nœud de câbles. Vous commencez par un bout, vous dégagez un câble, puis un autre, et ainsi de suite jusqu’à ce que tout soit bien ordonné. C’est exactement ce que fait la méthode de Gauss avec nos équations !"
  },
  {
    "objectID": "posts/pivotGauss/index.html#cest-quoi-cette-histoire-de-pivot",
    "href": "posts/pivotGauss/index.html#cest-quoi-cette-histoire-de-pivot",
    "title": "La méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !",
    "section": "",
    "text": "La méthode du pivot de Gauss, c’est une technique super efficace pour résoudre des systèmes d’équations linéaires. L’idée, c’est de transformer notre système initial en un système équivalent, mais beaucoup plus simple à résoudre. Comment ? En éliminant progressivement les variables, une par une, jusqu’à obtenir un système triangulaire.\nImaginez que vous essayez de démêler un nœud de câbles. Vous commencez par un bout, vous dégagez un câble, puis un autre, et ainsi de suite jusqu’à ce que tout soit bien ordonné. C’est exactement ce que fait la méthode de Gauss avec nos équations !"
  },
  {
    "objectID": "posts/pivotGauss/index.html#un-exemple-pour-mieux-comprendre",
    "href": "posts/pivotGauss/index.html#un-exemple-pour-mieux-comprendre",
    "title": "La méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !",
    "section": "Un exemple pour mieux comprendre",
    "text": "Un exemple pour mieux comprendre\nAllez, on se lance dans un exemple concret. On va résoudre un système de trois équations à trois inconnues. Attachez vos ceintures, ça va décoiffer !\nSoit le système suivant :\n\\[\n\\begin{cases}\n2&x &+& y &-& &z &=& 8 \\\\\n-3&x &-& y &+& 2&z &=& -11 \\\\\n-2&x &+& y &+& 2&z &=& -3\n\\end{cases}\n\\]\n\nÉtape 1 : On choisit notre pivot\nOn va utiliser la première équation comme pivot pour éliminer \\(x\\) dans les autres équations.\n\n\nÉtape 2 : On élimine \\(x\\) dans la deuxième et la troisième équation\n\nPour la deuxième équation, on ajoute 3/2 fois la première équation\nPour la troisième équation, on ajoute 1 fois la première équation\n\nOn obtient le système équivalent :\n\\[\n\\begin{cases}\n2&x &+& &y &-& &z &=& 8 \\\\\n& &&\\frac{1}{2}&y &+& \\frac{1}{2}&z &=& 1 \\\\\n& &&2&y &+& &z &=& 5\n\\end{cases}\n\\]\n\n\nÉtape 3 : On élimine \\(y\\) dans la troisième équation\nMaintenant, on utilise la deuxième équation comme pivot pour éliminer \\(y\\) dans la troisième équation. On multiplie la deuxième équation par \\(-4\\) et on l’ajoute à la troisième équation :\n\\[\n\\begin{cases}\n2& &+ &&y &- &&z &= 8 \\\\\n&&&\\frac{1}{2}&y &+ &\\frac{1}{2}&z &= 1 \\\\\n&& &&&-&&z &= 1\n\\end{cases}\n\\]\n\n\nÉtape 4 : On résout !\nEt voilà, on a notre système triangulaire ! C’est comme avoir dénoué tous nos câbles. Maintenant, on peut facilement trouver nos inconnues :\n\nDe la dernière équation : \\(z = -1\\)\nDe la deuxième équation : \\(\\frac{1}{2}y + \\frac{1}{2}(-1) = 1\\), donc \\(y = 3\\)\nDe la première équation : \\(2x + 3 + 1 = 8\\), donc \\(x = 2\\)\n\nNotre solution est donc \\((x, y, z) = (2, 3, -1)\\)."
  },
  {
    "objectID": "posts/pivotGauss/index.html#généralisation-et-équivalence-des-systèmes",
    "href": "posts/pivotGauss/index.html#généralisation-et-équivalence-des-systèmes",
    "title": "La méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !",
    "section": "Généralisation et équivalence des systèmes",
    "text": "Généralisation et équivalence des systèmes\nMaintenant que nous avons vu un exemple concret, parlons un peu de ce qui se passe en coulisses. La magie de la méthode du pivot de Gauss repose sur l’utilisation d’opérations élémentaires qui nous permettent de passer d’un système à un autre équivalent.\nMais qu’est-ce qu’un système équivalent ? C’est simple : deux systèmes sont équivalents s’ils ont exactement les mêmes solutions. En d’autres termes, peu importe lequel des deux systèmes, vous résolvez, vous obtiendrez le même résultat final.\nLes opérations élémentaires que nous utilisons sont :\n\nÉchanger deux équations\nMultiplier une équation par un nombre non nul\nAjouter à une équation un multiple d’une autre équation\n\nCes opérations sont comme des tours de magie mathématiques : elles transforment notre système, mais sans jamais changer ses solutions. C’est un peu comme si vous réarrangiez les pièces d’un puzzle sans changer l’image finale.\nPourquoi est-ce si important ? Eh bien, cela signifie que nous pouvons manipuler notre système initial pour le rendre plus simple à résoudre, sans craindre de perdre ou de modifier les solutions en cours de route. C’est ce qui nous permet de passer d’un système compliqué à un système triangulaire facile à résoudre, comme nous l’avons fait dans notre exemple.\nDans le cas général, pour un système de \\(n\\) équations à \\(n\\) inconnues, nous appliquons ces opérations de manière systématique :\n\nOn choisit un pivot (généralement le premier coefficient non nul de la première colonne) et on échange l’équation correspondante avec la première équation\nOn utilise ce pivot pour éliminer la première variable dans toutes les équations suivantes\nOn répète le processus avec la deuxième équation comme nouveau pivot, et ainsi de suite.\n\nÀ chaque étape, nous créons un nouveau système équivalent, jusqu’à obtenir un système triangulaire que nous pouvons résoudre facilement par substitution inverse.\nCette approche nous permet de résoudre des systèmes de plus en plus grands et complexes, tout en gardant la certitude que nos manipulations préservent les solutions originales. C’est la beauté et la puissance de la méthode du pivot de Gauss !"
  },
  {
    "objectID": "posts/pivotGauss/index.html#automatisons-tout-ça-avec-python",
    "href": "posts/pivotGauss/index.html#automatisons-tout-ça-avec-python",
    "title": "La méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !",
    "section": "Automatisons tout ça avec Python !",
    "text": "Automatisons tout ça avec Python !\nMaintenant que vous êtes des pros du pivot de Gauss, que diriez-vous d’automatiser tout ça avec un peu de code Python ? C’est parti !\nMais avant de plonger dans le code, parlons un peu de la façon dont nous allons représenter notre système d’équations en Python.\n\nReprésentation du système en Python\nEn Python, nous allons utiliser un tableau NumPy pour représenter notre système d’équations. Pourquoi NumPy ? Parce que c’est super efficace pour les calculs numériques et ça nous facilite la vie pour manipuler nos équations.\nVoici comment ça marche :\n\nChaque ligne du tableau représente une équation du système.\nLes colonnes représentent les coefficients des variables et le terme constant.\nLa dernière colonne contient les termes constants (les nombres à droite du signe égal dans nos équations).\n\nPar exemple, notre système initial :\n\\[\n\\begin{cases}\n2&x& +& y& -& &z& =& 8 \\\\\n-3&x& -& y& +& 2&z& =& -11 \\\\\n-2&x& +& y& +& 2&z& =& -3\n\\end{cases}\n\\]\nsera représenté par le tableau NumPy suivant :\nsysteme = np.array([\n    [2,  1, -1,  8],\n    [-3, -1,  2, -11],\n    [-2,  1,  2, -3]\n], dtype=float)\n\n\nAccès aux coefficients\nPour accéder aux différents coefficients dans notre tableau NumPy, on utilise l’indexation. Voici comment ça marche :\n\nsysteme[i, j] nous donne l’élément à la i-ème ligne et j-ème colonne.\nLes indices commencent à 0 (comme d’habitude en Python).\nPour un système de n équations à n inconnues :\n\nsysteme[i, j] pour i &lt; n et j &lt; n donne le coefficient de la (j+1)-ème variable dans la (i+1)-ème équation.\nsysteme[i, n] donne le terme constant de la (i+1)-ème équation.\n\n\nPar exemple :\n\nsysteme[0, 0] vaut 2 (coefficient de \\(x\\) dans la première équation)\nsysteme[1, 2] vaut 2 (coefficient de \\(z\\) dans la deuxième équation)\nsysteme[2, 3] vaut \\(-3\\) (terme constant de la troisième équation).\n\nCette représentation nous permet de manipuler facilement notre système d’équations en utilisant les opérations de NumPy, ce qui rend notre implémentation de la méthode du pivot de Gauss à la fois simple et efficace.\nMaintenant que nous avons compris comment représenter et manipuler notre système, passons au code !\n\nimport numpy as np\n\ndef echanger_equations(systeme, i, j):\n    systeme[i], systeme[j] = systeme[j].copy(), systeme[i].copy()\n\ndef multiplier_equation(systeme, i, facteur):\n    systeme[i] *= facteur\n\ndef ajouter_multiple_equation(systeme, i, j, facteur):\n    systeme[i] += facteur * systeme[j]\n\ndef pivot_gauss(systeme):\n    n, m = systeme.shape\n    for i in range(min(n, m - 1)):\n        # Trouver le pivot maximal\n        pivot = i + np.argmax(np.abs(systeme[i:, i]))\n        if systeme[pivot, i] == 0:\n            raise ValueError(\"Le système n'a pas de solution unique!\")\n        \n        # Échanger les équations\n        if pivot != i:\n            echanger_equations(systeme, i, pivot)\n        \n        # Éliminer les variables\n        for j in range(i + 1, n):\n            facteur = -systeme[j, i] / systeme[i, i]\n            ajouter_multiple_equation(systeme, j, i, facteur)\n    \n    return systeme\n\n# Exemple d'utilisation\nsysteme = np.array([\n    [2, 1, -1, 8],\n    [-3, -1, 2, -11],\n    [-2, 1, 2, -3]\n], dtype=float)\n\nprint(\"Système initial :\")\nprint(systeme)\n\nresultat = pivot_gauss(systeme)\nprint(\"\\nSystème après pivot de Gauss :\")\nprint(resultat)\n\nSystème initial :\n[[  2.   1.  -1.   8.]\n [ -3.  -1.   2. -11.]\n [ -2.   1.   2.  -3.]]\n\nSystème après pivot de Gauss :\n[[ -3.          -1.           2.         -11.        ]\n [  0.           1.66666667   0.66666667   4.33333333]\n [  0.           0.           0.2         -0.2       ]]\n\n\nExpliquons un peu ce code :\n\nechanger_equations, multiplier_equation, et ajouter_multiple_equation sont nos opérations élémentaires sur les équations. Elles utilisent l’indexation NumPy pour accéder et modifier les coefficients.\npivot_gauss est notre fonction principale qui applique la méthode du pivot de Gauss. Elle utilise systeme.shape pour obtenir les dimensions de notre tableau.\nDans pivot_gauss, on utilise np.argmax pour trouver l’indice du coefficient de plus grande valeur absolue, ce qui nous donne notre meilleur pivot pour minimiser les erreurs d’arrondi.\nLes opérations d’élimination utilisent l’indexation pour accéder aux coefficients appropriés et les modifier.\n\nEt voilà ! Avec ce code, vous pouvez résoudre des systèmes linéaires plus rapidement qu’il n’en faut pour dire “Carl Friedrich Gauss” !\nRésolvons par exemple le système de cinq équations à cinq inconnues suivant :\n\\[\n\\begin{cases}\n2&x& +& &y& -& &z& +& 2&w& -& 3&v& =& 8 \\\\\n-3&x& -& &y& +& 2&z& -& &w& +& 4&v& =& -11 \\\\\n-2&x& +& &y& +& 2&z& +& &w& -& 2&v& =& -3 \\\\\n&x& -& &y& +& & z& -& & w & +& & v& =& 2 \\\\\n4&x& -& 2&y& +& 3&z& -& 2&w& +& & v& =& 3\n\\end{cases}\n\\]\n\nsysteme = np.array([\n    [2, 1, -1, 2, -3, 8],\n    [-3, -1, 2, -1, 4, -11],\n    [-2, 1, 2, 1, -2, -3],\n    [1, -1, 1, -1, 1, 2],\n    [4, -2, 3, -2, 1, 3]\n], dtype=float)\n\nresultat = pivot_gauss(systeme)\nprint(\"Système après pivot de Gauss :\")\nprint(resultat)\n\nSystème après pivot de Gauss :\n[[ 4.         -2.          3.         -2.          1.          3.        ]\n [ 0.         -2.5         4.25       -2.5         4.75       -8.75      ]\n [ 0.          0.          3.5         0.         -1.5        -1.5       ]\n [ 0.          0.          0.          1.          0.68571429 -0.11428571]\n [ 0.          0.          0.          0.         -0.45714286  2.74285714]]\n\n\nIl n’y a plus qu’à remonter les équations pour trouver les valeurs de \\(x\\), \\(y\\), \\(z\\), \\(w\\), et \\(v\\).\nOn trouve en arrondissant les valeurs : \\(x=-2\\), \\(y=-17\\), \\(z=-3\\), \\(w=4\\), \\(v=-6\\)."
  },
  {
    "objectID": "posts/pivotGauss/index.html#conclusion",
    "href": "posts/pivotGauss/index.html#conclusion",
    "title": "La méthode du pivot de Gauss : résoudre des systèmes linéaires comme un pro !",
    "section": "Conclusion",
    "text": "Conclusion\nLa méthode du pivot de Gauss, c’est comme avoir un super-pouvoir pour résoudre des systèmes d’équations. Que vous le fassiez à la main ou avec Python, vous avez maintenant les outils pour dompter ces systèmes linéaires rebelles !\nAlors, la prochaine fois que quelqu’un vous parle de systèmes d’équations, vous pourrez fièrement dire : “Pas de panique, j’ai Gauss de mon côté !” 😎\n\n\n\nCarl Friedrich Gauss"
  },
  {
    "objectID": "posts/python_match/index.html",
    "href": "posts/python_match/index.html",
    "title": "Python match",
    "section": "",
    "text": "La version 3.10 de python est sortie le 4 octobre 2021 et apporte parmi d’autres améliorations, une nouvelle structure conditionnelle : la structure match ... case."
  },
  {
    "objectID": "posts/python_match/index.html#un-cas-simple",
    "href": "posts/python_match/index.html#un-cas-simple",
    "title": "Python match",
    "section": "Un cas simple",
    "text": "Un cas simple\nUne instruction de ce type existe déjà dans d’autres langages de programmation comme le JavaScript ou le C. Elle permet de tester une valeur et d’exécuter un bloc de code en fonction de la valeur testée. Dans ces deux langages, l’instruction s’appelle switch ... case. En python, elle s’appelle match ... case.\nVoici un exemple d’utilisation de l’instruction switch ... case en JavaScript :\n\n\nLangage JavaScript\n\nlet x = 3;\n\nswitch (x) {\n  case 1:\n    console.log(\"x est égal à 1\");\n    break;\n  case 2:\n    console.log(\"x est égal à 2\");\n    break;\n  case 3:\n    console.log(\"x est égal à 3\");\n    break;\n  case 4:\n    console.log(\"x est égal à 4\");\n    break;\n  default:\n    console.log(\"x n'est pas égal à 1, 2, 3 ou 4\");\n}\n\nEt maintenant de C :\n\n\nLangage C\n\nint x = 3;\n\nswitch (x) {\n  case 1:\n    printf(\"x est égal à 1\");\n    break;\n  case 2:\n    printf(\"x est égal à 2\");\n    break;\n  case 3:\n    printf(\"x est égal à 3\");\n    break;\n  case 4:\n    printf(\"x est égal à 4\");\n    break;\n  default:\n    printf(\"x n'est pas égal à 1, 2, 3 ou 4\");\n}\n\nC’est la même chose ! On retrouve la même structure dans les deux langages. En python, c’est la même chose :\n\n\nPython\n\n\nx = 3\n\nmatch x:\n    case 1:\n        print(\"x est égal à 1\")\n    case 2:\n        print(\"x est égal à 2\")\n    case 3:\n        print(\"x est égal à 3\")\n    case 4:\n        print(\"x est égal à 4\")\n    case _:\n        print(\"x n'est pas égal à 1, 2, 3 ou 4\")\n\nOn peut voir que l’instruction match ... case est très proche de l’instruction if ... elif ... else en python. La différence est que l’instruction match ... case permet de tester plusieurs valeurs d’une variable en une seule instruction. C’est très pratique pour vérifier les valeurs d’une variable.\nPar rapport aux autres langages mentionnés, on remarquera qu’il n’est pas nécessaire en python d’utiliser l’instruction break, c’est comme d’habitude l’indentation qui délimite les blocs de code.\nPar ailleurs, pas d’instruction default en python, on utilise l’instruction case _ pour gérer le cas par défaut."
  },
  {
    "objectID": "posts/python_match/index.html#un-cas-plus-complexe",
    "href": "posts/python_match/index.html#un-cas-plus-complexe",
    "title": "Python match",
    "section": "Un cas plus complexe",
    "text": "Un cas plus complexe\nL’instruction match ... case permet de faire des choses beaucoup plus complexes, on peut par exemple ajouter des conditions à chaque cas (source : Sumner (2021)) :\n\n\nPython\n\nimport random\ncible = random.randint (0, 100)\n\nnbEssai = 0\ngameOver = False\n\nwhile gameOver == False:\n   print ( f\"Vous avez essayé {nbEssai} fois\")\n   proposition = int (input (\"Votre essai : \"))\n   match proposition:\n      case ( i ) if i &lt; 0 or i &gt; 100:\n         print(\"Le nombre doit être compris entre 0 et 100 \")\n      case ( i ) if i &lt; cible:\n         print(\"Trop petit !\")\n         nbEssai += 1\n      case ( i ) if i &gt; cible:\n         print(\"Trop grand!\")\n         nbEssai += 1\n      case ( i ) if i == cible:\n         print(\"Gagné !\")\n         gameOver = True\n\nDans ce jeu de devinette, la variable proposition est remplacées dans les conditions case par la variable i. C’est une variable temporaire qui prend la valeur de proposition pour chaque cas. On peut donc utiliser i dans les conditions if pour tester la valeur de proposition.\nUn dernier exemple pour terminer (source : Moisset (2020)):\n\n\nPython\n\nreponse = input(\"Entrez votre prénom et votre nom : \")\n\nmatch reponse.split():\n    case [prenom, nom]:\n        print(f\"Bonjour {prenom} {nom} !\")\n    case [mot_unique]:\n        print(f\"Bonjour {mot_unique} ! Il me manque votre nom complet.\")\n    case [prenom, nom, *_]:\n        print(f\"Bonjour {prenom} {nom} ! Vous m'avez donné trop d'informations.\")\n\nDans cet exemple, on utilise la méthode split pour découper la chaîne de caractères reponse en une liste de mots. On utilise ensuite cette liste dans les conditions case pour tester le nombre de mots dans la chaîne de caractères. Le symbole *_ est utilisé pour représenter un nombre quelconque de mots.\nVoici par exemple le résultat de l’exécution de ce programme dans la console python :\n\n\nConsole python\n\n&gt;&gt;&gt; Entrez votre prénom et votre nom : Jean Dupont\nBonjour Jean Dupont !\n&gt;&gt;&gt; Entrez votre prénom et votre nom : Jean\nBonjour Jean ! Il me manque votre nom complet.\n&gt;&gt;&gt; Entrez votre prénom et votre nom : Jean Dupont et je suis un génie\nBonjour Jean Dupont ! Vous m'avez donné trop d'informations."
  },
  {
    "objectID": "posts/python_match/index.html#conclusion",
    "href": "posts/python_match/index.html#conclusion",
    "title": "Python match",
    "section": "Conclusion",
    "text": "Conclusion\nL’instruction match ... case est une instruction très puissante qui permet de simplifier le code et de le rendre plus lisible. Elle permet de tester plusieurs valeurs d’une variable en une seule instruction, mais il est aussi possible de tester des conditions plus complexes, comme le type de variable ou la longueur d’une liste, en ajoutant des conditions.\nPour un aperçu complet de toutes les possibilités de l’instruction match ... case, je vous invite à consulter la documentation officielle : https://docs.python.org/fr/3/tutorial/controlflow.html?highlight=match#match-statements et les références ci-dessous."
  },
  {
    "objectID": "posts/pyxel_tuto1_base/index.html",
    "href": "posts/pyxel_tuto1_base/index.html",
    "title": "Tuto pyxel : code de base",
    "section": "",
    "text": "La structure générale d’une application Pyxel sera toujours la même.\nOn commence par importer la bibliothèque Pyxel, puis on crée une classe App qui contient les méthodes __init__, update et draw. Enfin, il faut instancier la classe et lancer l’application avec la méthode run.\nimport pyxel\n\nclass App:\n    def __init__(self):\n        pyxel.init(256, 256, title=\"Exemple de base\", quit_key=pyxel.KEY_Q, fps=30)\n        pyxel.run(self.update, self.draw)\n\n    def update(self):\n        pass\n\n    def draw(self):\n        pass\n\nApp()\n\npyxel.init(256, 256, title=\"Exemple de base\", quit_key=pyxel.KEY_Q, fps=30) : on initialise la fenêtre de l’application avec une taille de 256x256 pixels et on définit le titre de la fenêtre. On définit aussi la touche qui permettra de quitter l’application (ici la touche Q) et le nombre d’images par seconde (frames per second) (30).\npyxel.run(self.update, self.draw) : on lance l’application en appelant les méthodes update et draw de la classe App.\ndef update(self): : cette méthode est appelée à chaque image (donc ici 30 fois par seconde). C’est ici qu’on mettra à jour les données de l’application.\ndef draw(self): : cette méthode est appelée à chaque image (donc ici 30 fois par seconde). C’est ici qu’on dessinera les éléments de l’application.\n\nVoici la fenêtre obtenue avec le code ci-dessus :\n\n\n\nfenêtre vide\n\n\nRemarque : certains calculs de coordonnées des objets de l’applications devront être faits en fonction des dimensions de la fenêtre. Pour cela, on peut utiliser les variables pyxel.width et pyxel.height qui contiennent respectivement la largeur et la hauteur de la fenêtre.\n\n\n\n\n\n\nUtilisation de Pyxelstudio\n\n\n\nSi vous programmez dans pyxelstudio, les paramètres title et quit_key de la méthode pyxel.init ne sont pas pris en compte."
  },
  {
    "objectID": "posts/pyxel_tuto3_fond/index.html",
    "href": "posts/pyxel_tuto3_fond/index.html",
    "title": "Tuto pyxel : Ajouter un fond",
    "section": "",
    "text": "Ce tuto fait suite au précédent : Tuto pyxel : Animer un personnage."
  },
  {
    "objectID": "posts/pyxel_tuto3_fond/index.html#préparation",
    "href": "posts/pyxel_tuto3_fond/index.html#préparation",
    "title": "Tuto pyxel : Ajouter un fond",
    "section": "Préparation",
    "text": "Préparation\nNous reprenons le code du tuto précédent comme base de travail, mais nous allons le réorganiser. Plusieurs nouveaux éléments vont en effet devoir être ajoutés au fur et à mesure du développement du jeu, et certains d’entre eux devront, comme le personnage, être animés ou voir certaines de leurs propriétés modifiées au cours du temps. Nous allons donc définir des classes pour chacun de ces éléments, afin de pouvoir les manipuler plus facilement et pour rendre notre code plus lisible. Chacune de ces classes comportera au moins trois méthodes : __init__ pour initialiser l’objet et ses paramètres de départ, puis update et draw. La première sera appelée à chaque frame pour mettre à jour les propriétés de l’objet, la seconde sera appelée pour afficher l’objet à l’écran.\nVoici donc le code de départ, réorganisé avec la création d’une classe Personnage. Les méthodes update et draw de cette classe sont appelées depuis les méthodes update et draw de l’application.\nimport pyxel\n\nclass Personnage:\n\n    def __init__(self):\n        self.x = 0\n        self.y = pyxel.height - 16\n        self.direction = 1\n        self.marche = False\n        self.vitesse = 2\n        self.personnage_marche = False\n\n    def update(self):\n        if pyxel.btn(pyxel.KEY_LEFT):\n            self.x = max(self.x - self.vitesse, 0)\n            self.direction = -1\n            self.personnage_marche = True\n        if pyxel.btn(pyxel.KEY_RIGHT):\n            self.x = min(self.x + self.vitesse, pyxel.width - 16)\n            self.direction = 1\n            self.personnage_marche = True\n    \n    def draw(self):\n        if self.personnage_marche:\n            if pyxel.frame_count % 6 &lt; 3:\n                pyxel.blt(self.x, pyxel.height-16, 0, 0, 0, self.direction*16, 16)\n            else:\n                pyxel.blt(self.x, pyxel.height-16, 0, 16, 0, self.direction*16, 16)\n            self.personnage_marche = False\n        else:\n            pyxel.blt(self.x, pyxel.height-16, 0, 0, 0, self.direction*16, 16)\n    \n\nclass App:\n    def __init__(self):\n        pyxel.init(256, 128, fps=30)\n        pyxel.load(\"jump_game.pyxres\")\n        self.personnage = Personnage()\n        pyxel.run(self.update, self.draw)\n        \n    def update(self):\n        self.personnage.update()\n\n    def draw(self):\n        pyxel.cls(12)\n        self.personnage.draw()\n\nApp()"
  },
  {
    "objectID": "posts/pyxel_tuto3_fond/index.html#fond-statique-montagne-et-ciel",
    "href": "posts/pyxel_tuto3_fond/index.html#fond-statique-montagne-et-ciel",
    "title": "Tuto pyxel : Ajouter un fond",
    "section": "Fond statique : Montagne et ciel",
    "text": "Fond statique : Montagne et ciel\nL’objectif est de créer le fond de la fenêtre de jeu à l’aide de quatre composantes :\n\nune montagne : elle sera fixe et située au milieu de la fenêtre ;\nun ciel dégradé : il sera fixe et situé sous la montagne ;\ndes nuages : ils seront animés, situés au-dessus de la montagne et défileront dans le ciel ;\nune forêt : elle sera animée, située derrière le personnage et défilera dans le bas de la fenêtre lorsque le personnage se déplace.\n\n\n\n\n\n\n\nIdée à retenir\n\n\n\nD’une manière générale, les objets statiques (dont la position ne change pas et dont les propriétés ne changent pas) peuvent être définis directement dans la classe App. Par contre, pour les objets dynamiques (soit parce qu’ils se déplacent, soit parce que leurs propriétés changent), on crée une classe indépendante dotée (au moins) des trois méthodes __init__, update et draw.\n\n\nL’examen du fichier de ressources nous permet de déterminer les coordonnées de la zone de l’image correspondant à ces éléments.\n\nMontagne : le coin supérieur gauche a pour coordonnées 0 et 64, l’image a une largeur de 160 pixels et une hauteur de 24 pixels.\nCiel : le coin supérieur gauche a pour coordonnées 0 et 88, l’image a une largeur de 160 pixels et une hauteur de 32 pixels.\n\nOn ajoute donc ces deux éléments à l’arrière plan de la fenêtre de jeu en modifiant comme suit la méthode draw de la classe App :\ndef draw(self): # classe App\n        pyxel.cls(12)\n         # Tracé de la montagne\n        pyxel.blt(pyxel.width//2 - 80, pyxel.height-50, 0, 0, 64, 160, 24)\n        # Tracé du ciel dégradé\n        pyxel.blt(0,pyxel.height-32, 0, 0, 88, 160, 32, 12)\n        pyxel.blt(160,pyxel.height-32, 0, 0, 88, 160, 32, 12)\n        self.personnage.draw()\nExplications :\n\nLigne 4 : pyxel.width//2 - 80 est l’abscisse du coin supérieur gauche de l’image dans la fenêtre de jeu. pyxel.width//2 est l’abscisse du milieu de la fenêtre, 80 est la moitié de la largeur de l’image. L’ordonnée pyxel.height-50 est choisie par tâtonnement pour que la montagne soit bien positionnée verticalement dans la fenêtre.\nLignes 6 et 7 : la largeur de la fenêtre est 256 pixels, la largeur de l’image est 160 pixels, il faut donc répéter l’image deux fois pour remplir toute la largeur de la fenêtre. On a ajouté ici le dernier paramètre 12 à la fonction blt pour que la couleur 12 (bleu) soit transparente. Cela permet de voir la montagne à travers le ciel dégradé.\n\nComme le montre l’image ci-dessous, il faut aussi ajouter un dernier paramètre à la fonction blt pour que la couleur 12 (bleu) soit transparente également pour le personnage (dons dans la méthode draw de la classe Personnage).\n\n\n\nLa couleur bleue derrière le personnage devient transparente"
  },
  {
    "objectID": "posts/pyxel_tuto3_fond/index.html#animation-des-nuages",
    "href": "posts/pyxel_tuto3_fond/index.html#animation-des-nuages",
    "title": "Tuto pyxel : Ajouter un fond",
    "section": "Animation des nuages",
    "text": "Animation des nuages\nAvec le temps qui passe, les nuages se déplacent lentement vers la gauche et d’autres nuages apparaissent sur la droite. Lorsqu’un nuage a complètement disparu de la fenêtre, il est retiré de la liste des nuages.\nNous allons définir une classe Nuage qui possède ses propres méthodes update et draw, comme le montre le code ci-dessous.\nclass Nuage:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.replaced = False\n\n    def update(self):\n        if pyxel.frame_count % 10 == 0:\n            self.x = self.x -1\n\n    def draw(self):\n        pyxel.blt(self.x, self.y, 0, 0, 24, 160, 16, 12)\nExplications :\n\nLigne 8 : if pyxel.frame_count % 10 == 0: permet de faire avancer le nuage de 1 pixel vers la gauche trois fois par seconde, puisque notre application a un framerate de 30 fps.\nLigne 5 : Un attribut booléen replaced est ajouté à la classe Nuage pour indiquer si le nuage a été remplacé par un nouveau nuage. Cela permet de ne pas créer un nouveau nuage à chaque frame (voir plus loin).\n\nL’idée est de faire apparaître un nouveau nuage dans le ciel dès que le nuage précédent s’approche du bord gauche de l’écran. Pour cela, il sera nécessaire de définir une liste de nuages dans la classe App et de la mettre à jour à chaque frame. Voici le code modifié de la méthode __init__ de la classe App, dans lequel on initialise la liste des nuages avec un seul nuage placé au milieu de la fenêtre (lignes 6, 7 et 8).\ndef __init__(self): # class App\n    pyxel.init(256, 128, fps=30)\n    pyxel.load(\"jump_game.pyxres\")\n    self.personnage = Personnage()\n    # liste des nuages visibles\n    self.nuages = []\n    premier_nuage = Nuage(x = pyxel.width//2-80, y = pyxel.height//4)\n    self.nuages.append(premier_nuage)\n    pyxel.run(self.update, self.draw)\nOn modifie ensuite la méthode update de la classe App pour mettre à jour la liste des nuages et faire apparaître un nouveau nuage dès que le nuage précédent s’approche du bord gauche de la fenêtre.\ndef update(self): # class App\n        self.personnage.update()\n        for nuage in self.nuages:\n            nuage.update()\n            if nuage.x &lt; 10 and not nuage.replaced:\n                nouveau_nuage = Nuage(pyxel.width, pyxel.height//4)\n                self.nuages.append(nouveau_nuage)\n                nuage.replaced = True\n            if nuage.x &lt; -160:\n                self.nuages.remove(nuage)\nExplications :\n\nLignes 3 et 4 : la boucle for nuage in self.nuages permet de parcourir la liste des nuages et d’appliquer la méthode update à chacun d’entre eux.\nLignes 5 à 8 : chaque nuage de la liste est mis à jour et, dès qu’un nuage a son abscisse inférieure à 10 (et qu’il n’a pas encore été remplacé), un nouveau nuage est créé. L’ancien nuage est alors marqué comme remplacé, afin d’éviter de créer un nouveau nuage à chaque frame : nuage.replaced = True.\nLignes 9 et 10 : lorsque le nuage a complètement disparu de la fenêtre, il est retiré de la liste : self.nuages.remove(nuage).\n\nDernière étape, on modifie la méthode draw de la classe App pour afficher tous les nuages de la liste.\ndef draw(self): # class App\n        pyxel.cls(12)\n         # Tracé de la montagne\n        pyxel.blt(pyxel.width//2 - 80, pyxel.height-50, 0, 0, 64, 160, 24)\n        # Tracé du ciel dégradé\n        pyxel.blt(0,pyxel.height-32, 0, 0, 88, 160, 32, 12)\n        pyxel.blt(160,pyxel.height-32, 0, 0, 88, 160, 32, 12)\n        # Tracé des nuages\n        for nuage in self.nuages:\n            nuage.draw()\n        self.personnage.draw()\n\n\n\nAnimation des nuages"
  },
  {
    "objectID": "posts/pyxel_tuto3_fond/index.html#animation-de-la-forêt",
    "href": "posts/pyxel_tuto3_fond/index.html#animation-de-la-forêt",
    "title": "Tuto pyxel : Ajouter un fond",
    "section": "Animation de la forêt",
    "text": "Animation de la forêt\nPour rendre plus réaliste le déplacement du personnage, on peut provoquer un déplacement de la forêt en sens contraire du déplacement du personnage. La montagne et le ciel, eux, peuvent rester fixes, car situés à une grande distance du personnage. Cela donne un effet de profondeur à la scène.\nDans le fichier de ressources, la forêt est constituée d’une image de largeur 160 pixels et de hauteur 16 pixels. Nous allons donc avoir besoin de répéter cette image pour remplir toute la largeur de la fenêtre. De plus, comme la forêt est animée, il faut prendre garde à créer une nouvelle copie de l’image à chaque fois que l’image précédente ne rempli plus totalement la largeur de la fenêtre.\nPour cela, on va créer une classe Foret qui possède ses propres méthodes update et draw, comme le montre le code ci-dessous.\nclass Foret:\n    def __init__(self):\n        self.x = 0\n        self.vitesse = 1\n        self.direction = 1\n\n    def update(self):\n        if pyxel.btn(pyxel.KEY_LEFT):\n            self.x = self.x + self.vitesse\n            self.direction = 1\n        if pyxel.btn(pyxel.KEY_RIGHT):\n            self.x = self.x - self.vitesse\n            self.direction = -1\n    \n    def draw(self):\n        k = 0\n        while self.x - k*160 &gt; -160 :\n            pyxel.blt(self.x - k*160,pyxel.height-16, 0, 0, 48, 160, 16, 12)\n            k = k + 1\n        k = 1\n        while self.x + k*160 &lt; pyxel.width :\n            pyxel.blt(self.x + k*160,pyxel.height-16, 0, 0, 48, 160, 16, 12)\n            k = k + 1\nExplications :\n\nLigne 3 : self.x est l’abscisse du coin supérieur gauche de l’image dans la fenêtre de jeu. On initialise cette abscisse à 0.\nLigne 8 : if pyxel.btn(pyxel.KEY_LEFT): permet de faire avancer la forêt vers la droite lorsque la touche flèche gauche est enfoncée.\nLigne 10 : if pyxel.btn(pyxel.KEY_RIGHT): permet de faire avancer la forêt vers la gauche lorsque la touche flèche droite est enfoncée.\nLignes 17 à 23 : on utilise une boucle while pour répéter l’image de la forêt autant de fois que nécessaire pour remplir toute la largeur de la fenêtre. La variable k permet de compter le nombre de répétitions nécessaires. On commence par répéter l’image vers la gauche, puis vers la droite.\n\nPour intégrer cet objet Foret à notre application, il faut maintenant ajouter une ligne à chacune des méthodes de la classe App :\n\nDans la méthode __init__, on crée un objet Foret et on l’ajoute à la liste des attributs de la classe App.\nself.foret = Foret()\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention : il faut ajouter cette ligne après la ligne pyxel.init(256, 128, fps=30) et avant la ligne pyxel.run(self.update, self.draw).\n\n\n\nDans la méthode update, on met à jour l’objet Foret.\nself.foret.update()\nDans la méthode draw, on affiche l’objet Foret.\nself.foret.draw()\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention : il faut ajouter cette ligne avant la ligne self.personnage.draw() : sinon, la forêt sera dessinée devant le personnage.\n\n\n\n\n\nAnimation de la forêt"
  },
  {
    "objectID": "posts/record-battu-pour-les-nombres-premiers/index.html",
    "href": "posts/record-battu-pour-les-nombres-premiers/index.html",
    "title": "Record battu pour les nombres premiers !",
    "section": "",
    "text": "Le 21 octobre 2024, le projet GIMPS (Great Internet Mersenne Prime Search) a annoncé la découverte d’un nouveau nombre premier de Mersenne, 2136279841-1, composé de 41 024 320 chiffres. Cette découverte marque un tournant dans l’histoire de GIMPS, car elle met fin à 28 années de domination des ordinateurs personnels dans la recherche de ces nombres rares.\nEn effet, ce nombre premier record a été découvert grâce à l’utilisation de GPUs (processeurs graphiques), une technologie initialement utilisée pour les cartes vidéo et le minage de cryptomonnaies, mais qui est aujourd’hui au cœur de la révolution de l’intelligence artificielle. Mihai Preda, un contributeur de GIMPS, a développé un logiciel de recherche de nombres premiers de Mersenne compatible avec les GPUs en 2017. Luke Durant, un ancien employé de NVIDIA et fervent partisan des GPUs, a vu en cette technologie une opportunité unique pour GIMPS.\nDurant a mis en place une infrastructure pour exécuter et maintenir une suite de logiciels GIMPS sur plusieurs serveurs GPU, créant ainsi un “supercalculateur cloud”. Ce réseau, composé de milliers de GPUs répartis dans 24 centres de données et 17 pays, a permis à Durant de découvrir le nouveau nombre premier après près d’un an de recherche. Le 11 octobre 2024, un GPU NVIDIA A100 à Dublin, en Irlande, a signalé que M136279841 était probablement premier, et le 12 octobre, un GPU NVIDIA H100 à San Antonio, au Texas, a confirmé sa primalité à l’aide d’un test de Lucas-Lehmer.\nUne fois le nombre premier probable identifié, plusieurs tests de Lucas-Lehmer ont été effectués par différents contributeurs de GIMPS utilisant différents programmes et matériels pour confirmer la découverte. Cette collaboration a impliqué Aaron Blosser utilisant Prime95 sur des CPUs Intel, ainsi que Durant, James Heinrich, Serge Batalov, Ken Kriesel et Preda utilisant PRPLL/GpuOwl sur des GPUs AMD et NVIDIA. La primalité du nombre a été confirmée le 19 octobre par Serge Batalov utilisant Mlucas sur un CPU Intel.\nGIMPS, fondé en 1996 par George Woltman, est un projet collaboratif qui rassemble des milliers de bénévoles à la recherche de nombres premiers de Mersenne. Ces nombres premiers, nommés d’après le moine français Marin Mersenne, sont de la forme 2P-1, où P est un nombre premier. GIMPS a permis de découvrir les 18 derniers nombres premiers de Mersenne, dont le nouveau record. Le projet offre une récompense de 3 000 $ à toute personne découvrant un nouveau nombre premier.\nLuke Durant, le découvreur du 52e nombre premier de Mersenne, est l’un des contributeurs les plus prolifiques de GIMPS. Son investissement dans le projet, qui a impliqué des dépenses considérables pour l’utilisation de GPUs dans le cloud, témoigne de son engagement envers la recherche mathématique. Durant prévoit de faire don de sa récompense de 3 000 $ au département de mathématiques de l’Alabama School of Math and Science.\nCette découverte marque une étape importante dans l’histoire de GIMPS et de la recherche de nombres premiers. L’utilisation de GPUs dans le cloud ouvre de nouvelles perspectives pour le projet et pourrait accélérer la découverte de futurs nombres premiers de Mersenne. La collaboration entre les bénévoles et l’utilisation de technologies innovantes ont permis de repousser les limites de la connaissance mathématique."
  },
  {
    "objectID": "posts/record-battu-pour-les-nombres-premiers/index.html#la-découverte-dun-nombre-premier-record-une-nouvelle-ère-pour-gimps",
    "href": "posts/record-battu-pour-les-nombres-premiers/index.html#la-découverte-dun-nombre-premier-record-une-nouvelle-ère-pour-gimps",
    "title": "Record battu pour les nombres premiers !",
    "section": "",
    "text": "Le 21 octobre 2024, le projet GIMPS (Great Internet Mersenne Prime Search) a annoncé la découverte d’un nouveau nombre premier de Mersenne, 2136279841-1, composé de 41 024 320 chiffres. Cette découverte marque un tournant dans l’histoire de GIMPS, car elle met fin à 28 années de domination des ordinateurs personnels dans la recherche de ces nombres rares.\nEn effet, ce nombre premier record a été découvert grâce à l’utilisation de GPUs (processeurs graphiques), une technologie initialement utilisée pour les cartes vidéo et le minage de cryptomonnaies, mais qui est aujourd’hui au cœur de la révolution de l’intelligence artificielle. Mihai Preda, un contributeur de GIMPS, a développé un logiciel de recherche de nombres premiers de Mersenne compatible avec les GPUs en 2017. Luke Durant, un ancien employé de NVIDIA et fervent partisan des GPUs, a vu en cette technologie une opportunité unique pour GIMPS.\nDurant a mis en place une infrastructure pour exécuter et maintenir une suite de logiciels GIMPS sur plusieurs serveurs GPU, créant ainsi un “supercalculateur cloud”. Ce réseau, composé de milliers de GPUs répartis dans 24 centres de données et 17 pays, a permis à Durant de découvrir le nouveau nombre premier après près d’un an de recherche. Le 11 octobre 2024, un GPU NVIDIA A100 à Dublin, en Irlande, a signalé que M136279841 était probablement premier, et le 12 octobre, un GPU NVIDIA H100 à San Antonio, au Texas, a confirmé sa primalité à l’aide d’un test de Lucas-Lehmer.\nUne fois le nombre premier probable identifié, plusieurs tests de Lucas-Lehmer ont été effectués par différents contributeurs de GIMPS utilisant différents programmes et matériels pour confirmer la découverte. Cette collaboration a impliqué Aaron Blosser utilisant Prime95 sur des CPUs Intel, ainsi que Durant, James Heinrich, Serge Batalov, Ken Kriesel et Preda utilisant PRPLL/GpuOwl sur des GPUs AMD et NVIDIA. La primalité du nombre a été confirmée le 19 octobre par Serge Batalov utilisant Mlucas sur un CPU Intel.\nGIMPS, fondé en 1996 par George Woltman, est un projet collaboratif qui rassemble des milliers de bénévoles à la recherche de nombres premiers de Mersenne. Ces nombres premiers, nommés d’après le moine français Marin Mersenne, sont de la forme 2P-1, où P est un nombre premier. GIMPS a permis de découvrir les 18 derniers nombres premiers de Mersenne, dont le nouveau record. Le projet offre une récompense de 3 000 $ à toute personne découvrant un nouveau nombre premier.\nLuke Durant, le découvreur du 52e nombre premier de Mersenne, est l’un des contributeurs les plus prolifiques de GIMPS. Son investissement dans le projet, qui a impliqué des dépenses considérables pour l’utilisation de GPUs dans le cloud, témoigne de son engagement envers la recherche mathématique. Durant prévoit de faire don de sa récompense de 3 000 $ au département de mathématiques de l’Alabama School of Math and Science.\nCette découverte marque une étape importante dans l’histoire de GIMPS et de la recherche de nombres premiers. L’utilisation de GPUs dans le cloud ouvre de nouvelles perspectives pour le projet et pourrait accélérer la découverte de futurs nombres premiers de Mersenne. La collaboration entre les bénévoles et l’utilisation de technologies innovantes ont permis de repousser les limites de la connaissance mathématique."
  },
  {
    "objectID": "posts/record-battu-pour-les-nombres-premiers/index.html#que-sont-les-nombres-premiers-de-mersenne",
    "href": "posts/record-battu-pour-les-nombres-premiers/index.html#que-sont-les-nombres-premiers-de-mersenne",
    "title": "Record battu pour les nombres premiers !",
    "section": "Que sont les nombres premiers de Mersenne ?",
    "text": "Que sont les nombres premiers de Mersenne ?\n\n\n\nMarin Mersenne\n\n\nLes nombres premiers de Mersenne sont des nombres premiers de la forme \\(2^P-1\\), où \\(P\\) est un nombre premier. Ils sont nommés d’après le moine français Marin Mersenne, qui a étudié ces nombres au 17e siècle. Les nombres premiers de Mersenne sont particulièrement intéressants pour les mathématiciens en raison de leur forme simple et de leurs propriétés mathématiques. Ils ont des applications dans divers domaines des mathématiques et de l’informatique, notamment la cryptographie et la théorie des nombres.\nTous les nombres de la forme \\(2^P-1\\) ne sont pas des nombres premiers de Mersenne. Par exemple, \\(2^{11}-1=2047\\) n’est pas un nombre premier, car il peut être décomposé en \\(23 \\times 89\\). La recherche de nombres premiers de Mersenne est un domaine actif de la recherche mathématique, et de nombreux projets, dont GIMPS, sont dédiés à leur découverte."
  },
  {
    "objectID": "posts/record-battu-pour-les-nombres-premiers/index.html#quelques-explications-sur-le-teste-de-lucas-lehmer",
    "href": "posts/record-battu-pour-les-nombres-premiers/index.html#quelques-explications-sur-le-teste-de-lucas-lehmer",
    "title": "Record battu pour les nombres premiers !",
    "section": "Quelques explications sur le teste de Lucas-Lehmer",
    "text": "Quelques explications sur le teste de Lucas-Lehmer\nLe test de Lucas-Lehmer est une méthode utilisée pour déterminer si un nombre de Mersenne est premier. Il repose sur une suite récurrente définie par la relation de récurrence suivante :\n\\[\nS_0 = 4, \\quad S_{n+1} = S_n^2 - 2\n\\]\nUn nombre de Mersenne \\(2^P-1\\) est premier si et seulement si \\(S_{P-2} \\equiv 0 \\pmod{2^P-1}\\). Autrement dit, si \\(S_{P-2}\\) est divisible par \\(2^P-1\\), alors le nombre de Mersenne est premier.\nLe test de Lucas-Lehmer est particulièrement efficace pour les nombres de Mersenne, car il permet de vérifier leur primalité en un temps polynomial par rapport à la taille du nombre. Cela en fait un outil précieux pour la recherche de nombres premiers de Mersenne.\nVoici une fonction Python qui implémente le test de Lucas-Lehmer pour vérifier si un nombre de Mersenne est premier :\n\ndef lucas_lehmer(p):\n    s = 4\n    m = 2**p - 1\n    for _ in range(p - 2):\n        s = (s**2 - 2) % m\n    return s == 0\n\n# test avec p = 7 (nombre de Mersenne 2^7 - 1 = 127 premier)\np = 7\nif lucas_lehmer(p):\n    print(f\"Le nombre de Mersenne 2^{p} - 1 est premier.\")\nelse:\n    print(f\"Le nombre de Mersenne 2^{p} - 1 n'est pas premier.\")\n\n# test avec p = 11 (nombre de Mersenne 2^11 - 1 = 2047 = 23 * 89)\np = 11\nif lucas_lehmer(p):\n    print(f\"Le nombre de Mersenne 2^{p} - 1 est premier.\")\nelse:\n    print(f\"Le nombre de Mersenne 2^{p} - 1 n'est pas premier.\")\n\nLe nombre de Mersenne 2^7 - 1 est premier.\nLe nombre de Mersenne 2^11 - 1 n'est pas premier.\n\n\nDans cette fonction, p est l’exposant du nombre de Mersenne, et la fonction renvoie True si le nombre de Mersenne est premier et False sinon.\nÉvidemment, pour des nombres de Mersenne de taille importante, il est nécessaire d’utiliser des algorithmes et des implémentations plus sophistiqués pour effectuer le test de Lucas-Lehmer de manière efficace."
  },
  {
    "objectID": "posts/record-battu-pour-les-nombres-premiers/index.html#vous-aussi-participez-à-la-recherche-de-nombres-premiers",
    "href": "posts/record-battu-pour-les-nombres-premiers/index.html#vous-aussi-participez-à-la-recherche-de-nombres-premiers",
    "title": "Record battu pour les nombres premiers !",
    "section": "Vous aussi, participez à la recherche de nombres premiers !",
    "text": "Vous aussi, participez à la recherche de nombres premiers !\n\n\n\nLe site de GIMPS\n\n\nSi vous êtes passionné par les mathématiques et que vous souhaitez contribuer à la recherche de nombres premiers, vous pouvez rejoindre le projet GIMPS en téléchargeant le logiciel Prime95 sur votre ordinateur. Le logiciel utilise la puissance de calcul de votre CPU pour effectuer des tests de primalité sur des nombres de Mersenne. En participant à ce projet, vous contribuerez à l’avancement de la recherche mathématique et aurez peut-être la chance de découvrir le prochain nombre premier record ! Vous pourrez alors entrer dans l’histoire des mathématiques en tant que découvreur d’un nombre premier de Mersenne et recevoir une récompense de 3 000 $."
  },
  {
    "objectID": "posts/record-battu-pour-les-nombres-premiers/index.html#pour-aller-plus-loin",
    "href": "posts/record-battu-pour-les-nombres-premiers/index.html#pour-aller-plus-loin",
    "title": "Record battu pour les nombres premiers !",
    "section": "Pour aller plus loin",
    "text": "Pour aller plus loin\nDeux vidéos qui parlent de cette découverte :"
  },
  {
    "objectID": "posts/transistors/index.html",
    "href": "posts/transistors/index.html",
    "title": "Les transistors expliqués",
    "section": "",
    "text": "C’est le titre d’une excellente vidéo de la chaîne Mentalité Ingénieur, sur Youtube, qui explique de façon claire et imagée le fonctionnement d’un transistor, élément de base de toute puce informatique."
  },
  {
    "objectID": "posts/tropheesnsi/index.html",
    "href": "posts/tropheesnsi/index.html",
    "title": "Participer aux trophées NSI",
    "section": "",
    "text": "Les trophées NSI récompensent des projets informatiques réalisés dans le cadre de l’enseignement de spécialité « numérique et sciences informatiques ».\n\n\n\n\nLes objectifs du concours sont les suivants :\n\n\n\n\n\nValoriser l’enseignement de spécialité NSI.\n\n\nMettre en avant les projets réalisés pendant l’année scolaire.\n\n\nEncourager le travail en équipe.\n\n\n\n\n\nL’inscription et la participation se font par l’intermédiaire du professeur de NSI des participants.\n\n\n\n\nDe quoi s’agit-il ?\n\n\n\n\nTous les élèves suivant la spécialité NSI en première et/ou en terminale peuvent participer.\n\n\n\n\nLes élèves qui désirent participer aux trophées NSI forment une équipe de 2 à 5 personnes maximum (du même niveau scolaire). Ils choisissent un projet informatique qu’ils vont développer en équipe tout au long de l’année scolaire. Ce projet doit obligatoirement s’inscrire dans le cadre du programme de NSI. Il peut s’agir de développer un logiciel répondant à un certain besoin, un site web, … En ce qui concerne la programmation, le langage utilisé a priori est Python, mais d’autres langages open source peuvent être acceptés. Le code doit être soigné, documenté et placé sous licence libre. Enfin, une courte vidéo de présentation du projet doit être réalisée par l’équipe.\n\n\n\n\nLors de la session 2022, la date limite d’envoi des projets était le 5 mai 2022.\n\n\n\n\nLes projets sont ensuite évalués, d’abord au niveau académique (Auvergne-Rhône-Alpes), puis au niveau national.\n\n\n\n\nCritères d’évaluation\n\n\n\n\nVoici les critères d’évaluations définis dans le règlement du concours :\n\n\n\n\n\nPrésentation globale du projet\n\n\nDocumentation et lisibilité du projet\n\n\nPrésentation orale (vidéo)\n\n\nIllustration du projet (image 500px x 500px)\n\n\nEsprit logique de l’équipe\n\n\nOriginalité et créativité du projet et/ou du dossier\n\n\nOrganisation de l’équipe, du projet\n\n\nFonctionnement et opérationnalité du projet\n\n\nOuverture : idées d’amélioration, pistes de développement, analyse critique\n\n\n\n\n\nRécompenses\n\n\n\n\n\nPlusieurs prix sont décernés au niveau académique.\n\n\n\n\nAu niveau national, les récompenses suivantes sont annoncées :\n\n\n\n\n\nDeux prix sont obligatoirement remis :\n\n\nPrix du meilleur projet Première\n\n\nPrix du meilleur projet Terminale\n\n\n\n\nLes autres catégories :\n\n\nPrix spécial du jury (projet coup de cœur)\n\n\nPrix de la créativité (originalité et créativité)\n\n\nPrix des futurs ingénieurs et futures ingénieuses (dimension technique et scientifique forte)\n\n\nPrix de la mixité (part et rôle des filles dans l’équipe et/ou sujet traitant de cette thématique)\n\n\nPrix de la citoyenneté (projet inclut une dimension à impact social ou sociétal)\n\n\n\n\n\n\n\nExemples de projets réalisés pour la session 2022\n\n\n\n\nVous trouverez sur le site officiel les présentations des projets des lauréats de la session 2022.\n\n\n\n\n\nMeilleur projet Première : SnowFake, simulateur de croissance de flocons de neige\n\n\nMeilleur projet Terminale : Pytris, implémentation Python/Pygame du célèbre jeu TETRIS.\n\n\nPrix de la citoyenneté : EDUCOVOIT’, gestionnaire de covoiturage entre collègues\n\n\n\n\n\nEt beaucoup d’autres exemples : https://trophees-nsi.fr/resultats\n\n\n\n\nSource : le site officiel des trophées : https://trophees-nsi.fr/"
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "",
    "text": "Le sujet de mathématiques du baccalauréat 2025 pour la Métropole, Jour 1, est désormais disponible. Vous pouvez le télécharger en cliquant sur le lien ci-dessous :\nTélécharger le sujet de mathématiques - Bac 2025 Métropole Jour 1\n\n\nCet exercice aborde plusieurs notions du chapitre sur les probabilités à partir d’une situation basée sur les groupes sanguins.\n\nContenu de l’exercice : L’exercice débute par la construction d’un arbre pondéré et l’application de la formule des probabilités totales. La suite de l’exercice porte sur l’échantillonnage, la loi binomiale, son espérance, sa variance, et se termine par une application de l’inégalité de Bienaymé-Tchebychev.\n\n\n\n\n\nCet exercice est une étude de fonction composée d’un polynôme et d’un logarithme népérien. Il est structuré en trois parties.\n\nContenu de l’exercice :\n\nPartie A (Lecture graphique) : Interprétation graphique du nombre dérivé, du signe de la dérivée et du nombre de solutions d’une équation.\nPartie B (Étude analytique) : Calcul de limites, de dérivées première et seconde, étude de la convexité et de la position relative d’une courbe par rapport à sa tangente.\nPartie C (Calcul d’aire) : Calcul d’une intégrale à l’aide d’une intégration par parties.\n\n\n\n\n\n\nCet exercice est un “Vrai ou Faux” où chaque affirmation nécessite une justification mathématique.\n\nContenu de l’exercice : Les notions abordées sont les représentations paramétriques de droites, la colinéarité de vecteurs, le vecteur normal à un plan, la position relative de deux droites et le calcul de la distance d’un point à un plan.\n\n\n\n\n\nCet exercice de modélisation compare deux approches pour décrire l’évolution d’une population d’algues.\n\nContenu de l’exercice :\n\nPartie A (Modèle discret) : Étude d’une suite définie par récurrence (\\(u_{n+1} = h(u_n)\\)), incluant la démonstration de sa monotonie et de sa convergence par récurrence, la recherche de sa limite et la complétion d’un algorithme.\nPartie B (Modèle continu) : Résolution d’une équation différentielle non linéaire via un changement de variable.\n\n\nVoilà pour ce tour d’horizon ! Un sujet riche et bien équilibré."
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html#lénoncé",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html#lénoncé",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "",
    "text": "Le sujet de mathématiques du baccalauréat 2025 pour la Métropole, Jour 1, est désormais disponible. Vous pouvez le télécharger en cliquant sur le lien ci-dessous :\nTélécharger le sujet de mathématiques - Bac 2025 Métropole Jour 1\n\n\nCet exercice aborde plusieurs notions du chapitre sur les probabilités à partir d’une situation basée sur les groupes sanguins.\n\nContenu de l’exercice : L’exercice débute par la construction d’un arbre pondéré et l’application de la formule des probabilités totales. La suite de l’exercice porte sur l’échantillonnage, la loi binomiale, son espérance, sa variance, et se termine par une application de l’inégalité de Bienaymé-Tchebychev.\n\n\n\n\n\nCet exercice est une étude de fonction composée d’un polynôme et d’un logarithme népérien. Il est structuré en trois parties.\n\nContenu de l’exercice :\n\nPartie A (Lecture graphique) : Interprétation graphique du nombre dérivé, du signe de la dérivée et du nombre de solutions d’une équation.\nPartie B (Étude analytique) : Calcul de limites, de dérivées première et seconde, étude de la convexité et de la position relative d’une courbe par rapport à sa tangente.\nPartie C (Calcul d’aire) : Calcul d’une intégrale à l’aide d’une intégration par parties.\n\n\n\n\n\n\nCet exercice est un “Vrai ou Faux” où chaque affirmation nécessite une justification mathématique.\n\nContenu de l’exercice : Les notions abordées sont les représentations paramétriques de droites, la colinéarité de vecteurs, le vecteur normal à un plan, la position relative de deux droites et le calcul de la distance d’un point à un plan.\n\n\n\n\n\nCet exercice de modélisation compare deux approches pour décrire l’évolution d’une population d’algues.\n\nContenu de l’exercice :\n\nPartie A (Modèle discret) : Étude d’une suite définie par récurrence (\\(u_{n+1} = h(u_n)\\)), incluant la démonstration de sa monotonie et de sa convergence par récurrence, la recherche de sa limite et la complétion d’un algorithme.\nPartie B (Modèle continu) : Résolution d’une équation différentielle non linéaire via un changement de variable.\n\n\nVoilà pour ce tour d’horizon ! Un sujet riche et bien équilibré."
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html#le-corrigé",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html#le-corrigé",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "Le corrigé",
    "text": "Le corrigé\n\nExercice 1\nCet exercice porte sur les probabilités conditionnelles, la formule des probabilités totales, la loi binomiale et se termine par une application de l’inégalité de Bienaymé-Tchebychev.\n\n1. Arbre de probabilités\nPour compléter l’arbre, nous devons d’abord déterminer la probabilité de l’événement O. Les événements A, B, AB et O forment une partition de l’univers, c’est-à-dire que ce sont des événements incompatibles deux à deux et dont la réunion est l’univers. La somme de leurs probabilités est donc égale à 1.\n\\[ P(A) + P(B) + P(AB) + P(O) = 1 \\]\nOn en déduit \\(P(O)\\) : \\[ P(O) = 1 - P(A) - P(B) - P(AB) \\] \\[ P(O) = 1 - 0,45 - 0,10 - 0,03 = 0,42 \\]\nEnsuite, pour chaque branche, la somme des probabilités des événements conditionnels doit valoir 1. Par exemple, \\(P_A(R) + P_A(\\bar{R}) = 1\\).\nL’énoncé nous donne : * \\(P_A(R) = 0,85\\), donc \\(P_A(\\bar{R}) = 1 - 0,85 = 0,15\\). * \\(P_B(R) = 0,84\\), donc \\(P_B(\\bar{R}) = 1 - 0,84 = 0,16\\). * \\(P_{AB}(R) = 0,82\\), donc \\(P_{AB}(\\bar{R}) = 1 - 0,82 = 0,18\\).\nLa probabilité \\(P_O(R)\\) sera calculée à la question 3. Anticipons son résultat (\\(P_O(R) = 0,83\\)) pour compléter l’arbre. On a donc \\(P_O(\\bar{R}) = 1 - 0,83 = 0,17\\).\nL’arbre complété est le suivant :\n\nPremière branche (Groupe A) : \\(P(A) = 0,45\\)\n\n\\(P_A(R) = 0,85\\)\n\\(P_A(\\bar{R}) = 0,15\\)\n\nDeuxième branche (Groupe B) : \\(P(B) = 0,10\\)\n\n\\(P_B(R) = 0,84\\)\n\\(P_B(\\bar{R}) = 0,16\\)\n\nTroisième branche (Groupe AB) : \\(P(AB) = 0,03\\)\n\n\\(P_{AB}(R) = 0,82\\)\n\\(P_{AB}(\\bar{R}) = 0,18\\)\n\nQuatrième branche (Groupe O) : \\(P(O) = 0,42\\)\n\n\\(P_O(R) = 0,83\\)\n\\(P_O(\\bar{R}) = 0,17\\)\n\n\n\n\n2. Calcul de \\(P(B \\cap R)\\) et interprétation\n\n\n\n\n\n\nRappel de cours : Probabilité d’une intersection\n\n\n\nPour deux événements A et B, la probabilité de leur intersection est donnée par la formule : \\[ P(A \\cap B) = P(A) \\times P_A(B) \\] Cette formule se lit directement sur un arbre pondéré en multipliant les probabilités le long du chemin correspondant.\n\n\nEn appliquant cette formule, on a : \\[ P(B \\cap R) = P(B) \\times P_B(R) \\] \\[ P(B \\cap R) = 0,10 \\times 0,84 = 0,084 \\]\nInterprétation : La probabilité que la personne choisie au hasard dans la population française soit du groupe sanguin B et de rhésus positif est de 0,084 (soit 8,4 %).\n\n\n3. Calcul de \\(P_O(R)\\)\n\n\n\n\n\n\nRappel de cours : Formule des probabilités totales\n\n\n\nSi les événements \\(E_1, E_2, \\dots, E_n\\) forment une partition de l’univers, alors pour tout événement F, on a : \\[ P(F) = P(E_1 \\cap F) + P(E_2 \\cap F) + \\dots + P(E_n \\cap F) \\] \\[ P(F) = P(E_1)P_{E_1}(F) + P(E_2)P_{E_2}(F) + \\dots + P(E_n)P_{E_n}(F) \\]\n\n\nIci, les événements A, B, AB et O forment une partition de l’univers. On peut donc appliquer la formule des probabilités totales pour calculer \\(P(R)\\) : \\[ P(R) = P(A \\cap R) + P(B \\cap R) + P(AB \\cap R) + P(O \\cap R) \\] \\[ P(R) = P(A)P_A(R) + P(B)P_B(R) + P(AB)P_{AB}(R) + P(O)P_O(R) \\]\nL’énoncé nous donne \\(P(R)=0,8397\\). On peut donc isoler l’inconnue \\(P_O(R)\\) : \\[ 0,8397 = (0,45 \\times 0,85) + (0,10 \\times 0,84) + (0,03 \\times 0,82) + (0,42 \\times P_O(R)) \\] \\[ 0,8397 = 0,3825 + 0,084 + 0,0246 + 0,42 \\times P_O(R) \\] \\[ 0,8397 = 0,4911 + 0,42 \\times P_O(R) \\] \\[ 0,42 \\times P_O(R) = 0,8397 - 0,4911 \\] \\[ 0,42 \\times P_O(R) = 0,3486 \\] \\[ P_O(R) = \\frac{0,3486}{0,42} = 0,83 \\] On a bien montré que \\(P_O(R) = 0,83\\).\n\n\n4. Probabilité d’être donneur universel\nUn “donneur universel” est un individu du groupe O et de rhésus négatif. On cherche donc à calculer la probabilité de l’événement \\(O \\cap \\bar{R}\\). En utilisant la règle de l’intersection : \\[ P(O \\cap \\bar{R}) = P(O) \\times P_O(\\bar{R}) \\] Nous savons que \\(P(O) = 0,42\\). De plus, comme \\(P_O(R) = 0,83\\), on en déduit : \\[ P_O(\\bar{R}) = 1 - P_O(R) = 1 - 0,83 = 0,17 \\] Donc : \\[ P(O \\cap \\bar{R}) = 0,42 \\times 0,17 = 0,0714 \\] La probabilité qu’un individu choisi au hasard soit donneur universel est bien de 0,0714.\n\n\n\n5. Étude d’un échantillon de 100 personnes\na. Justification de la loi binomiale\n\n\n\n\n\n\nRappel de cours : Loi binomiale\n\n\n\nUne variable aléatoire \\(X\\) suit une loi binomiale \\(\\mathcal{B}(n, p)\\) si elle compte le nombre de succès dans une série de \\(n\\) épreuves de Bernoulli identiques et indépendantes, où \\(p\\) est la probabilité de succès à chaque épreuve.\n\n\nConsidérons l’épreuve de Bernoulli suivante : “on choisit une personne au hasard dans la population et on regarde si elle est donneur universel”. * Le succès est l’événement “la personne est un donneur universel”. La probabilité de succès est \\(p = P(O \\cap \\bar{R}) = 0,0714\\) (calculée en 4.). * L’échec est l’événement contraire, de probabilité \\(1-p\\).\nOn répète cette épreuve \\(n=100\\) fois. L’énoncé précise que “la population est suffisamment grande pour assimiler ce choix à un tirage avec remise”. Cette condition garantit que les tirages sont identiques et indépendants.\nLa variable aléatoire \\(X\\), qui compte le nombre de donneurs universels (nombre de succès) dans l’échantillon de 100 personnes, suit donc une loi binomiale de paramètres \\(n=100\\) et \\(p=0,0714\\). On note \\(X \\sim \\mathcal{B}(100; 0,0714)\\).\nb. Probabilité d’avoir au plus 7 donneurs universels\nOn cherche à calculer \\(P(X \\le 7)\\). \\[ P(X \\le 7) = \\sum_{k=0}^{7} P(X=k) = \\sum_{k=0}^{7} \\binom{100}{k} (0,0714)^k (1-0,0714)^{100-k} \\] À l’aide de la fonction de répartition de la loi binomiale de la calculatrice (binomFRep ou BinomialCD), on obtient : \\[ P(X \\le 7) \\approx 0,5735 \\] Arrondie à \\(10^{-3}\\) près, la probabilité est de 0,574.\nc. Espérance et variance de X\n\n\n\n\n\n\nFormules : Espérance et Variance de la loi binomiale\n\n\n\nSi \\(X \\sim \\mathcal{B}(n, p)\\), alors : * Espérance : \\(E(X) = n \\times p\\) * Variance : \\(V(X) = n \\times p \\times (1-p)\\)\n\n\nAppliquons ces formules :\n\nEspérance : \\[ E(X) = 100 \\times 0,0714 = 7,14 \\]\nVariance : \\[ V(X) = 100 \\times 0,0714 \\times (1 - 0,0714) = 7,14 \\times 0,9286 = 6,630444 \\] Arrondie à \\(10^{-2}\\) près, la variance est bien \\(V(X) \\approx 6,63\\).\n\n\n\n6. Étude sur N villes\na. Représentation de la variable aléatoire \\(M_N\\)\n\\(X_i\\) est le nombre de donneurs universels dans un échantillon de 100 personnes de la ville \\(i\\). La variable aléatoire \\(M_N = \\frac{X_1 + X_2 + \\dots + X_N}{N}\\) est la moyenne arithmétique des nombres de donneurs universels observés dans les échantillons des \\(N\\) villes. Elle représente donc le nombre moyen de donneurs universels par échantillon de 100 personnes sur l’ensemble des \\(N\\) collectes.\nb. Espérance de \\(M_N\\)\nPar linéarité de l’espérance, on a : \\[ E(M_N) = E\\left(\\frac{1}{N}\\sum_{i=1}^{N} X_i\\right) = \\frac{1}{N} \\sum_{i=1}^{N} E(X_i) \\] On nous dit que pour tout \\(i\\), \\(E(X_i) = 7,14\\). Donc : \\[ E(M_N) = \\frac{1}{N} \\sum_{i=1}^{N} 7,14 = \\frac{1}{N} \\times (N \\times 7,14) = 7,14 \\] L’espérance de la moyenne est égale à l’espérance de la variable de départ.\nc. Variance de \\(M_N\\)\nLes variables \\(X_i\\) sont supposées indépendantes. Pour la variance, on a \\(V(aY) = a^2 V(Y)\\) et la variance d’une somme de variables indépendantes est la somme de leurs variances. \\[ V(M_N) = V\\left(\\frac{1}{N}\\sum_{i=1}^{N} X_i\\right) = \\left(\\frac{1}{N}\\right)^2 V\\left(\\sum_{i=1}^{N} X_i\\right) \\] \\[ V(M_N) = \\frac{1}{N^2} \\sum_{i=1}^{N} V(X_i) \\quad \\text{(car les } X_i \\text{ sont indépendantes)} \\] On nous dit que pour tout \\(i\\), \\(V(X_i) = 6,63\\). Donc : \\[ V(M_N) = \\frac{1}{N^2} \\sum_{i=1}^{N} 6,63 = \\frac{1}{N^2} \\times (N \\times 6,63) = \\frac{6,63}{N} \\]\nd. Inégalité de Bienaymé-Tchebychev\n\n\n\n\n\n\nRappel de cours : Inégalité de Bienaymé-Tchebychev\n\n\n\nPour une variable aléatoire \\(Y\\) d’espérance \\(E(Y)\\) et de variance \\(V(Y)\\), et pour tout réel \\(\\epsilon &gt; 0\\), on a : \\[ P(|Y - E(Y)| \\ge \\epsilon) \\le \\frac{V(Y)}{\\epsilon^2} \\] Ou, sous sa forme complémentaire souvent plus utile : \\[ P(|Y - E(Y)| &lt; \\epsilon) \\ge 1 - \\frac{V(Y)}{\\epsilon^2} \\] Cette inégalité donne une borne inférieure pour la probabilité que la variable aléatoire se trouve dans un intervalle centré sur son espérance.\n\n\nOn cherche la plus petite valeur de \\(N\\) telle que \\(P(7 &lt; M_N &lt; 7,28) \\ge 0,95\\). L’espérance de \\(M_N\\) est \\(E(M_N) = 7,14\\). Réécrivons l’inégalité autour de cette espérance : \\[ 7 &lt; M_N &lt; 7,28 \\iff 7,14 - 0,14 &lt; M_N &lt; 7,14 + 0,14 \\] Ceci est équivalent à : \\[ |M_N - 7,14| &lt; 0,14 \\quad \\text{ou} \\quad |M_N - E(M_N)| &lt; 0,14 \\] On peut donc appliquer l’inégalité de Bienaymé-Tchebychev avec \\(Y=M_N\\) et \\(\\epsilon = 0,14\\). \\[ P(|M_N - E(M_N)| &lt; 0,14) \\ge 1 - \\frac{V(M_N)}{0,14^2} \\] On sait que \\(V(M_N) = \\frac{6,63}{N}\\). Donc : \\[ P(7 &lt; M_N &lt; 7,28) \\ge 1 - \\frac{6,63/N}{0,14^2} = 1 - \\frac{6,63}{N \\times 0,0196} \\] Pour que la condition \\(P(7 &lt; M_N &lt; 7,28) \\ge 0,95\\) soit vérifiée, il suffit que la borne inférieure que nous avons trouvée soit supérieure ou égale à 0,95. On cherche donc \\(N\\) tel que : \\[ 1 - \\frac{6,63}{0,0196 \\times N} \\ge 0,95 \\] \\[ 0,05 \\ge \\frac{6,63}{0,0196 \\times N} \\] Comme \\(N\\) est un entier positif, on peut multiplier les deux côtés par \\(0,0196 \\times N\\) sans changer le sens de l’inégalité : \\[ 0,05 \\times 0,0196 \\times N \\ge 6,63 \\] \\[ 0,00098 \\times N \\ge 6,63 \\] \\[ N \\ge \\frac{6,63}{0,00098} \\] \\[ N \\ge 6765,306... \\] Puisque \\(N\\) doit être un entier, la plus petite valeur de \\(N\\) qui satisfait cette condition est \\(N = 6766\\).\nLa plus petite valeur de \\(N\\) est 6766."
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-1",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-1",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "Corrigé de l’exercice 1",
    "text": "Corrigé de l’exercice 1\nCet exercice porte sur les probabilités conditionnelles, la formule des probabilités totales, la loi binomiale et se termine par une application de l’inégalité de Bienaymé-Tchebychev.\n\n1. Arbre de probabilités\nPour compléter l’arbre, nous devons d’abord déterminer la probabilité de l’événement O. Les événements A, B, AB et O forment une partition de l’univers, c’est-à-dire que ce sont des événements incompatibles deux à deux et dont la réunion est l’univers. La somme de leurs probabilités est donc égale à 1.\n\\[ P(A) + P(B) + P(AB) + P(O) = 1 \\]\nOn en déduit \\(P(O)\\) : \\[ P(O) = 1 - P(A) - P(B) - P(AB) \\] \\[ P(O) = 1 - 0,45 - 0,10 - 0,03 = 0,42 \\]\nEnsuite, pour chaque branche, la somme des probabilités des événements conditionnels doit valoir 1. Par exemple, \\(P_A(R) + P_A(\\overline{R}) = 1\\).\nL’énoncé nous donne :\n\n\\(P_A(R) = 0,85\\), donc \\(P_A(\\overline{R}) = 1 - 0,85 = 0,15\\).\n\\(P_B(R) = 0,84\\), donc \\(P_B(\\overline{R}) = 1 - 0,84 = 0,16\\).\n\\(P_{AB}(R) = 0,82\\), donc \\(P_{AB}(\\overline{R}) = 1 - 0,82 = 0,18\\).\n\nLa probabilité \\(P_O(R)\\) sera calculée à la question 3.\nL’arbre complété est le suivant :\n\n\n\n2. Calcul de \\(P(B \\cap R)\\) et interprétation\n\n\n\n\n\n\nRappel de cours : Probabilité d’une intersection\n\n\n\nPour deux événements A et B, la probabilité de leur intersection est donnée par la formule : \\[ P(A \\cap B) = P(A) \\times P_A(B) \\] Cette formule se lit directement sur un arbre pondéré en multipliant les probabilités le long du chemin correspondant.\n\n\nEn appliquant cette formule, on a : \\[ P(B \\cap R) = P(B) \\times P_B(R) \\] \\[ P(B \\cap R) = 0,10 \\times 0,84 = 0,084 \\]\nInterprétation : La probabilité que la personne choisie au hasard dans la population française soit du groupe sanguin B et de rhésus positif est de 0,084 (soit 8,4 %).\n\n\n3. Calcul de \\(P_O(R)\\)\n\n\n\n\n\n\nRappel de cours : Formule des probabilités totales\n\n\n\nSi les événements \\(E_1, E_2, \\dots, E_n\\) forment une partition de l’univers, alors pour tout événement F, on a : \\[ P(F) = P(E_1 \\cap F) + P(E_2 \\cap F) + \\dots + P(E_n \\cap F) \\] \\[ P(F) = P(E_1)P_{E_1}(F) + P(E_2)P_{E_2}(F) + \\dots + P(E_n)P_{E_n}(F) \\]\n\n\nIci, les événements A, B, AB et O forment une partition de l’univers. On peut donc appliquer la formule des probabilités totales pour calculer \\(P(R)\\) : \\[ P(R) = P(A \\cap R) + P(B \\cap R) + P(AB \\cap R) + P(O \\cap R) \\] \\[ P(R) = P(A)P_A(R) + P(B)P_B(R) + P(AB)P_{AB}(R) + P(O)P_O(R) \\]\nL’énoncé nous donne \\(P(R)=0,8397\\). On peut donc isoler l’inconnue \\(P_O(R)\\) : \\[ 0,8397 = (0,45 \\times 0,85) + (0,10 \\times 0,84) + (0,03 \\times 0,82) + (0,42 \\times P_O(R)) \\] \\[ 0,8397 = 0,3825 + 0,084 + 0,0246 + 0,42 \\times P_O(R) \\] \\[ 0,8397 = 0,4911 + 0,42 \\times P_O(R) \\] \\[ 0,42 \\times P_O(R) = 0,8397 - 0,4911 \\] \\[ 0,42 \\times P_O(R) = 0,3486 \\] \\[ P_O(R) = \\frac{0,3486}{0,42} = 0,83 \\] On a bien montré que \\(P_O(R) = 0,83\\).\n\n\n4. Probabilité d’être donneur universel\nUn “donneur universel” est un individu du groupe O et de rhésus négatif. On cherche donc à calculer la probabilité de l’événement \\(O \\cap \\overline{R}\\). En utilisant la règle de l’intersection : \\[ P(O \\cap \\overline{R}) = P(O) \\times P_O(\\overline{R}) \\] Nous savons que \\(P(O) = 0,42\\). De plus, comme \\(P_O(R) = 0,83\\), on en déduit : \\[ P_O(\\overline{R}) = 1 - P_O(R) = 1 - 0,83 = 0,17 \\] Donc : \\[ P(O \\cap \\overline{R}) = 0,42 \\times 0,17 = 0,0714 \\] La probabilité qu’un individu choisi au hasard soit donneur universel est bien de 0,0714.\n\n\n\n5. Étude d’un échantillon de 100 personnes\na. Justification de la loi binomiale\n\n\n\n\n\n\nRappel de cours : Loi binomiale\n\n\n\nUne variable aléatoire \\(X\\) suit une loi binomiale \\(\\mathcal{B}(n, p)\\) si elle compte le nombre de succès dans une série de \\(n\\) épreuves de Bernoulli identiques et indépendantes, où \\(p\\) est la probabilité de succès à chaque épreuve.\n\n\nConsidérons l’épreuve de Bernoulli suivante : “on choisit une personne au hasard dans la population et on regarde si elle est donneur universel”.\n\nLe succès est l’événement “la personne est un donneur universel”. La probabilité de succès est \\(p = P(O \\cap \\overline{R}) = 0,0714\\) (calculée en 4.).\nL’échec est l’événement contraire, de probabilité \\(1-p\\).\n\nOn répète cette épreuve \\(n=100\\) fois. L’énoncé précise que “la population est suffisamment grande pour assimiler ce choix à un tirage avec remise”. Cette condition garantit que les tirages sont identiques et indépendants.\nLa variable aléatoire \\(X\\), qui compte le nombre de donneurs universels (nombre de succès) dans l’échantillon de 100 personnes, suit donc une loi binomiale de paramètres \\(n=100\\) et \\(p=0,0714\\). On note \\(X \\sim \\mathcal{B}(100; 0,0714)\\).\nb. Probabilité d’avoir au plus 7 donneurs universels\nOn cherche à calculer \\(P(X \\leqslant 7)\\). \\[ P(X \\leqslant 7) = \\sum_{k=0}^{7} P(X=k) = \\sum_{k=0}^{7} \\binom{100}{k} (0,0714)^k (1-0,0714)^{100-k} \\] À l’aide de la fonction de répartition de la loi binomiale de la calculatrice (binomFRep ou BinomialCD), on obtient : \\[ P(X \\leqslant 7) \\approx 0,5735 \\] Arrondie à \\(10^{-3}\\) près, la probabilité est de 0,574.\nc. Espérance et variance de X\n\n\n\n\n\n\nFormules : Espérance et Variance de la loi binomiale\n\n\n\nSi \\(X \\sim \\mathcal{B}(n, p)\\), alors : * Espérance : \\(E(X) = n \\times p\\) * Variance : \\(V(X) = n \\times p \\times (1-p)\\)\n\n\nAppliquons ces formules :\n\nEspérance : \\[ E(X) = 100 \\times 0,0714 = 7,14 \\]\nVariance : \\[ V(X) = 100 \\times 0,0714 \\times (1 - 0,0714) = 7,14 \\times 0,9286 = 6,630444 \\] Arrondie à \\(10^{-2}\\) près, la variance est bien \\(V(X) \\approx 6,63\\).\n\n\n\n6. Étude sur N villes\na. Représentation de la variable aléatoire \\(M_N\\)\n\\(X_i\\) est le nombre de donneurs universels dans un échantillon de 100 personnes de la ville \\(i\\). La variable aléatoire \\(M_N = \\frac{X_1 + X_2 + \\dots + X_N}{N}\\) est la moyenne arithmétique des nombres de donneurs universels observés dans les échantillons des \\(N\\) villes. Elle représente donc le nombre moyen de donneurs universels par échantillon de 100 personnes sur l’ensemble des \\(N\\) collectes.\nb. Espérance de \\(M_N\\)\nPar linéarité de l’espérance, on a : \\[ E(M_N) = E\\left(\\frac{1}{N}\\sum_{i=1}^{N} X_i\\right) = \\frac{1}{N} \\sum_{i=1}^{N} E(X_i) \\] On nous dit que pour tout \\(i\\), \\(E(X_i) = 7,14\\). Donc : \\[ E(M_N) = \\frac{1}{N} \\sum_{i=1}^{N} 7,14 = \\frac{1}{N} \\times (N \\times 7,14) = 7,14 \\] L’espérance de la moyenne est égale à l’espérance de la variable de départ.\nc. Variance de \\(M_N\\)\nLes variables \\(X_i\\) sont supposées indépendantes. Pour la variance, on a \\(V(aY) = a^2 V(Y)\\) et la variance d’une somme de variables indépendantes est la somme de leurs variances. \\[ V(M_N) = V\\left(\\frac{1}{N}\\sum_{i=1}^{N} X_i\\right) = \\left(\\frac{1}{N}\\right)^2 V\\left(\\sum_{i=1}^{N} X_i\\right) \\] \\[ V(M_N) = \\frac{1}{N^2} \\sum_{i=1}^{N} V(X_i) \\quad \\text{(car les } X_i \\text{ sont indépendantes)} \\] On nous dit que pour tout \\(i\\), \\(V(X_i) = 6,63\\). Donc : \\[ V(M_N) = \\frac{1}{N^2} \\sum_{i=1}^{N} 6,63 = \\frac{1}{N^2} \\times (N \\times 6,63) = \\frac{6,63}{N} \\]\nd. Inégalité de Bienaymé-Tchebychev\n\n\n\n\n\n\nRappel de cours : Inégalité de Bienaymé-Tchebychev\n\n\n\nPour une variable aléatoire \\(Y\\) d’espérance \\(E(Y)\\) et de variance \\(V(Y)\\), et pour tout réel \\(\\epsilon &gt; 0\\), on a : \\[ P(|Y - E(Y)| \\geqslant \\epsilon) \\leqslant \\frac{V(Y)}{\\epsilon^2} \\] Ou, sous sa forme complémentaire souvent plus utile : \\[ P(|Y - E(Y)| &lt; \\epsilon) \\geqslant 1 - \\frac{V(Y)}{\\epsilon^2} \\] Cette inégalité donne une borne inférieure pour la probabilité que la variable aléatoire se trouve dans un intervalle centré sur son espérance.\n\n\nOn cherche la plus petite valeur de \\(N\\) telle que \\(P(7 &lt; M_N &lt; 7,28) \\geqslant 0,95\\). L’espérance de \\(M_N\\) est \\(E(M_N) = 7,14\\). Réécrivons l’inégalité autour de cette espérance : \\[ 7 &lt; M_N &lt; 7,28 \\iff 7,14 - 0,14 &lt; M_N &lt; 7,14 + 0,14 \\] Ceci est équivalent à : \\[ |M_N - 7,14| &lt; 0,14 \\quad \\text{ou} \\quad |M_N - E(M_N)| &lt; 0,14 \\] On peut donc appliquer l’inégalité de Bienaymé-Tchebychev avec \\(Y=M_N\\) et \\(\\epsilon = 0,14\\). \\[ P(|M_N - E(M_N)| &lt; 0,14) \\geqslant 1 - \\frac{V(M_N)}{0,14^2} \\] On sait que \\(V(M_N) = \\frac{6,63}{N}\\). Donc : \\[ P(7 &lt; M_N &lt; 7,28) \\geqslant 1 - \\frac{6,63/N}{0,14^2} = 1 - \\frac{6,63}{N \\times 0,0196} \\] Pour que la condition \\(P(7 &lt; M_N &lt; 7,28) \\geqslant 0,95\\) soit vérifiée, il suffit que la borne inférieure que nous avons trouvée soit supérieure ou égale à 0,95. On cherche donc \\(N\\) tel que : \\[ 1 - \\frac{6,63}{0,0196 \\times N} \\geqslant 0,95 \\] \\[ 0,05 \\geqslant \\frac{6,63}{0,0196 \\times N} \\] Comme \\(N\\) est un entier positif, on peut multiplier les deux côtés par \\(0,0196 \\times N\\) sans changer le sens de l’inégalité : \\[ 0,05 \\times 0,0196 \\times N \\geqslant 6,63 \\] \\[ 0,00098 \\times N \\geqslant 6,63 \\] \\[ N \\geqslant \\frac{6,63}{0,00098} \\] \\[ N \\geqslant 6765,306... \\] Puisque \\(N\\) doit être un entier, la plus petite valeur de \\(N\\) qui satisfait cette condition est \\(N = 6766\\).\nLa plus petite valeur de \\(N\\) est 6766."
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-2",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-2",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "Corrigé de l’exercice 2",
    "text": "Corrigé de l’exercice 2\n\nPartie A : Lectures graphiques\nOn répond aux questions en s’appuyant sur les informations visuelles fournies par le graphique.\n1. Déterminer le nombre dérivé \\(f'(1)\\).\n\n\n\n\n\n\nRappel de cours : Interprétation graphique du nombre dérivé\n\n\n\nLe nombre dérivé \\(f'(a)\\) d’une fonction \\(f\\) en un point d’abscisse \\(a\\) est égal au coefficient directeur (la pente) de la tangente à la courbe de \\(f\\) en ce point.\n\n\nLe nombre \\(f'(1)\\) est le coefficient directeur de la tangente \\(T_A\\) à la courbe \\(C_f\\) au point \\(A(1; 2)\\). Pour calculer ce coefficient directeur, on utilise les coordonnées de deux points par lesquels passe la droite \\(T_A\\). Le graphique nous indique que \\(T_A\\) passe par les points \\(A(1; 2)\\) et \\(C(3; 0)\\). Le coefficient directeur est donc : \\[ m = \\frac{y_C - y_A}{x_C - x_A} = \\frac{0 - 2}{3 - 1} = \\frac{-2}{2} = -1 \\]\nAinsi, \\(f'(1) = -1\\).\n2. Combien de solutions l’équation \\(f'(x) = 0\\) admet-elle dans l’intervalle \\(]0; 3]\\) ?\nL’équation \\(f'(x) = 0\\) a pour solutions les abscisses des points de la courbe \\(C_f\\) où la tangente est horizontale.\nEn observant le graphique sur l’intervalle \\(]0; 3]\\), on voit que la fonction \\(f\\) est d’abord croissante, puis décroissante. Elle admet donc un maximum local entre \\(x=0,2\\) et \\(x=1\\). En ce point, la tangente à la courbe \\(C_f\\) est horizontale.\nDe plus, la fonction est à nouveau croissante ensuite. Elle admet donc un minimum local entre \\(x=1\\) et \\(x=e\\). En ce point, la tangente est également horizontale.\nL’équation \\(f'(x) = 0\\) admet donc deux solutions dans l’intervalle \\(]0; 3]\\).\n3. Quel est le signe de \\(f''(0,2)\\) ?\n\n\n\n\n\n\nRappel de cours : Lien entre signe de \\(f''\\) et convexité\n\n\n\n\nSi \\(f''(x) &gt; 0\\), la fonction \\(f\\) est convexe en \\(x\\).\nSi \\(f''(x) &lt; 0\\), la fonction \\(f\\) est concave en \\(x\\).\nSi \\(f''\\) s’annule en \\(x\\) en changeant de signe, il y a un point d’inflexion en \\(x\\).\n\n\n\nSur le graphique, pour \\(x=0,2\\), on observe que la courbe \\(C_f\\) est concave.\nDonc, le signe de la dérivée seconde \\(f''(0,2)\\) est négatif.\n\n\n\nPartie B : Étude de la fonction f\nOn admet que \\(f(x) = x(2(\\ln x)^2 - 3 \\ln x + 2)\\).\n1. Résoudre l’équation \\(2X^2 - 3X + 2 = 0\\) et en déduire que \\(C_f\\) ne coupe pas l’axe des abscisses.\nPour résoudre l’équation du second degré \\(2X^2 - 3X + 2 = 0\\), on calcule le discriminant \\(\\Delta\\). \\[ \\Delta = b^2 - 4ac = (-3)^2 - 4(2)(2) = 9 - 16 = -7 \\]\nComme \\(\\Delta &lt; 0\\), l’équation n’a pas de solution réelle. Le polynôme \\(P(X) = 2X^2 - 3X + 2\\) est donc de signe constant. Son signe est celui de son coefficient dominant \\(a=2\\), qui est positif.\nAinsi, pour tout réel \\(X\\), \\(2X^2 - 3X + 2 &gt; 0\\).\nPour déduire que \\(C_f\\) ne coupe pas l’axe des abscisses, on étudie le signe de \\(f(x)\\). \\[ f(x) = x(2(\\ln x)^2 - 3 \\ln x + 2) \\]\nLa fonction est définie sur \\(]0; +\\infty[\\), donc \\(x &gt; 0\\).\nLe second facteur, \\(2(\\ln x)^2 - 3 \\ln x + 2\\), peut s’écrire \\(P(\\ln x)\\). Comme nous avons montré que \\(P(X) &gt; 0\\) pour tout \\(X\\), on a \\(2(\\ln x)^2 - 3 \\ln x + 2 &gt; 0\\) pour tout \\(x \\in ]0; +\\infty[\\).\n\\(f(x)\\) est le produit de deux termes strictement positifs, donc \\(f(x) &gt; 0\\) pour tout \\(x \\in ]0; +\\infty[\\).\nPuisque \\(f(x)\\) ne s’annule jamais et est toujours positive, la courbe \\(C_f\\) ne coupe pas l’axe des abscisses.\n2. Déterminer la limite de \\(f\\) en \\(+\\infty\\).\nOn cherche \\(\\lim_{x \\to +\\infty} x(2(\\ln x)^2 - 3 \\ln x + 2)\\).\nOn a :\n\n\\(\\lim_{x \\to +\\infty} x = +\\infty\\)\nPour le second facteur, on pose \\(X = \\ln x\\). Quand \\(x \\to +\\infty\\), \\(X \\to +\\infty\\).\n\\(\\lim_{x \\to +\\infty} (2(\\ln x)^2 - 3 \\ln x + 2) = \\lim_{X \\to +\\infty} (2X^2 - 3X + 2)\\).\nLa limite d’un polynôme en l’infini est celle de son terme de plus haut degré.\n\\(\\lim_{X \\to +\\infty} (2X^2) = +\\infty\\).\n\nPar produit des limites, on obtient : \\[ \\lim_{x \\to +\\infty} f(x) = (+\\infty) \\times (+\\infty) = +\\infty \\]\n3. On admet que \\(f'(x) = 2(\\ln x)^2 + \\ln x - 1\\).\na. Montrer que \\(f''(x) = \\frac{1}{x}(4 \\ln x + 1)\\).\nPour trouver \\(f''(x)\\), on dérive \\(f'(x)\\).\nEn utilisant la dérivée de \\(u^2\\) qui est \\(2uu'\\) et la dérivée de \\(\\ln x\\) qui est \\(1/x\\) : \\[ f''(x) = 2 \\times (2(\\ln x) \\times \\frac{1}{x}) + \\frac{1}{x} - 0 \\] \\[ f''(x) = \\frac{4 \\ln x}{x} + \\frac{1}{x} = \\frac{4 \\ln x + 1}{x} \\]\nCe qui est bien l’expression attendue.\nb. Étudier la convexité de \\(f\\) et préciser l’abscisse du point d’inflexion.\nOn étudie le signe de \\(f''(x) = \\frac{4 \\ln x + 1}{x}\\) sur \\(]0; +\\infty[\\).\nSur cet intervalle, le dénominateur \\(x\\) est toujours positif. Le signe de \\(f''(x)\\) est donc le même que celui de son numérateur \\(4 \\ln x + 1\\).\n\n\\(4 \\ln x + 1 = 0 \\iff \\ln x = -\\frac{1}{4} \\iff x = e^{-1/4}\\)\n\\(4 \\ln x + 1 &gt; 0 \\iff \\ln x &gt; -\\frac{1}{4} \\iff x &gt; e^{-1/4}\\)\n\nOn peut dresser un tableau de signes :\n\n\n\n\\(x\\)\n\\(0\\)\n\n\\(e^{-1/4}\\)\n\n\\(+\\infty\\)\n\n\n\n\nSigne de \\(f''(x)\\)\n\n\\(-\\)\n\\(0\\)\n\\(+\\)\n\n\n\nConvexité de \\(f\\)\n\nConcave\nPoint d’inflexion\nConvexe\n\n\n\n\n\nLa fonction \\(f\\) est concave sur \\(]0, e^{-1/4}]\\).\nLa fonction \\(f\\) est convexe sur \\([e^{-1/4}, +\\infty[\\).\nLa dérivée seconde s’annule et change de signe en \\(x = e^{-1/4}\\). La courbe \\(C_f\\) admet donc un point d’inflexion d’abscisse \\(e^{-1/4}\\).\n\nc. Montrer que \\(C_f\\) est au-dessus de \\(T_B\\) sur \\([1; +\\infty[\\).\nUne propriété des fonctions convexes est que leur courbe représentative est située au-dessus de chacune de leurs tangentes.\nD’après la question précédente, la fonction \\(f\\) est convexe sur l’intervalle \\([e^{-1/4}, +\\infty[\\).\nOn a \\(e \\approx 2,718\\), donc \\(e^{-1/4} &lt; 1\\).\nL’intervalle \\([1, +\\infty[\\) est donc inclus dans l’intervalle de convexité \\([e^{-1/4}, +\\infty[\\).\nPuisque \\(f\\) est convexe sur \\([1, +\\infty[\\), sa courbe \\(C_f\\) est au-dessus de toutes ses tangentes sur cet intervalle. La droite \\(T_B\\) est la tangente au point d’abscisse \\(e\\), et \\(e \\in [1, +\\infty[\\).\nPar conséquent, la courbe \\(C_f\\) est au-dessus de la tangente \\(T_B\\) sur l’intervalle \\([1; +\\infty[\\).\n\n\n\nPartie C : Calcul d’aire\n1. Justifier que la tangente \\(T_B\\) a pour équation réduite \\(y = 2x - e\\).\nL’équation de la tangente à \\(C_f\\) au point d’abscisse \\(a\\) est \\(y = f'(a)(x-a) + f(a)\\).\nIci, le point est \\(B(e; e)\\), donc \\(a=e\\).\n\nCalculons \\(f(e)\\): \\(f(e) = e(2(\\ln e)^2 - 3 \\ln e + 2) = e(2(1)^2 - 3(1) + 2) = e(2-3+2) = e\\).\nCalculons \\(f'(e)\\): \\(f'(e) = 2(\\ln e)^2 + \\ln e - 1 = 2(1)^2 + 1 - 1 = 2\\).\n\nL’équation de la tangente \\(T_B\\) est donc : \\[ y = 2(x - e) + e \\]\n\\[ y = 2x - 2e + e \\]\n\\[ y = 2x - e \\] Ceci justifie l’équation donnée.\n2. Montrer que \\(\\int_1^e x \\ln x \\, dx = \\frac{e^2+1}{4}\\).\n\n\n\n\n\n\nFormule : Intégration par parties\n\n\n\nSoient \\(u\\) et \\(v\\) deux fonctions dérivables et de dérivée continue sur un intervalle \\([a, b]\\).\n\\[ \\int_a^b u(x)v'(x) \\, dx = [u(x)v(x)]_a^b - \\int_a^b u'(x)v(x) \\, dx \\]\n\n\nOn pose :\n\n\\(u(x) = \\ln x \\implies u'(x) = \\frac{1}{x}\\)\n\\(v'(x) = x \\implies v(x) = \\frac{x^2}{2}\\)\n\nLes fonctions \\(u\\) et \\(v\\) sont bien dérivables sur \\([1, e]\\). En appliquant la formule :\n\\[ \\int_1^e x \\ln x \\, dx = \\left[ (\\ln x) \\frac{x^2}{2} \\right]_1^e - \\int_1^e \\frac{1}{x} \\frac{x^2}{2} \\, dx \\]\n\\[ = \\left( (\\ln e) \\frac{e^2}{2} - (\\ln 1) \\frac{1^2}{2} \\right) - \\int_1^e \\frac{x}{2} \\, dx \\]\n\\[ = \\left( 1 \\times \\frac{e^2}{2} - 0 \\times \\frac{1}{2} \\right) - \\left[ \\frac{1}{2} \\frac{x^2}{2} \\right]_1^e \\]\n\\[ = \\frac{e^2}{2} - \\left[ \\frac{x^2}{4} \\right]_1^e \\]\n\\[ = \\frac{e^2}{2} - \\left( \\frac{e^2}{4} - \\frac{1^2}{4} \\right) \\]\n\\[ = \\frac{e^2}{2} - \\frac{e^2}{4} + \\frac{1}{4} = \\frac{2e^2 - e^2 + 1}{4} = \\frac{e^2+1}{4} \\]\n3. En déduire la valeur exacte de \\(\\mathcal{A}\\) en unité d’aire.\nL’aire \\(\\mathcal{A}\\) est celle du domaine délimité par \\(C_f\\), \\(T_B\\), et les droites \\(x=1\\) et \\(x=e\\).\nComme \\(C_f\\) est au-dessus de \\(T_B\\) sur \\([1, e]\\), l’aire est donnée par l’intégrale :\n\\[ \\mathcal{A} = \\int_1^e (f(x) - y_{T_B}) \\, dx = \\int_1^e (f(x) - (2x-e)) \\, dx \\]\n\\[ \\mathcal{A} = \\int_1^e (x(2(\\ln x)^2 - 3\\ln x + 2) - 2x + e) \\, dx \\]\n\\[ \\mathcal{A} = \\int_1^e (2x(\\ln x)^2 - 3x\\ln x + 2x - 2x + e) \\, dx \\]\n\\[ \\mathcal{A} = \\int_1^e (2x(\\ln x)^2 - 3x\\ln x + e) \\, dx \\]\nPar linéarité de l’intégrale :\n\\[ \\mathcal{A} = 2 \\int_1^e x(\\ln x)^2 \\, dx - 3 \\int_1^e x\\ln x \\, dx + \\int_1^e e \\, dx \\]\nOn utilise les résultats admis et calculés :\n\n\\(\\int_1^e x(\\ln x)^2 \\, dx = \\frac{e^2-1}{4}\\) (admis)\n\\(\\int_1^e x\\ln x \\, dx = \\frac{e^2+1}{4}\\) (calculé en C.2)\n\\(\\int_1^e e \\, dx = [ex]_1^e = e \\times e - e \\times 1 = e^2 - e\\)\n\nOn remplace :\n\\[ \\mathcal{A} = 2 \\left( \\frac{e^2-1}{4} \\right) - 3 \\left( \\frac{e^2+1}{4} \\right) + (e^2 - e) \\]\n\\[ \\mathcal{A} = \\frac{2e^2 - 2}{4} - \\frac{3e^2 + 3}{4} + \\frac{4(e^2 - e)}{4} \\]\n\\[ \\mathcal{A} = \\frac{(2e^2 - 2) - (3e^2 + 3) + (4e^2 - 4e)}{4} \\]\n\\[ \\mathcal{A} = \\frac{2e^2 - 2 - 3e^2 - 3 + 4e^2 - 4e}{4} \\]\n\\[ \\mathcal{A} = \\frac{(2-3+4)e^2 - 4e + (-2-3)}{4} \\]\n\\[ \\mathcal{A} = \\frac{3e^2 - 4e - 5}{4} \\text{ unités d'aire.} \\]"
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-3",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-3",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "Corrigé de l’exercice 3",
    "text": "Corrigé de l’exercice 3\n1. On considère les points A(−1 ; 0 ; 5) et B(3; 2; −1).\nAffirmation 1 : Une représentation paramétrique de la droite (AB) est \\(\\begin{cases} x = 3 - 2t \\\\ y = 2 - t \\\\ z = -1 + 3t \\end{cases}\\) avec \\(t \\in \\mathbb{R}\\).\nAffirmation 1 : VRAIE\nJustification :\n\n\n\n\n\n\nRappel de cours : Représentation paramétrique d’une droite\n\n\n\nUne représentation paramétrique d’une droite est définie par un point appartenant à cette droite et un vecteur directeur de cette droite. La droite passant par un point \\(P_0(x_0; y_0; z_0)\\) et dirigée par un vecteur \\(\\overrightarrow{u}(a; b; c)\\) a pour représentation \\(\\begin{cases} x = x_0 + at \\\\ y = y_0 + bt \\\\ z = z_0 + ct \\end{cases}\\) avec \\(t \\in \\mathbb{R}\\).\n\n\nLa représentation paramétrique donnée est associée au point de coordonnées \\((3; 2; -1)\\), qui est le point B, et au vecteur directeur \\(\\overrightarrow{u}(-2; -1; 3)\\).\nPour vérifier si cette représentation est correcte pour la droite (AB), il suffit de s’assurer que le vecteur directeur \\(\\overrightarrow{u}\\) est bien colinéaire au vecteur \\(\\overrightarrow{AB}\\).\nCalculons les coordonnées du vecteur \\(\\overrightarrow{AB}\\) : \\[ \\overrightarrow{AB} \\begin{pmatrix} x_B - x_A \\\\ y_B - y_A \\\\ z_B - z_A \\end{pmatrix} = \\begin{pmatrix} 3 - (-1) \\\\ 2 - 0 \\\\ -1 - 5 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 2 \\\\ -6 \\end{pmatrix} \\]\nComparons les vecteurs \\(\\overrightarrow{u}(-2; -1; 3)\\) et \\(\\overrightarrow{AB}(4; 2; -6)\\).\nOn remarque que \\(\\overrightarrow{AB} = -2 \\times \\overrightarrow{u}\\), car : \\[ -2 \\times (-2) = 4 \\] \\[ -2 \\times (-1) = 2 \\] \\[ -2 \\times 3 = -6 \\] Les vecteurs \\(\\overrightarrow{u}\\) et \\(\\overrightarrow{AB}\\) sont donc colinéaires.\nLa représentation donnée utilise un point de la droite (le point B) et un vecteur directeur de la droite (le vecteur \\(\\overrightarrow{u}\\)). Elle est donc bien une représentation paramétrique de la droite (AB).\n\nAffirmation 2 : Le vecteur \\(\\overrightarrow{n}(5; -2; 1)\\) est normal au plan (OAB).\nAffirmation 2 : FAUSSE\nJustification :\n\n\n\n\n\n\nRappel de cours : Vecteur normal à un plan\n\n\n\nUn vecteur \\(\\overrightarrow{n}\\) est normal à un plan s’il est orthogonal à deux vecteurs non colinéaires de ce plan. On vérifie l’orthogonalité à l’aide du produit scalaire : deux vecteurs sont orthogonaux si leur produit scalaire est nul.\n\n\nLe plan (OAB) est dirigé par les vecteurs \\(\\overrightarrow{OA}\\) et \\(\\overrightarrow{OB}\\) (puisque O, A et B définissent le plan).\nCalculons les coordonnées de ces vecteurs :\n\nLe point O est l’origine, donc \\(O(0; 0; 0)\\).\n\\(\\overrightarrow{OA} \\begin{pmatrix} -1 - 0 \\\\ 0 - 0 \\\\ 5 - 0 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 0 \\\\ 5 \\end{pmatrix}\\)\n\\(\\overrightarrow{OB} \\begin{pmatrix} 3 - 0 \\\\ 2 - 0 \\\\ -1 - 0 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 2 \\\\ -1 \\end{pmatrix}\\)\n\nCes deux vecteurs ne sont pas colinéaires. Vérifions si le vecteur \\(\\overrightarrow{n}(5; -2; 1)\\) est orthogonal à \\(\\overrightarrow{OA}\\) et \\(\\overrightarrow{OB}\\) en calculant les produits scalaires.\n\nProduit scalaire avec \\(\\overrightarrow{OA}\\) : \\[ \\overrightarrow{n} \\cdot \\overrightarrow{OA} = (5)(-1) + (-2)(0) + (1)(5) = -5 + 0 + 5 = 0 \\] Le vecteur \\(\\overrightarrow{n}\\) est bien orthogonal à \\(\\overrightarrow{OA}\\).\nProduit scalaire avec \\(\\overrightarrow{OB}\\) : \\[ \\overrightarrow{n} \\cdot \\overrightarrow{OB} = (5)(3) + (-2)(2) + (1)(-1) = 15 - 4 - 1 = 10 \\] Le produit scalaire \\(\\overrightarrow{n} \\cdot \\overrightarrow{OB}\\) n’est pas nul.\n\nPuisque le vecteur \\(\\overrightarrow{n}\\) n’est pas orthogonal au vecteur \\(\\overrightarrow{OB}\\), il n’est pas normal au plan (OAB).\n\n2. On considère les droites \\(d\\) et \\(d'\\).\nAffirmation 3 : Les droites \\(d\\) et \\(d'\\) ne sont pas coplanaires.\nAffirmation 3 : FAUSSE\nJustification : Deux droites sont coplanaires si elles sont parallèles ou sécantes. Elles sont non coplanaires si elles ne sont ni parallèles ni sécantes.\n\nÉtape 1 : Vérifier si les droites sont parallèles.\nUn vecteur directeur de la droite \\(d\\) est \\(\\overrightarrow{v_d}(1; -1; 2)\\).\nUn vecteur directeur de la droite \\(d'\\) est \\(\\overrightarrow{v_{d'}}(4; 4; -6)\\).\nPour que les droites soient parallèles, leurs vecteurs directeurs doivent être colinéaires. Vérifions s’il existe un réel \\(\\lambda\\) tel que \\(\\overrightarrow{v_{d'}} = \\lambda \\overrightarrow{v_d}\\). \\[ \\begin{cases} 4 = \\lambda \\times 1 \\\\ 4 = \\lambda \\times (-1) \\\\ -6 = \\lambda \\times 2 \\end{cases} \\implies \\begin{cases} \\lambda = 4 \\\\ \\lambda = -4 \\\\ \\lambda = -3 \\end{cases} \\] Le système n’a pas de solution. Les vecteurs ne sont pas colinéaires, donc les droites \\(d\\) et \\(d'\\) ne sont pas parallèles.\nÉtape 2 : Vérifier si les droites sont sécantes.\nOn cherche s’il existe un point d’intersection, c’est-à-dire un couple de réels \\((k, s)\\) tel que :\n\\[ \\begin{cases} 15 + k = 1 + 4s \\quad (L_1) \\\\ 8 - k = 2 + 4s \\quad (L_2) \\\\ -6 + 2k = 1 - 6s \\quad (L_3) \\end{cases} \\] Simplifions les deux premières lignes : \\[ \\begin{cases} k - 4s = -14 \\\\ -k - 4s = -6 \\end{cases} \\] En additionnant ces deux lignes \\((L_1+L_2)\\), on obtient : \\[ -8s = -20 \\implies s = \\frac{-20}{-8} = \\frac{5}{2} \\] En remplaçant \\(s\\) dans la première ligne : \\[ k - 4\\left(\\frac{5}{2}\\right) = -14 \\implies k - 10 = -14 \\implies k = -4 \\] Nous avons trouvé un unique couple solution \\((k, s) = (-4, 5/2)\\) pour les deux premières équations. Vérifions s’il satisfait la troisième équation \\((L_3)\\) :\n\nMembre de gauche : \\(-6 + 2k = -6 + 2(-4) = -6 - 8 = -14\\).\nMembre de droite : \\(1 - 6s = 1 - 6\\left(\\frac{5}{2}\\right) = 1 - 15 = -14\\).\n\nLes deux membres sont égaux. Le système a une solution.\n\nLes droites \\(d\\) et \\(d'\\) ont un point d’intersection, elles sont donc sécantes. Si elles sont sécantes, elles sont coplanaires. L’affirmation qu’elles ne sont pas coplanaires est donc fausse.\n\nAffirmation 4 : La distance du point C(2; -1; 2) au plan \\(\\mathcal{P}\\) d’équation \\(x - y + z + 1 = 0\\) est égale à \\(2\\sqrt{3}\\).\nAffirmation 4 : VRAIE\nNous allons déterminer les coordonnées du point H, projeté orthogonal du point C sur le plan \\(\\mathcal{P}\\). La distance du point C au plan \\(\\mathcal{P}\\) est alors la longueur du segment [CH], c’est-à-dire la norme du vecteur \\(\\overrightarrow{CH}\\).\n\n\n\n\n\n\nRappel de cours : Projection orthogonale sur un plan\n\n\n\nLe projeté orthogonal H d’un point C sur un plan \\(\\mathcal{P}\\) est le point d’intersection entre le plan \\(\\mathcal{P}\\) et la droite \\(\\Delta\\) qui est perpendiculaire à \\(\\mathcal{P}\\) et qui passe par C.\nLe vecteur \\(\\overrightarrow{CH}\\) est alors un vecteur normal au plan \\(\\mathcal{P}\\).\n\n\nLa démarche se décompose en trois étapes :\n\nDéterminer une représentation paramétrique de la droite \\(\\Delta\\) passant par C et orthogonale à \\(\\mathcal{P}\\).\nCalculer les coordonnées du point H, intersection de \\(\\Delta\\) et \\(\\mathcal{P}\\).\nCalculer la norme du vecteur \\(\\overrightarrow{CH}\\).\n\nÉtape 1 : Représentation paramétrique de la droite \\(\\Delta\\)\nLa droite \\(\\Delta\\) est orthogonale au plan \\(\\mathcal{P}\\). Un vecteur directeur de \\(\\Delta\\) est donc un vecteur normal à \\(\\mathcal{P}\\).\nL’équation du plan \\(\\mathcal{P}\\) est \\(1x - 1y + 1z + 1 = 0\\). Un vecteur normal à \\(\\mathcal{P}\\) est donc \\(\\overrightarrow{n}(1; -1; 1)\\).\nCe vecteur \\(\\overrightarrow{n}\\) est un vecteur directeur pour notre droite \\(\\Delta\\).\nLa droite \\(\\Delta\\) passe par le point \\(C(2; -1; 2)\\) et est dirigée par le vecteur \\(\\overrightarrow{n}(1; -1; 1)\\).\nUne représentation paramétrique de \\(\\Delta\\) est donc : \\[ \\begin{cases} x = 2 + 1 \\cdot t \\\\ y = -1 - 1 \\cdot t \\\\ z = 2 + 1 \\cdot t \\end{cases} \\quad \\text{avec } t \\in \\mathbb{R} \\quad \\iff \\quad \\begin{cases} x = 2 + t \\\\ y = -1 - t \\\\ z = 2 + t \\end{cases} \\]\nÉtape 2 : Coordonnées du point d’intersection H\nLe point \\(H(x_H; y_H; z_H)\\) appartient à la fois à la droite \\(\\Delta\\) et au plan \\(\\mathcal{P}\\). Ses coordonnées vérifient donc le système d’équations composé de la représentation paramétrique de \\(\\Delta\\) et de l’équation cartésienne de \\(\\mathcal{P}\\).\nIl existe un réel \\(t\\) tel que : \\[ \\begin{cases} x_H = 2 + t \\\\ y_H = -1 - t \\\\ z_H = 2 + t \\\\ x_H - y_H + z_H + 1 = 0 \\end{cases} \\] On substitue les expressions de \\(x_H, y_H, z_H\\) en fonction de \\(t\\) dans l’équation du plan : \\[ (2+t) - (-1-t) + (2+t) + 1 = 0 \\] \\[ 2 + t + 1 + t + 2 + t + 1 = 0 \\] \\[ 3t + 6 = 0 \\] \\[ 3t = -6 \\] \\[ t = -2 \\] Maintenant que nous avons la valeur du paramètre \\(t\\) correspondant au point H, nous pouvons calculer ses coordonnées en remplaçant \\(t\\) par \\(-2\\) dans la représentation paramétrique de \\(\\Delta\\) : \\[ \\begin{cases} x_H = 2 + (-2) = 0 \\\\ y_H = -1 - (-2) = 1 \\\\ z_H = 2 + (-2) = 0 \\end{cases} \\] Le projeté orthogonal de C sur le plan \\(\\mathcal{P}\\) est le point \\(H(0; 1; 0)\\).\nÉtape 3 : Calcul de la distance CH\nLa distance du point C au plan \\(\\mathcal{P}\\) est la norme du vecteur \\(\\overrightarrow{CH}\\).\nCalculons d’abord les coordonnées du vecteur \\(\\overrightarrow{CH}\\) : \\[ \\overrightarrow{CH} \\begin{pmatrix} x_H - x_C \\\\ y_H - y_C \\\\ z_H - z_C \\end{pmatrix} = \\begin{pmatrix} 0 - 2 \\\\ 1 - (-1) \\\\ 0 - 2 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ 2 \\\\ -2 \\end{pmatrix} \\] Calculons maintenant sa norme : \\[ \\text{dist}(C, \\mathcal{P}) = ||\\overrightarrow{CH}|| = \\sqrt{(-2)^2 + 2^2 + (-2)^2} \\] \\[ = \\sqrt{4 + 4 + 4} = \\sqrt{12} \\] On simplifie la racine carrée : \\[ \\sqrt{12} = \\sqrt{4 \\times 3} = \\sqrt{4} \\times \\sqrt{3} = 2\\sqrt{3} \\] La distance du point C au plan \\(\\mathcal{P}\\) est bien égale à \\(2\\sqrt{3}\\)."
  },
  {
    "objectID": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-4",
    "href": "posts/2025-06-16-MathsMétropoleJ1/index.html#corrigé-de-lexercice-4",
    "title": "Corrigé du sujet de mathématiques du baccalauréat 2025 - Métropole Jour 1",
    "section": "Corrigé de l’exercice 4",
    "text": "Corrigé de l’exercice 4\nCet exercice propose d’étudier l’évolution d’une population biologique par deux approches complémentaires : un modèle discret basé sur une suite récurrente, et un modèle continu régi par une équation différentielle.\n\nPartie A : Étude d’un modèle discret\nOn étudie la suite \\((u_n)\\) définie par \\(u_0 = 1\\) et, pour tout entier naturel \\(n\\), \\(u_{n+1} = -0,02u_n^2 + 1,3u_n\\).\n1. Calculer la superficie au premier juillet 2025.\nLe premier juillet 2024 correspond à l’année de départ, soit \\(n=0\\), avec \\(u_0=1\\) ha. Le premier juillet 2025 correspond à \\(n=1\\). On calcule donc \\(u_1\\) : \\[ u_1 = -0,02u_0^2 + 1,3u_0 \\] \\[ u_1 = -0,02(1)^2 + 1,3(1) = -0,02 + 1,3 = 1,28 \\] D’après ce modèle, la superficie recouverte au premier juillet 2025 sera de 1,28 hectare.\n2. On note \\(h\\) la fonction définie sur \\([0; 20]\\) par \\(h(x) = -0,02x^2 + 1,3x\\).\na. Démontrer que pour tout entier naturel \\(n\\), \\(1 \\leqslant u_n \\leqslant u_{n+1} \\leqslant 20\\).\nNous allons procéder par récurrence. Soit \\(P(n)\\) la propriété : “\\(1 \\leqslant u_n \\leqslant u_{n+1} \\leqslant 20\\)”.\nInitialisation (pour n=0) : - \\(u_0 = 1\\) - \\(u_1 = 1,28\\) On a bien \\(1 \\leqslant 1 \\leqslant 1,28 \\leqslant 20\\), c’est-à-dire \\(1 \\leqslant u_0 \\leqslant u_1 \\leqslant 20\\). La propriété \\(P(0)\\) est vraie.\nHérédité : Supposons que la propriété \\(P(k)\\) est vraie pour un certain entier naturel \\(k \\geqslant 0\\). C’est notre hypothèse de récurrence : \\(1 \\leqslant u_k \\leqslant u_{k+1} \\leqslant 20\\). Nous voulons montrer que \\(P(k+1)\\) est vraie, c’est-à-dire : \\(1 \\leqslant u_{k+1} \\leqslant u_{k+2} \\leqslant 20\\).\nD’après l’hypothèse de récurrence, nous avons \\(1 \\leqslant u_k \\leqslant u_{k+1} \\leqslant 20\\). On nous admet que la fonction \\(h\\) est croissante sur l’intervalle \\([0; 20]\\). Puisque les termes \\(u_k\\) et \\(u_{k+1}\\) appartiennent à cet intervalle, on peut appliquer la fonction \\(h\\) à l’inégalité en conservant l’ordre : \\[ h(1) \\leqslant h(u_k) \\leqslant h(u_{k+1}) \\leqslant h(20) \\] On a \\(u_{n+1} = h(u_n)\\). L’inégalité devient : \\[ h(1) \\leqslant u_{k+1} \\leqslant u_{k+2} \\leqslant h(20) \\] Calculons les valeurs des bornes : - \\(h(1) = -0,02(1)^2 + 1,3(1) = 1,28\\). - \\(h(20) = -0,02(20)^2 + 1,3(20) = -0,02(400) + 26 = -8 + 26 = 18\\). L’inégalité devient donc : \\[ 1,28 \\leqslant u_{k+1} \\leqslant u_{k+2} \\leqslant 18 \\] Puisque \\(1 \\leqslant 1,28\\) et \\(18 \\leqslant 20\\), on peut en conclure que : \\[ 1 \\leqslant u_{k+1} \\leqslant u_{k+2} \\leqslant 20 \\] La propriété \\(P(k+1)\\) est donc vraie.\nConclusion : Par le principe de récurrence, la propriété \\(P(n)\\) est vraie pour tout entier naturel \\(n\\).\nb. En déduire que la suite \\((u_n)\\) converge.\n\n\n\n\n\n\nRappel de cours : Théorème de la convergence monotone\n\n\n\n\nToute suite croissante et majorée est convergente.\nToute suite décroissante et minorée est convergente.\n\n\n\nD’après la question précédente, nous avons montré que \\(u_n \\leqslant u_{n+1}\\) pour tout \\(n\\). La suite \\((u_n)\\) est donc croissante. Nous avons également montré que \\(u_n \\leqslant 20\\) pour tout \\(n\\). La suite \\((u_n)\\) est donc majorée par 20. Étant croissante et majorée, la suite \\((u_n)\\) est convergente. On note \\(L\\) sa limite.\nc. Justifier que \\(L=15\\).\nLa suite \\((u_n)\\) est définie par la relation de récurrence \\(u_{n+1} = h(u_n)\\), où \\(h\\) est une fonction continue sur \\([0; 20]\\). Comme la suite \\((u_n)\\) converge vers une limite \\(L\\), cette limite doit être un point fixe de la fonction \\(h\\), c’est-à-dire qu’elle doit vérifier l’équation \\(h(L)=L\\). Résolvons l’équation \\(h(x)=x\\) : \\[ -0,02x^2 + 1,3x = x \\] \\[ -0,02x^2 + 0,3x = 0 \\] On factorise par \\(x\\) : \\[ x(-0,02x + 0,3) = 0 \\] Cette équation a deux solutions :\n\n\\(x = 0\\)\n\\(-0,02x + 0,3 = 0 \\iff 0,02x = 0,3 \\iff x = \\frac{0,3}{0,02} = 15\\)\n\nLa suite \\((u_n)\\) est croissante et son premier terme est \\(u_0=1\\). Tous les termes de la suite sont donc supérieurs ou égaux à 1. Sa limite \\(L\\) ne peut donc pas être 0. On en conclut que la limite de la suite est \\(L=15\\).\n3. Dépassement d’un seuil.\na. Justifier que la surface recouverte dépassera les 14 hectares. La suite \\((u_n)\\) est croissante et converge vers 15. Par définition de la convergence, les termes de la suite se rapprochent de 15. Comme la suite est croissante, les termes se rapprochent de 15 par valeurs inférieures. Puisque \\(14 &lt; 15\\), il existera nécessairement un rang \\(N\\) à partir duquel tous les termes \\(u_n\\) seront dans l’intervalle \\(]14; 15]\\). La superficie recouverte dépassera donc un jour les 14 hectares.\nb. Recopier et compléter l’algorithme. L’algorithme doit calculer les termes successifs de la suite jusqu’à ce que la valeur de u dépasse (ou soit égale à) 14. À chaque étape, il faut incrémenter le compteur d’années n.\ndef seuil():\n    n = 0\n    u = 1\n    while u &lt;= 14:\n        n = n + 1\n        u = -0.02 * u * u + 1.3 * u\n    return n\n\n\n\nPartie B : Étude d’un modèle continu\nOn étudie la fonction \\(f\\) solution de l’équation différentielle \\((E_1) : y' = 0,02y(15-y)\\), avec la condition initiale \\(f(0)=1\\).\n1. Montrer que \\(g = 1/f\\) est solution de \\((E_2) : y' = -0,3y + 0,02\\).\nLa fonction \\(f\\) ne s’annule pas, donc la fonction \\(g=1/f\\) est bien définie et dérivable. Calculons la dérivée \\(g'(t)\\) : \\[ g'(t) = \\left(\\frac{1}{f(t)}\\right)' = -\\frac{f'(t)}{(f(t))^2} \\] On sait que \\(f\\) est solution de \\((E_1)\\), donc \\(f'(t) = 0,02f(t)(15-f(t))\\). On substitue cette expression dans celle de \\(g'(t)\\) : \\[ g'(t) = -\\frac{0,02f(t)(15-f(t))}{(f(t))^2} = -0,02 \\frac{15-f(t)}{f(t)} \\] On sépare la fraction en deux : \\[ g'(t) = -0,02 \\left( \\frac{15}{f(t)} - \\frac{f(t)}{f(t)} \\right) = -0,02 \\left( 15 \\times \\frac{1}{f(t)} - 1 \\right) \\] Puisque \\(g(t) = 1/f(t)\\), on obtient : \\[ g'(t) = -0,02 (15g(t) - 1) = -0,3g(t) + 0,02 \\] La fonction \\(g\\) est donc bien solution de l’équation différentielle \\((E_2)\\).\n2. Donner les solutions de l’équation différentielle \\((E_2)\\).\n\n\n\n\n\n\nFormule : Solutions d’une équation différentielle linéaire\n\n\n\nLes solutions de l’équation différentielle \\(y' = ay + b\\) (où \\(a \\neq 0\\)) sont les fonctions de la forme : \\[ y(t) = C e^{at} - \\frac{b}{a} \\quad \\text{avec } C \\in \\mathbb{R} \\]\n\n\nL’équation \\((E_2)\\) est \\(y' = -0,3y + 0,02\\). C’est une équation de la forme \\(y'=ay+b\\) avec \\(a=-0,3\\) et \\(b=0,02\\). Les solutions sont donc les fonctions \\(g\\) définies par : \\[ g(t) = C e^{-0,3t} - \\frac{0,02}{-0,3} = C e^{-0,3t} + \\frac{2}{30} = C e^{-0,3t} + \\frac{1}{15} \\] où \\(C\\) est une constante réelle.\n3. En déduire l’expression de \\(f(t)\\). On utilise la condition initiale \\(f(0)=1\\) pour déterminer la constante \\(C\\). On sait que \\(g(0) = 1/f(0) = 1/1 = 1\\). En utilisant l’expression de \\(g(t)\\) trouvée à la question précédente : \\[ g(0) = C e^{-0,3 \\times 0} + \\frac{1}{15} = C e^0 + \\frac{1}{15} = C + \\frac{1}{15} \\] On a donc l’équation \\(C + \\frac{1}{15} = 1\\), ce qui donne \\(C = 1 - \\frac{1}{15} = \\frac{14}{15}\\). L’expression de \\(g(t)\\) est : \\[ g(t) = \\frac{14}{15}e^{-0,3t} + \\frac{1}{15} \\] Maintenant, on trouve \\(f(t)\\) en calculant l’inverse de \\(g(t)\\) : \\[ f(t) = \\frac{1}{g(t)} = \\frac{1}{\\frac{14}{15}e^{-0,3t} + \\frac{1}{15}} \\] En multipliant le numérateur et le dénominateur par 15 pour simplifier : \\[ f(t) = \\frac{15}{14e^{-0,3t} + 1} \\]\n4. Déterminer la limite de \\(f\\) en \\(+\\infty\\). On cherche \\(\\lim_{t \\to +\\infty} f(t)\\). On a \\(\\lim_{t \\to +\\infty} -0,3t = -\\infty\\). Par composition, \\(\\lim_{t \\to +\\infty} e^{-0,3t} = 0\\). Donc, la limite du dénominateur est : \\[ \\lim_{t \\to +\\infty} (14e^{-0,3t} + 1) = 14 \\times 0 + 1 = 1 \\] Par quotient, la limite de \\(f\\) est : \\[ \\lim_{t \\to +\\infty} f(t) = \\frac{15}{1} = 15 \\] Le modèle continu prédit que la superficie recouverte tendra vers 15 hectares à long terme, ce qui est cohérent avec le modèle discret.\n5. Résoudre l’inéquation \\(f(t) &gt; 14\\) et interpréter. On résout dans \\([0; +\\infty[\\) : \\[ \\frac{15}{14e^{-0,3t} + 1} &gt; 14 \\] Comme le dénominateur \\(14e^{-0,3t} + 1\\) est strictement positif, on peut multiplier les deux membres par ce terme sans changer le sens de l’inégalité : \\[ 15 &gt; 14(14e^{-0,3t} + 1) \\] \\[ 15 &gt; 196e^{-0,3t} + 14 \\] \\[ 1 &gt; 196e^{-0,3t} \\] \\[ \\frac{1}{196} &gt; e^{-0,3t} \\] On applique la fonction logarithme népérien, qui est strictement croissante, des deux côtés : \\[ \\ln\\left(\\frac{1}{196}\\right) &gt; \\ln(e^{-0,3t}) \\] \\[ -\\ln(196) &gt; -0,3t \\] On divise par \\(-0,3\\), qui est un nombre négatif, ce qui inverse le sens de l’inégalité : \\[ \\frac{-\\ln(196)}{-0,3} &lt; t \\implies t &gt; \\frac{\\ln(196)}{0,3} \\] Calculons une valeur approchée : \\[ t &gt; \\frac{5,278...}{0,3} \\approx 17,59 \\] Interprétation : La superficie recouverte par la posidonie dépassera 14 hectares après environ 17,6 ans à compter du premier juillet 2024. Cela se produira donc au cours de l’année 2042 (\\(2024 + 18\\)).\nRemarque : L’algorithme python de la partie A retourne \\(n=18\\) : les résultats sont cohérents."
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "",
    "text": "Cet exercice évalue les compétences sur les bases de données relationnelles et le langage SQL.\n\n\nDans cette partie, nous travaillons avec une unique table inventaire.\n\n\nExpliquer pourquoi l’attribut num_ser ne peut pas être une clé primaire de la relation inventaire.\n\n\n\n\n\n\nRappel : Clé primaire\n\n\n\nUne clé primaire est un attribut (ou un ensemble d’attributs) qui permet d’identifier de manière unique chaque enregistrement (ou tuple) dans une table. Par conséquent, la valeur d’une clé primaire ne peut pas être présente en double dans la table.\n\n\nL’attribut num_ser ne peut pas être une clé primaire car ses valeurs ne sont pas uniques dans la table. On observe que la valeur 81757532 apparaît deux fois dans la colonne num_ser : pour la guitare avec id=4 et pour celle avec id=8. Une clé primaire ne peut pas contenir de doublons.\n\n\n\nDonner, sous forme de tableau, le résultat de la requête suivante appliquée à l’extrait de table précédent.\nSELECT marque, modele\nFROM inventaire\nWHERE annee = 1956\nLa requête sélectionne les attributs marque et modele pour tous les enregistrements où l’année est 1956. En examinant la table inventaire, deux lignes correspondent à ce critère : celle avec id=1 et celle avec id=7.\nLe résultat est donc :\n\n\n\nmarque\nmodele\n\n\n\n\nGibson\nLes Paul Goldtop\n\n\nFender\nStratocaster\n\n\n\n\n\n\nÉcrire une requête SQL permettant d’obtenir toutes les années du modèle Les Paul Standard dans la collection.\nPour sélectionner les années, on utilise SELECT annee. Pour ne garder que celles correspondant au modèle ‘Les Paul Standard’, on utilise une clause WHERE. Il est judicieux d’utiliser DISTINCT pour éviter d’afficher des doublons si plusieurs guitares de ce modèle ont été fabriquées la même année.\n\n\n\n\n\n\nClause DISTINCT\n\n\n\nLa clause DISTINCT s’utilise avec SELECT pour éliminer les lignes en double dans le résultat d’une requête.\n\n\nSELECT DISTINCT annee\nFROM inventaire\nWHERE modele = 'Les Paul Standard';\n\n\n\nÉcrire une requête SQL permettant d’obtenir tous les modèles de guitares de la marque Gibson par ordre croissant de l’année dans la collection.\nIl faut filtrer les guitares de marque ‘Gibson’ avec WHERE et trier le résultat par année croissante avec ORDER BY.\nSELECT modele\nFROM inventaire\nWHERE marque = 'Gibson'\nORDER BY annee ASC;\nNote : ASC (pour ascendant) est l’ordre de tri par défaut et peut être omis.\n\n\n\nMaud a fait une erreur de saisie pour la guitare d’identifiant id=1. L’année est en réalité 1957. Écrire une requête SQL permettant de corriger cette erreur de saisie.\nLa modification d’un enregistrement existant se fait avec la commande UPDATE. On spécifie la table à modifier, les colonnes et leurs nouvelles valeurs avec SET, et l’enregistrement à modifier avec WHERE.\n\n\n\n\n\n\nSyntaxe UPDATE\n\n\n\nUPDATE nom_de_la_table SET colonne1 = valeur1, colonne2 = valeur2, ... WHERE condition; La clause WHERE est importante pour ne pas modifier toutes les lignes de la table.\n\n\nUPDATE inventaire\nSET annee = 1957\nWHERE id = 1;\n\n\n\n\nDans cette partie, la base de données est normalisée en trois tables : marque, modele et guitare.\n\n\nExpliquer brièvement, en justifiant, dans quel ordre les trois tables doivent être créées.\n\n\n\n\n\n\nRappel : Clé étrangère\n\n\n\nUne clé étrangère est un attribut dans une table qui fait référence à la clé primaire d’une autre table. Pour pouvoir créer une contrainte de clé étrangère, la table référencée doit déjà exister.\n\n\nL’ordre de création des tables est contraint par les clés étrangères.\n\nLa table modele contient une clé étrangère id_marque qui référence la clé primaire de la table marque. La table marque doit donc être créée avant la table modele.\nLa table guitare contient une clé étrangère id_modele qui référence la clé primaire de la table modele. La table modele doit donc être créée avant la table guitare.\n\nL’ordre de création est donc : 1. marque 2. modele 3. guitare\n\n\n\nÉcrire une requête SQL permettant d’obtenir le numéro de série et l’année de toutes les guitares Les Paul Standard de la collection.\nLes informations num_ser et annee sont dans la table guitare, mais le nom du modèle ‘Les Paul Standard’ est dans la table modele. Il faut donc effectuer une jointure entre ces deux tables.\nSELECT G.num_ser, G.annee\nFROM guitare AS G\nJOIN modele AS M ON G.id_modele = M.id\nWHERE M.nom = 'Les Paul Standard';\nNote : l’utilisation d’alias (AS G, AS M) rend la requête plus lisible.\n\n\n\nÉcrire une requête SQL permettant de retirer de la collection la guitare d’identifiant id=3.\nLa suppression d’un enregistrement se fait avec la commande DELETE FROM. Il est essentiel de spécifier la ligne à supprimer avec une clause WHERE.\nDELETE FROM guitare\nWHERE id = 3;\n\n\n\nÉcrire l’ensemble des requêtes SQL permettant d’ajouter la guitare suivante :\n\nmarque : BC Rich\nmodèle : Mockingbird\nannée : 1992\nnuméro de série : 92R\nprix : 5000.\n\nL’ajout doit se faire en respectant les contraintes de clés étrangères. On doit d’abord insérer la nouvelle marque, puis le nouveau modèle (en le liant à la marque), et enfin la nouvelle guitare (en la liant au modèle). Les identifiants à utiliser sont fournis.\n\nInsertion de la marque :\nINSERT INTO marque (id, nom) VALUES (3, 'BC Rich');\nInsertion du modèle :\nINSERT INTO modele (id, nom, id_marque) VALUES (5, 'Mockingbird', 3);\nInsertion de la guitare :\nINSERT INTO guitare (id, id_modele, annee, num_ser, prix) VALUES (9, 5, 1992, '92R', 5000);\n\n\n\n\nÉcrire une requête SQL permettant de calculer la valeur totale des modèles Stratocaster de la collection de Slash.\nIl faut utiliser la fonction d’agrégation SUM() sur la colonne prix de la table guitare. Comme pour la question 7, une jointure avec la table modele est nécessaire pour filtrer sur le nom du modèle ‘Stratocaster’.\nSELECT SUM(G.prix)\nFROM guitare AS G\nJOIN modele AS M ON G.id_modele = M.id\nWHERE M.nom = 'Stratocaster';"
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-a",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-a",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "",
    "text": "Dans cette partie, nous travaillons avec une unique table inventaire.\n\n\nExpliquer pourquoi l’attribut num_ser ne peut pas être une clé primaire de la relation inventaire.\n\n\n\n\n\n\nRappel : Clé primaire\n\n\n\nUne clé primaire est un attribut (ou un ensemble d’attributs) qui permet d’identifier de manière unique chaque enregistrement (ou tuple) dans une table. Par conséquent, la valeur d’une clé primaire ne peut pas être présente en double dans la table.\n\n\nL’attribut num_ser ne peut pas être une clé primaire car ses valeurs ne sont pas uniques dans la table. On observe que la valeur 81757532 apparaît deux fois dans la colonne num_ser : pour la guitare avec id=4 et pour celle avec id=8. Une clé primaire ne peut pas contenir de doublons.\n\n\n\nDonner, sous forme de tableau, le résultat de la requête suivante appliquée à l’extrait de table précédent.\nSELECT marque, modele\nFROM inventaire\nWHERE annee = 1956\nLa requête sélectionne les attributs marque et modele pour tous les enregistrements où l’année est 1956. En examinant la table inventaire, deux lignes correspondent à ce critère : celle avec id=1 et celle avec id=7.\nLe résultat est donc :\n\n\n\nmarque\nmodele\n\n\n\n\nGibson\nLes Paul Goldtop\n\n\nFender\nStratocaster\n\n\n\n\n\n\nÉcrire une requête SQL permettant d’obtenir toutes les années du modèle Les Paul Standard dans la collection.\nPour sélectionner les années, on utilise SELECT annee. Pour ne garder que celles correspondant au modèle ‘Les Paul Standard’, on utilise une clause WHERE. Il est judicieux d’utiliser DISTINCT pour éviter d’afficher des doublons si plusieurs guitares de ce modèle ont été fabriquées la même année.\n\n\n\n\n\n\nClause DISTINCT\n\n\n\nLa clause DISTINCT s’utilise avec SELECT pour éliminer les lignes en double dans le résultat d’une requête.\n\n\nSELECT DISTINCT annee\nFROM inventaire\nWHERE modele = 'Les Paul Standard';\n\n\n\nÉcrire une requête SQL permettant d’obtenir tous les modèles de guitares de la marque Gibson par ordre croissant de l’année dans la collection.\nIl faut filtrer les guitares de marque ‘Gibson’ avec WHERE et trier le résultat par année croissante avec ORDER BY.\nSELECT modele\nFROM inventaire\nWHERE marque = 'Gibson'\nORDER BY annee ASC;\nNote : ASC (pour ascendant) est l’ordre de tri par défaut et peut être omis.\n\n\n\nMaud a fait une erreur de saisie pour la guitare d’identifiant id=1. L’année est en réalité 1957. Écrire une requête SQL permettant de corriger cette erreur de saisie.\nLa modification d’un enregistrement existant se fait avec la commande UPDATE. On spécifie la table à modifier, les colonnes et leurs nouvelles valeurs avec SET, et l’enregistrement à modifier avec WHERE.\n\n\n\n\n\n\nSyntaxe UPDATE\n\n\n\nUPDATE nom_de_la_table SET colonne1 = valeur1, colonne2 = valeur2, ... WHERE condition; La clause WHERE est importante pour ne pas modifier toutes les lignes de la table.\n\n\nUPDATE inventaire\nSET annee = 1957\nWHERE id = 1;"
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-b",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-b",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "",
    "text": "Dans cette partie, la base de données est normalisée en trois tables : marque, modele et guitare.\n\n\nExpliquer brièvement, en justifiant, dans quel ordre les trois tables doivent être créées.\n\n\n\n\n\n\nRappel : Clé étrangère\n\n\n\nUne clé étrangère est un attribut dans une table qui fait référence à la clé primaire d’une autre table. Pour pouvoir créer une contrainte de clé étrangère, la table référencée doit déjà exister.\n\n\nL’ordre de création des tables est contraint par les clés étrangères.\n\nLa table modele contient une clé étrangère id_marque qui référence la clé primaire de la table marque. La table marque doit donc être créée avant la table modele.\nLa table guitare contient une clé étrangère id_modele qui référence la clé primaire de la table modele. La table modele doit donc être créée avant la table guitare.\n\nL’ordre de création est donc : 1. marque 2. modele 3. guitare\n\n\n\nÉcrire une requête SQL permettant d’obtenir le numéro de série et l’année de toutes les guitares Les Paul Standard de la collection.\nLes informations num_ser et annee sont dans la table guitare, mais le nom du modèle ‘Les Paul Standard’ est dans la table modele. Il faut donc effectuer une jointure entre ces deux tables.\nSELECT G.num_ser, G.annee\nFROM guitare AS G\nJOIN modele AS M ON G.id_modele = M.id\nWHERE M.nom = 'Les Paul Standard';\nNote : l’utilisation d’alias (AS G, AS M) rend la requête plus lisible.\n\n\n\nÉcrire une requête SQL permettant de retirer de la collection la guitare d’identifiant id=3.\nLa suppression d’un enregistrement se fait avec la commande DELETE FROM. Il est essentiel de spécifier la ligne à supprimer avec une clause WHERE.\nDELETE FROM guitare\nWHERE id = 3;\n\n\n\nÉcrire l’ensemble des requêtes SQL permettant d’ajouter la guitare suivante :\n\nmarque : BC Rich\nmodèle : Mockingbird\nannée : 1992\nnuméro de série : 92R\nprix : 5000.\n\nL’ajout doit se faire en respectant les contraintes de clés étrangères. On doit d’abord insérer la nouvelle marque, puis le nouveau modèle (en le liant à la marque), et enfin la nouvelle guitare (en la liant au modèle). Les identifiants à utiliser sont fournis.\n\nInsertion de la marque :\nINSERT INTO marque (id, nom) VALUES (3, 'BC Rich');\nInsertion du modèle :\nINSERT INTO modele (id, nom, id_marque) VALUES (5, 'Mockingbird', 3);\nInsertion de la guitare :\nINSERT INTO guitare (id, id_modele, annee, num_ser, prix) VALUES (9, 5, 1992, '92R', 5000);\n\n\n\n\nÉcrire une requête SQL permettant de calculer la valeur totale des modèles Stratocaster de la collection de Slash.\nIl faut utiliser la fonction d’agrégation SUM() sur la colonne prix de la table guitare. Comme pour la question 7, une jointure avec la table modele est nécessaire pour filtrer sur le nom du modèle ‘Stratocaster’.\nSELECT SUM(G.prix)\nFROM guitare AS G\nJOIN modele AS M ON G.id_modele = M.id\nWHERE M.nom = 'Stratocaster';"
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-a-réseau-local",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-a-réseau-local",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "Partie A : Réseau local",
    "text": "Partie A : Réseau local\n\nQuestion 1\nIndiquer les deux seules adresses IP valides pour cette nouvelle borne, parmi les quatre adresses IP proposées.\n\n\n\n\n\n\nRappel : Adressage IP et Masque de sous-réseau\n\n\n\nLe réseau du café 1 est 192.168.20.0 avec un masque 255.255.255.0 (ou /24).\n\nL’adresse du réseau est 192.168.20.0. Elle ne peut pas être attribuée à une machine.\nL’adresse de diffusion (broadcast) est 192.168.20.255. Elle ne peut pas être attribuée à une machine.\nLes adresses valides pour les hôtes vont donc de 192.168.20.1 à 192.168.20.254. Le dernier octet d’une adresse IPv4 doit être compris entre 0 et 255.\n\n\n\nAnalysons les propositions :\n\n\n192.168.20.2 : Valide. Elle est dans la plage 192.168.20.1 - 192.168.20.254.\n\n\n192.168.20.157 : Valide. Elle est dans la plage 192.168.20.1 - 192.168.20.254.\n\n\n192.168.20.261 : Invalide. Le dernier octet (261) est supérieur à 255.\n\n\n192.168.24.10 : Invalide. Elle n’appartient pas au réseau 192.168.20.0 car le troisième octet (24) est différent.\n\n\nLes deux adresses valides sont (a) 192.168.20.2 et (b) 192.168.20.157.\n\n\nQuestion 2\nDéterminer l’adresse de diffusion du réseau du café 1.\nPour un réseau d’adresse 192.168.20.0 et de masque 255.255.255.0, l’adresse de diffusion est celle où tous les bits de la partie hôte (le dernier octet ici) sont à 1. En binaire, 11111111 correspond à 255 en décimal. L’adresse de diffusion est donc 192.168.20.255.\n\n\nQuestion 3\nDéterminer combien de machines informatiques il est encore possible de connecter au réseau du café 1 après l’installation de la troisième borne de commande.\nUn masque /24 laisse 8 bits pour la partie hôte, ce qui permet \\(2^8 = 256\\) adresses au total. En retirant l’adresse réseau et l’adresse de diffusion, il y a \\(256 - 2 = 254\\) adresses disponibles pour les machines.\nMachines déjà connectées sur le réseau 192.168.20.0 (d’après le schéma) :\n\nL’interface du routeur 2 : 192.168.20.1\nBorne de commande 1 : 192.168.20.10\nBorne de commande 2 : 192.168.20.11\n\nCela fait 3 adresses utilisées. Si on ajoute une troisième borne, il y aura 4 adresses utilisées. Le nombre de machines qu’il est encore possible de connecter est donc : \\(254 - 4 = 250\\).\nIl est encore possible de connecter 250 machines.\n\n\nQuestion 4\nExpliquer quelle est la longueur maximale du masque de sous-réseau que l’on pourrait choisir pour le réseau local du café 1.\nLe réseau a besoin de 8 adresses IP (ce qui inclut l’adresse de réseau et de diffusion). Il nous faut donc trouver le plus petit nombre de bits n pour la partie hôte tel que \\(2^n \\ge 8\\).\n\n\\(2^2 = 4\\) (insuffisant)\n\\(2^3 = 8\\) (suffisant)\n\nIl faut donc réserver 3 bits pour la partie hôte. La longueur du masque sera alors \\(32 - 3 = 29\\) bits. La longueur maximale du masque est 29 bits."
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-b-routage-rip",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-b-routage-rip",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "Partie B : Routage RIP",
    "text": "Partie B : Routage RIP\n\nQuestion 5\nRecopier et compléter les deux dernières lignes de la table de routage du routeur 2.\n\n\n\n\n\n\nRappel : Protocole RIP (Routing Information Protocol)\n\n\n\nLe protocole RIP utilise le nombre de sauts (hops) comme métrique pour choisir le meilleur chemin. Un saut correspond au passage d’un routeur. Le chemin avec le moins de sauts est privilégié.\n\n\n\nDestination 192.168.30.0 (Réseau Café 2) :\n\nChemin : Routeur 2 \\(\\rightarrow\\) Routeur 3.\nLe prochain routeur est le R3. Son interface sur le lien est 172.16.4.2.\nL’interface de sortie sur R2 est 172.16.4.1.\nNombre de sauts pour atteindre un réseau directement connecté au routeur suivant : 1.\n\nDestination 172.16.1.0 (lien entre R1 et R4) :\n\nChemin : Routeur 2 \\(\\rightarrow\\) Routeur 1.\nLe prochain routeur est le R1. Son interface sur le lien est 172.16.3.2.\nL’interface de sortie sur R2 est 172.16.3.1.\nNombre de sauts : 1.\n\n\nTable complétée :\n\n\n\n\n\n\n\n\n\nRéseau destination\nInterface de sortie\nProchain routeur\nNombre de sauts\n\n\n\n\n192.168.30.0\n172.16.4.1\n172.16.4.2\n1\n\n\n172.16.1.0\n172.16.3.1\n172.16.3.2\n1\n\n\n\n\n\nQuestion 6\nIdentifier, dans la table de routage du routeur 2, le réseau de destination que l’on peut atteindre d’une autre façon et indiquer comment cette ligne pourrait être modifiée.\nLe réseau 192.168.10.0 (Siège Social) est atteint en 2 sauts via le chemin R2 \\(\\rightarrow\\) R1 \\(\\rightarrow\\) R4. Il existe un chemin alternatif : R2 \\(\\rightarrow\\) R3 \\(\\rightarrow\\) R4. Ce chemin a également 2 sauts. Le protocole RIP considère ces deux chemins comme équivalents en coût. La ligne pourrait donc être modifiée pour utiliser cette seconde route.\n\nRéseau de destination : 192.168.10.0\nModification possible :\n\nInterface de sortie : 172.16.4.1 (vers le routeur 3)\nProchain routeur : 172.16.4.2 (l’adresse du routeur 3)\nNombre de sauts : 2 (inchangé)\n\n\n\n\nQuestion 7\nRecopier et compléter la ligne à ajouter à la table de routage du routeur 2.\nUne adresse non référencée doit être routée par défaut vers Internet. Le routeur connecté à Internet est le R1. Le routeur 2 doit donc envoyer ces paquets au routeur 1. La destination “autre” correspond à la route par défaut 0.0.0.0.\n\n\n\nRéseau destination\nInterface de sortie\nProchain routeur\n\n\n\n\nautre (0.0.0.0/0)\n172.16.3.1\n172.16.3.2"
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-c-routage-ospf",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-c-routage-ospf",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "Partie C : Routage OSPF",
    "text": "Partie C : Routage OSPF\n\nQuestion 8\nRecopier et compléter la dernière colonne du tableau ci-dessous.\n\n\n\n\n\n\nRappel : Protocole OSPF (Open Shortest Path First)\n\n\n\nLe protocole OSPF utilise un coût comme métrique, qui est généralement inversement proportionnel au débit de la liaison. Le chemin avec le coût total le plus faible est choisi. La formule donnée est : \\(\\text{coût} = \\frac{10^9}{\\text{débit}}\\).\n\n\n\nFast Ethernet (100 Mbit/s = \\(10^8\\) bit/s) : \\(\\text{coût} = \\frac{10^9}{10^8} = 10\\)\nFibre optique (1 Gbit/s = \\(10^9\\) bit/s) : \\(\\text{coût} = \\frac{10^9}{10^9} = 1\\)\n\nTableau complété :\n\n\n\nType de connexion\nDébit en bit.s⁻¹\ncoût\n\n\n\n\nEthernet\n10 Mbit.s⁻¹ = \\(10^7\\) bit.s⁻¹\n100\n\n\nFast Ethernet\n100 Mbit.s⁻¹ = \\(10^8\\) bit.s⁻¹\n10\n\n\nFibre optique\n1 Gbit.s⁻¹ = \\(10^9\\) bit.s⁻¹\n1\n\n\n\n\n\nQuestion 9\nDéterminer la route dont le coût est minimal pour aller du routeur 1 jusqu’au routeur 4 et calculer son coût au sens du protocole OSPF.\nCalculons le coût des routes possibles de R1 à R4 en utilisant le schéma de la Figure 2 et les coûts de la question 8 :\n\nRoute 1 (directe) : R1 \\(\\rightarrow\\) R4.\n\nLiaison : Ethernet.\nCoût = 100.\n\nRoute 2 (indirecte) : R1 \\(\\rightarrow\\) R2 \\(\\rightarrow\\) R3 \\(\\rightarrow\\) R4.\n\nLiaisons : R1-R2 (Fast Ethernet) + R2-R3 (Fast Ethernet) + R3-R4 (Fibre).\nCoût = \\(10 + 10 + 1 = 21\\).\n\n\nLa route au coût minimal est R1 \\(\\rightarrow\\) R2 \\(\\rightarrow\\) R3 \\(\\rightarrow\\) R4, avec un coût total de 21."
  },
  {
    "objectID": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-d-arbres-binaires-de-recherche",
    "href": "posts/2025-06-18-NSIMetropoleJ1/index.html#partie-d-arbres-binaires-de-recherche",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 1",
    "section": "Partie D : Arbres binaires de recherche",
    "text": "Partie D : Arbres binaires de recherche\n\nQuestion 10\nDonner la chaîne de caractères renvoyée par ip_bin('192.168.20.12').\nIl faut convertir chaque octet en binaire sur 8 bits :\n\n192 = 11000000\n168 = 10101000\n20 = 00010100\n12 = 00001100\n\nLa chaîne renvoyée est : '11000000.10101000.00010100.00001100'\n\n\nQuestion 11\nExpliquer dans quel cas la fonction precede exécutera la dernière instruction return de la ligne 7.\nL’instruction return de la ligne 7 est exécutée uniquement si la boucle for se termine sans qu’aucune des conditions if ou elif ne soit jamais vraie. Cela signifie que pour tous les indices i de 0 à 34, ip_1[i] est égal à ip_2[i].\nCe cas se produit donc lorsque les deux chaînes de caractères ip_1 et ip_2 sont strictement identiques.\n\n\nQuestion 12\nRecopier et compléter les lignes 4, 6 et 7 du code de la fonction precede.\ndef precede(ip_1, ip_2):\n    for i in range(35):\n        if ip_1[i] &lt; ip_2[i]:\n            return True   # ligne 4\n        elif ip_1[i] &gt; ip_2[i]:\n            return False  # ligne 6\n    return False          # ligne 7 (si les IPs sont égales)\n\n\nQuestion 13\nCiter un attribut et citer une méthode de la classe Abr.\n\nAttribut : adresse_ip (ou interface, passerelle, cout, gauche, droite).\nMéthode : est_vide (ou __init__, modifie).\n\n\n\nQuestion 14\nRecopier et compléter la ligne 14 du code de la classe Abr.\nPar convention, un arbre vide est une instance où adresse_ip est une chaîne vide.\ndef est_vide(self):\n    return self.adresse_ip == '' # ligne 14\n\n\nQuestion 15\nJustifier, en mobilisant des connaissances de cours, l’intérêt qu’il peut y avoir à représenter la table de routage par un arbre binaire de recherche.\n\n\n\n\n\n\nRappel : Arbre binaire de recherche (ABR)\n\n\n\nUn ABR est une structure de données qui permet des opérations de recherche, d’insertion et de suppression efficaces. Dans un ABR équilibré contenant \\(n\\) éléments, la complexité de ces opérations est en moyenne de \\(O(\\log n)\\).\n\n\nL’intérêt principal d’utiliser un arbre binaire de recherche (ABR) pour une table de routage est la rapidité de la recherche. Un routeur doit consulter sa table de routage pour chaque paquet qu’il traite, une opération qui doit être extrêmement rapide. Dans un ABR équilibré, la recherche d’une adresse de destination a une complexité temporelle de \\(O(\\log n)\\), où \\(n\\) est le nombre de routes dans la table. C’est beaucoup plus efficace qu’une recherche dans une liste non triée, qui aurait une complexité de \\(O(n)\\). Pour les grands routeurs d’Internet qui gèrent des centaines de milliers de routes, cette différence est importante pour les performances.\n\n\nQuestion 16\nRéécrire le code de la fonction modifie en évitant cette répétition.\nLes lignes d’affectation des attributs sont exécutées que le nœud soit vide ou non. On peut donc les factoriser.\ndef modifie(self, adresse_ip, interface, passerelle, cout):\n    \n    # On mémorise si le nœud était vide avant la modification.\n    etait_vide = self.est_vide()\n\n    # Opérations de mise à jour des données, qui ont lieu dans tous les cas.\n    self.adresse_ip = adresse_ip\n    self.interface = interface\n    self.passerelle = passerelle\n    self.cout = cout\n    \n    # Opération de création des enfants, qui n'a lieu QUE si le nœud\n    # était initialement vide.\n    if etait_vide:\n        self.gauche = Abr('', '', '', 0)\n        self.droite = Abr('', '', '', 0)\n\n\nQuestion 17\nRecopier et compléter la ligne 35 du code de la fonction rechercher.\nLa fonction rechercher navigue dans l’ABR. Si l’adresse cherchée (adresse_ip) précède l’adresse du nœud courant (self.adresse_ip), il faut chercher dans le sous-arbre gauche.\ndef rechercher(self, adresse_ip):\n    if self.est_vide() or adresse_ip == self.adresse_ip:\n        return self\n    elif precede(adresse_ip, self.adresse_ip): # ligne 35\n        return self.gauche.rechercher(adresse_ip)\n    else:\n        return self.droite.rechercher(adresse_ip)"
  },
  {
    "objectID": "posts/2025-06-23-NSIMetropoleJ2/index.html",
    "href": "posts/2025-06-23-NSIMetropoleJ2/index.html",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 2",
    "section": "",
    "text": "Cet exercice porte sur les arbres binaires et la programmation Python dans le contexte du codage de Shannon-Fano.\n\n\n\nPour obtenir le mot binaire qui encode le caractère espace, représenté par le symbole _, il faut parcourir l’arbre de la Figure 1 de la racine jusqu’à la feuille contenant ce symbole.\n\nOn part de la racine et on prend la branche de droite, étiquetée 0.\nDu nœud suivant, on prend la branche de gauche, étiquetée 1.\nDu nœud suivant, on prend la branche de droite, étiquetée 0. On arrive à la feuille _.\n\nLe mot binaire correspondant est donc 010.\nPour décoder le mot binaire 0001110101111110011001, on parcourt l’arbre depuis la racine pour chaque symbole.\n\n00 : racine -&gt; droite (0) -&gt; droite (0) -&gt; feuille e.\nIl reste 01110101111110011001. On repart de la racine.\n011 : racine -&gt; droite (0) -&gt; gauche (1) -&gt; gauche (1) -&gt; feuille s.\nIl reste 1010111110011001. On repart de la racine.\n1010 : racine -&gt; gauche (1) -&gt; droite (0) -&gt; gauche (1) -&gt; droite (0) -&gt; feuille p.\nIl reste 11110011001. On repart de la racine.\n1111 : racine -&gt; gauche (1) -&gt; gauche (1) -&gt; gauche (1) -&gt; gauche (1) -&gt; feuille i.\nIl reste 110011001. On repart de la racine.\n11001 : racine -&gt; gauche (1) -&gt; gauche (1) -&gt; droite (0) -&gt; droite (0) -&gt; gauche (1) -&gt; feuille o.\nIl reste 1001. On repart de la racine.\n1001 : racine -&gt; gauche (1) -&gt; droite (0) -&gt; droite (0) -&gt; gauche (1) -&gt; feuille n.\n\nLe texte décodé est espion.\nPour obtenir les symboles classés par taille d’encodage croissante, il faut lister les symboles en fonction de leur profondeur dans l’arbre. Les symboles les plus proches de la racine ont les codes les plus courts. Le parcours qui explore un arbre niveau par niveau est le parcours en largeur.\n\n\n\n\n\n\n\nRappel de cours : Parcours d’arbre\n\n\n\nUn parcours en largeur (ou Breadth-First Search, BFS) explore un arbre niveau par niveau. On visite d’abord la racine, puis tous ses enfants, puis tous les nœuds du niveau suivant, et ainsi de suite. Ce parcours est souvent mis en œuvre à l’aide d’une file.\n\n\n\n\n\n\nL’étape 2 de l’algorithme de Shannon-Fano consiste à séparer la liste ordonnée des symboles en deux groupes dont les sommes des occurrences sont les plus proches possibles.\nLe tableau des symboles triés par nombre d’occurrences est : i(1), u(1), c(1), o(1), d(1), ,(1), p(1), n(2), j(2), s(3), _(4), e(4). La somme totale des occurrences est : \\(7 \\times 1 + 2 \\times 2 + 1 \\times 3 + 2 \\times 4 = 7 + 4 + 3 + 8 = 22\\).\nIl faut donc chercher une coupure qui sépare ce total en deux sommes aussi proches que possible de \\(22 / 2 = 11\\).\nLa figure 2 propose la coupure suivante :\n\nGroupe 1 (gauche) : i, u, c, o, d, ,, p, n, j. La somme de leurs occurrences est : \\(1+1+1+1+1+1+1+2+2 = 11\\).\nGroupe 2 (droite) : s, _, e. La somme de leurs occurrences est : \\(3+4+4 = 11\\).\n\nLes deux sommes étant égales à 11, cette séparation est optimale. La justification est donc validée par ce calcul.\nLa hauteur d’un arbre est la longueur du plus long chemin de la racine à une feuille. Dans la figure 3, les feuilles les plus profondes sont o et d. Le chemin pour atteindre d est 1 -&gt; 0 -&gt; 1 -&gt; 1 -&gt; 0. Ce chemin est de longueur 5.\nLa hauteur de l’arbre est 5.\nDans le contexte de l’exercice, cette hauteur représente la longueur du plus long mot de code binaire utilisé pour encoder un symbole.\nPour justifier que le codage de Shannon-Fano est plus efficace que l’ASCII pour le texte je pense, donc je suis, nous devons comparer le nombre total de bits nécessaires dans chaque cas.\n\nCodage ASCII : Le texte contient 22 caractères (en se basant sur la somme des occurrences du tableau de la page 3). En ASCII, chaque caractère est codé sur un octet, soit 8 bits. Taille totale en ASCII = \\(22 \\text{ caractères} \\times 8 \\text{ bits/caractère} = 176 \\text{ bits}\\).\nCodage de Shannon-Fano : On utilise les longueurs de code données par la profondeur de chaque symbole dans l’arbre de la figure 3 et les fréquences du tableau.\n\nProfondeur 2 : e (4), _ (4). Coût : \\((4+4) \\times 2 = 16\\) bits.\nProfondeur 3 : s (3). Coût : \\(3 \\times 3 = 9\\) bits.\nProfondeur 4 : j (2), n (2), p (1), c (1), u (1), i (1). Coût : \\((2+2+1+1+1+1) \\times 4 = 8 \\times 4 = 32\\) bits.\nProfondeur 5 : , (1), d (1), o (1). Coût : \\((1+1+1) \\times 5 = 3 \\times 5 = 15\\) bits.\n\nTaille totale Shannon-Fano = \\(16 + 9 + 32 + 15 = 72\\) bits.\n\nComparaison :\nLe rapport des tailles est \\(\\frac{\\text{Taille ASCII}}{\\text{Taille Shannon-Fano}} = \\frac{176}{72} \\approx 2,44\\). Le codage de Shannon-Fano utilise donc bien environ deux fois moins de bits (et donc d’octets) que le codage ASCII pour ce texte.\nPour construire l’arbre de codage du mot « chiffrer » :\n\nFréquences : c(1), h(1), i(1), e(1), f(2), r(2). Total : 8.\nListe triée : (c,1), (h,1), (i,1), (e,1), (f,2), (r,2).\nConstruction récursive :\n\nÉtape 1 : Somme totale = 8. On coupe en deux groupes de somme 4.\n\nGroupe 1 (étiquette 1): (c,1), (h,1), (i,1), (e,1). Somme = 4.\nGroupe 2 (étiquette 0): (f,2), (r,2). Somme = 4.\n\nÉtape 2 (sur Groupe 1) : Somme = 4. On coupe en deux groupes de somme 2.\n\nGroupe 1.1 (1): (c,1), (h,1).\nGroupe 1.2 (0): (i,1), (e,1).\n\nÉtape 3 (sur Groupe 1.1) :\n\nFeuille c (étiquette 1). Code: 111.\nFeuille h (étiquette 0). Code: 110.\n\nÉtape 4 (sur Groupe 1.2) :\n\nFeuille i (étiquette 1). Code: 101.\nFeuille e (étiquette 0). Code: 100.\n\nÉtape 5 (sur Groupe 2) :\n\nFeuille f (étiquette 1). Code: 01.\nFeuille r (étiquette 0). Code: 00.\n\n\n\nL’arbre de codage obtenu est le suivant :\n\n\n\n\n\n\nVoici les lignes 8 et 10 complétées pour la fonction creer_dico_occ :\n# ...\n7     if symbole in dico:\n8         dico[symbole] += 1\n9     else:\n10        dico[symbole] = 1\n# ...\nVoici une proposition pour la fonction somme_occ :\ndef somme_occ(tab):\n    \"\"\"\n    Renvoie la somme des nombres d'occurrences\n    contenus dans un tableau de tuples (symbole, nb_occ).\n    \"\"\"\n    somme = 0\n    for symbole, nb in tab:\n        somme += nb\n    return somme\nUne écriture plus concise utilisant une compréhension de liste est aussi possible :\ndef somme_occ(tab):\n    return sum([nb for symbole, nb in tab])\nVoici les lignes 9 et 11 complétées pour la fonction shannon :\n# ...\n8     if symbole in [elt[0] for elt in t1]:\n9         return \"1\" + shannon(symbole, t1)\n10    else:\n11        return \"0\" + shannon(symbole, t2)\nLa terminaison de la fonction récursive shannon est garantie par deux points :\n\nCas de base : La fonction s’arrête lorsque la condition len(tab) == 1 est vraie.\nConvergence : À chaque appel récursif, la fonction separe divise le tableau tab en deux sous-tableaux non vides t1 et t2. La taille du tableau passé en paramètre à l’appel suivant (t1 ou t2) est donc strictement inférieure à la taille du tableau tab de l’appel courant. La taille de l’argument décroissant strictement à chaque étape, elle atteindra nécessairement la valeur 1, ce qui déclenchera le cas de base et mettra fin à la récursion.\n\n\n\n\n\n\n\n\nRappel de cours : Terminaison d’une fonction récursive\n\n\n\nPour qu’une fonction récursive se termine, elle doit comporter :\n\nUn ou plusieurs cas de base qui ne génèrent pas d’appel récursif.\nUn ou plusieurs cas récursifs où la fonction s’appelle elle-même avec des arguments qui la rapprochent systématiquement d’un cas de base. On appelle cela le variant de boucle (ou de récursion) : une quantité entière positive qui décroît strictement à chaque appel.\n\n\n\n\nVoici une proposition pour la fonction encode_shannon :\ndef encode_shannon(texte):\n    \"\"\"\n    Prend un texte en paramètre et renvoie le mot binaire\n    correspondant après encodage par l'algorithme de Shannon-Fano.\n    \"\"\"\n    if not texte:\n        return \"\"\n\n    dico_occurrences = creer_dico_occ(texte)\n    tableau_trie = creer_tab_trie(dico_occurrences)\n\n    mot_binaire_final = \"\"\n    for caractere in texte:\n        code_caractere = shannon(caractere, tableau_trie)\n        mot_binaire_final += code_caractere\n\n    return mot_binaire_final"
  },
  {
    "objectID": "posts/2025-06-23-NSIMetropoleJ2/index.html#exercice-1-6-points",
    "href": "posts/2025-06-23-NSIMetropoleJ2/index.html#exercice-1-6-points",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 2",
    "section": "",
    "text": "Cet exercice porte sur les arbres binaires et la programmation Python dans le contexte du codage de Shannon-Fano.\n\n\n\nPour obtenir le mot binaire qui encode le caractère espace, représenté par le symbole _, il faut parcourir l’arbre de la Figure 1 de la racine jusqu’à la feuille contenant ce symbole.\n\nOn part de la racine et on prend la branche de droite, étiquetée 0.\nDu nœud suivant, on prend la branche de gauche, étiquetée 1.\nDu nœud suivant, on prend la branche de droite, étiquetée 0. On arrive à la feuille _.\n\nLe mot binaire correspondant est donc 010.\nPour décoder le mot binaire 0001110101111110011001, on parcourt l’arbre depuis la racine pour chaque symbole.\n\n00 : racine -&gt; droite (0) -&gt; droite (0) -&gt; feuille e.\nIl reste 01110101111110011001. On repart de la racine.\n011 : racine -&gt; droite (0) -&gt; gauche (1) -&gt; gauche (1) -&gt; feuille s.\nIl reste 1010111110011001. On repart de la racine.\n1010 : racine -&gt; gauche (1) -&gt; droite (0) -&gt; gauche (1) -&gt; droite (0) -&gt; feuille p.\nIl reste 11110011001. On repart de la racine.\n1111 : racine -&gt; gauche (1) -&gt; gauche (1) -&gt; gauche (1) -&gt; gauche (1) -&gt; feuille i.\nIl reste 110011001. On repart de la racine.\n11001 : racine -&gt; gauche (1) -&gt; gauche (1) -&gt; droite (0) -&gt; droite (0) -&gt; gauche (1) -&gt; feuille o.\nIl reste 1001. On repart de la racine.\n1001 : racine -&gt; gauche (1) -&gt; droite (0) -&gt; droite (0) -&gt; gauche (1) -&gt; feuille n.\n\nLe texte décodé est espion.\nPour obtenir les symboles classés par taille d’encodage croissante, il faut lister les symboles en fonction de leur profondeur dans l’arbre. Les symboles les plus proches de la racine ont les codes les plus courts. Le parcours qui explore un arbre niveau par niveau est le parcours en largeur.\n\n\n\n\n\n\n\nRappel de cours : Parcours d’arbre\n\n\n\nUn parcours en largeur (ou Breadth-First Search, BFS) explore un arbre niveau par niveau. On visite d’abord la racine, puis tous ses enfants, puis tous les nœuds du niveau suivant, et ainsi de suite. Ce parcours est souvent mis en œuvre à l’aide d’une file.\n\n\n\n\n\n\nL’étape 2 de l’algorithme de Shannon-Fano consiste à séparer la liste ordonnée des symboles en deux groupes dont les sommes des occurrences sont les plus proches possibles.\nLe tableau des symboles triés par nombre d’occurrences est : i(1), u(1), c(1), o(1), d(1), ,(1), p(1), n(2), j(2), s(3), _(4), e(4). La somme totale des occurrences est : \\(7 \\times 1 + 2 \\times 2 + 1 \\times 3 + 2 \\times 4 = 7 + 4 + 3 + 8 = 22\\).\nIl faut donc chercher une coupure qui sépare ce total en deux sommes aussi proches que possible de \\(22 / 2 = 11\\).\nLa figure 2 propose la coupure suivante :\n\nGroupe 1 (gauche) : i, u, c, o, d, ,, p, n, j. La somme de leurs occurrences est : \\(1+1+1+1+1+1+1+2+2 = 11\\).\nGroupe 2 (droite) : s, _, e. La somme de leurs occurrences est : \\(3+4+4 = 11\\).\n\nLes deux sommes étant égales à 11, cette séparation est optimale. La justification est donc validée par ce calcul.\nLa hauteur d’un arbre est la longueur du plus long chemin de la racine à une feuille. Dans la figure 3, les feuilles les plus profondes sont o et d. Le chemin pour atteindre d est 1 -&gt; 0 -&gt; 1 -&gt; 1 -&gt; 0. Ce chemin est de longueur 5.\nLa hauteur de l’arbre est 5.\nDans le contexte de l’exercice, cette hauteur représente la longueur du plus long mot de code binaire utilisé pour encoder un symbole.\nPour justifier que le codage de Shannon-Fano est plus efficace que l’ASCII pour le texte je pense, donc je suis, nous devons comparer le nombre total de bits nécessaires dans chaque cas.\n\nCodage ASCII : Le texte contient 22 caractères (en se basant sur la somme des occurrences du tableau de la page 3). En ASCII, chaque caractère est codé sur un octet, soit 8 bits. Taille totale en ASCII = \\(22 \\text{ caractères} \\times 8 \\text{ bits/caractère} = 176 \\text{ bits}\\).\nCodage de Shannon-Fano : On utilise les longueurs de code données par la profondeur de chaque symbole dans l’arbre de la figure 3 et les fréquences du tableau.\n\nProfondeur 2 : e (4), _ (4). Coût : \\((4+4) \\times 2 = 16\\) bits.\nProfondeur 3 : s (3). Coût : \\(3 \\times 3 = 9\\) bits.\nProfondeur 4 : j (2), n (2), p (1), c (1), u (1), i (1). Coût : \\((2+2+1+1+1+1) \\times 4 = 8 \\times 4 = 32\\) bits.\nProfondeur 5 : , (1), d (1), o (1). Coût : \\((1+1+1) \\times 5 = 3 \\times 5 = 15\\) bits.\n\nTaille totale Shannon-Fano = \\(16 + 9 + 32 + 15 = 72\\) bits.\n\nComparaison :\nLe rapport des tailles est \\(\\frac{\\text{Taille ASCII}}{\\text{Taille Shannon-Fano}} = \\frac{176}{72} \\approx 2,44\\). Le codage de Shannon-Fano utilise donc bien environ deux fois moins de bits (et donc d’octets) que le codage ASCII pour ce texte.\nPour construire l’arbre de codage du mot « chiffrer » :\n\nFréquences : c(1), h(1), i(1), e(1), f(2), r(2). Total : 8.\nListe triée : (c,1), (h,1), (i,1), (e,1), (f,2), (r,2).\nConstruction récursive :\n\nÉtape 1 : Somme totale = 8. On coupe en deux groupes de somme 4.\n\nGroupe 1 (étiquette 1): (c,1), (h,1), (i,1), (e,1). Somme = 4.\nGroupe 2 (étiquette 0): (f,2), (r,2). Somme = 4.\n\nÉtape 2 (sur Groupe 1) : Somme = 4. On coupe en deux groupes de somme 2.\n\nGroupe 1.1 (1): (c,1), (h,1).\nGroupe 1.2 (0): (i,1), (e,1).\n\nÉtape 3 (sur Groupe 1.1) :\n\nFeuille c (étiquette 1). Code: 111.\nFeuille h (étiquette 0). Code: 110.\n\nÉtape 4 (sur Groupe 1.2) :\n\nFeuille i (étiquette 1). Code: 101.\nFeuille e (étiquette 0). Code: 100.\n\nÉtape 5 (sur Groupe 2) :\n\nFeuille f (étiquette 1). Code: 01.\nFeuille r (étiquette 0). Code: 00.\n\n\n\nL’arbre de codage obtenu est le suivant :\n\n\n\n\n\n\nVoici les lignes 8 et 10 complétées pour la fonction creer_dico_occ :\n# ...\n7     if symbole in dico:\n8         dico[symbole] += 1\n9     else:\n10        dico[symbole] = 1\n# ...\nVoici une proposition pour la fonction somme_occ :\ndef somme_occ(tab):\n    \"\"\"\n    Renvoie la somme des nombres d'occurrences\n    contenus dans un tableau de tuples (symbole, nb_occ).\n    \"\"\"\n    somme = 0\n    for symbole, nb in tab:\n        somme += nb\n    return somme\nUne écriture plus concise utilisant une compréhension de liste est aussi possible :\ndef somme_occ(tab):\n    return sum([nb for symbole, nb in tab])\nVoici les lignes 9 et 11 complétées pour la fonction shannon :\n# ...\n8     if symbole in [elt[0] for elt in t1]:\n9         return \"1\" + shannon(symbole, t1)\n10    else:\n11        return \"0\" + shannon(symbole, t2)\nLa terminaison de la fonction récursive shannon est garantie par deux points :\n\nCas de base : La fonction s’arrête lorsque la condition len(tab) == 1 est vraie.\nConvergence : À chaque appel récursif, la fonction separe divise le tableau tab en deux sous-tableaux non vides t1 et t2. La taille du tableau passé en paramètre à l’appel suivant (t1 ou t2) est donc strictement inférieure à la taille du tableau tab de l’appel courant. La taille de l’argument décroissant strictement à chaque étape, elle atteindra nécessairement la valeur 1, ce qui déclenchera le cas de base et mettra fin à la récursion.\n\n\n\n\n\n\n\n\nRappel de cours : Terminaison d’une fonction récursive\n\n\n\nPour qu’une fonction récursive se termine, elle doit comporter :\n\nUn ou plusieurs cas de base qui ne génèrent pas d’appel récursif.\nUn ou plusieurs cas récursifs où la fonction s’appelle elle-même avec des arguments qui la rapprochent systématiquement d’un cas de base. On appelle cela le variant de boucle (ou de récursion) : une quantité entière positive qui décroît strictement à chaque appel.\n\n\n\n\nVoici une proposition pour la fonction encode_shannon :\ndef encode_shannon(texte):\n    \"\"\"\n    Prend un texte en paramètre et renvoie le mot binaire\n    correspondant après encodage par l'algorithme de Shannon-Fano.\n    \"\"\"\n    if not texte:\n        return \"\"\n\n    dico_occurrences = creer_dico_occ(texte)\n    tableau_trie = creer_tab_trie(dico_occurrences)\n\n    mot_binaire_final = \"\"\n    for caractere in texte:\n        code_caractere = shannon(caractere, tableau_trie)\n        mot_binaire_final += code_caractere\n\n    return mot_binaire_final"
  },
  {
    "objectID": "posts/2025-06-23-NSIMetropoleJ2/index.html#exercice-2-6-points",
    "href": "posts/2025-06-23-NSIMetropoleJ2/index.html#exercice-2-6-points",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 2",
    "section": "Exercice 2 (6 points)",
    "text": "Exercice 2 (6 points)\nCet exercice porte sur les bases de données relationnelles, le langage SQL et la programmation Python.\n\nL’attribut nom ne peut pas être utilisé comme clé primaire pour la relation adherent car il n’assure pas l’unicité de chaque enregistrement. Plusieurs personnes peuvent avoir le même nom de famille (homonymes). La clé primaire doit être un identifiant unique pour chaque adhérent.\n\n\n\n\n\n\n\nRappel de cours : Clé primaire\n\n\n\nUne clé primaire (primary key) est un attribut ou un ensemble d’attributs qui permet d’identifier de manière unique chaque enregistrement (ou ligne) dans une table. Sa valeur doit être unique pour chaque ligne et ne peut pas être NULL.\n\n\n\nLa requête SQL SELECT nomJeu, editeur FROM jeu ORDER BY nomJeu; a pour effet de :\n\nSélectionner les colonnes nomJeu et editeur de la table jeu.\nTrier les résultats obtenus par ordre alphabétique croissant en se basant sur la colonne nomJeu.\n\nCette requête renvoie donc la liste de tous les jeux et de leur éditeur, classée par ordre alphabétique des noms de jeu.\nPour connaître le nom des jeux en cours d’emprunt, il faut sélectionner les jeux dans la table emprunt dont l’attribut dateRendu a la valeur NULL. Comme un jeu ne peut être emprunté qu’une seule fois à un instant donné (un seul exemplaire), l’utilisation de DISTINCT est facultative mais reste une bonne pratique.\nSELECT nomJeu\nFROM emprunt\nWHERE dateRendu IS NULL;\n\n\n\n\n\n\n\nRappel de cours : La valeur NULL\n\n\n\nEn SQL, NULL représente une valeur inconnue ou absente. Pour tester si une colonne a la valeur NULL, on doit utiliser les opérateurs IS NULL ou IS NOT NULL, et non l’opérateur d’égalité =.\n\n\n\nPour afficher le nom et le prénom des adhérents ayant emprunté le jeu “Catan”, il faut lier les tables adherent et emprunt via leur clé commune (idAdherent).\nSELECT adherent.nom, adherent.prenom\nFROM adherent\nJOIN emprunt ON adherent.idAdherent = emprunt.idAdherent\nWHERE emprunt.nomJeu = 'Catan';\n\n\n\n\n\n\n\nRappel de cours : Les jointures\n\n\n\nUne jointure (clause JOIN) permet de combiner des lignes de deux ou plusieurs tables en se basant sur une colonne commune entre elles. La clause ON spécifie la condition de jointure.\n\n\n\nPour mettre à jour la base de données après le retour du jeu, il faut utiliser une requête UPDATE pour renseigner la dateRendu de l’emprunt concerné, identifié par son idEmprunt.\nUPDATE emprunt\nSET dateRendu = '2025-06-03'\nWHERE idEmprunt = 1538;\nPour trouver le nom et la catégorie des jeux sortis à partir de 2010 et dont l’âge minimum est strictement inférieur à 10 ans, on utilise une clause WHERE avec deux conditions reliées par l’opérateur AND.\nSELECT nomJeu, categorie\nFROM jeu\nWHERE anneeSortie &gt;= 2010 AND ageMinimum &lt; 10;\nLa table participation sert à lier les événements aux adhérents. Il s’agit d’une table de jointure pour une relation de type “plusieurs à plusieurs” (un adhérent peut participer à plusieurs événements, un événement accueille plusieurs adhérents). Elle doit donc contenir une clé étrangère vers la table evenement et une clé étrangère vers la table adherent.\nLa clé primaire de la table evenement est nom, les clés étrangères de la table participation sont :\n\n#nomEvenement qui fait référence à l’attribut nom de la table evenement.\n#idAdherent qui fait référence à l’attribut idAdherent de la table adherent.\n\nLe script Python suivant reprend le code fourni, récupère la liste des jeux empruntés et construit le dictionnaire dict_emprunts qui associe à chaque nom de jeu son nombre total d’emprunts.\nimport sqlite3\n\n# Connexion à la base de données\nconnection = sqlite3.connect(\"ludotheque.db\")\ncurseur = connection.cursor()\n\n# Exécution de la requête\ncurseur.execute(\"SELECT nomJeu FROM emprunt\")\n\n# Récupération des résultats\n# curseur.fetchall() renvoie une liste de tuples, ex: [('Catan',), ('Agricola',)]\njeux_empruntes_tuples = curseur.fetchall()\n\n# Création de la liste des noms de jeux\nliste_jeux = []\nfor jeu_tuple in jeux_empruntes_tuples:\n    liste_jeux.append(jeu_tuple[0])\n\n# Création du dictionnaire des occurrences\ndict_emprunts = {}\nfor nom_jeu in liste_jeux:\n    if nom_jeu in dict_emprunts:\n        dict_emprunts[nom_jeu] += 1\n    else:\n        dict_emprunts[nom_jeu] = 1\n\n# Affichage du dictionnaire (pour vérification)\nprint(dict_emprunts)\n\n# Fermeture de la connexion\ncurseur.close()\nconnection.close()\n\n\n# On suppose que dict_emprunts est déjà créé.\ndict_emprunts = {\n    \"Terraforming Mars\": 25,\n    \"Codenames\": 22,\n    \"Agricola\": 18,\n    \"Puerto Rico\": 18,\n    \"Caylus\": 18,\n    \"Dominion\": 22,\n    \"Dixit\": 12\n}\n\n# --- Étape 1 : Regrouper les jeux par score dans un dictionnaire ---\n# (Cette étape reste identique et très utile)\nscores_podium = {}\nfor jeu, score in dict_emprunts.items():\n    if score not in scores_podium:\n        scores_podium[score] = []\n    scores_podium[score].append(jeu)\n\n# --- Étape 2 : Trouver les 3 meilleurs scores en cherchant le maximum 3 fois ---\n\n# On récupère la liste des scores uniques à traiter.\nscores_a_traiter = list(scores_podium.keys())\n\n# On va stocker les listes du podium dans l'ordre où on les trouve (du meilleur au moins bon).\npodium_ordre_inverse = []\n\n# On répète l'opération 3 fois pour les 3 places du podium.\n# On vérifie aussi qu'il reste des scores à traiter.\nfor i in range(3):\n    if len(scores_a_traiter) == 0:\n        break # Arrête la boucle s'il y a moins de 3 scores uniques.\n\n    # On cherche le score le plus élevé parmi ceux qui restent.\n    score_maximum = -1 # On initialise avec une valeur très basse\n    for score in scores_a_traiter:\n        if score &gt; score_maximum:\n            score_maximum = score\n    \n    # On ajoute la liste des jeux correspondants à notre podium temporaire.\n    podium_ordre_inverse.append(scores_podium[score_maximum])\n    \n    # On retire ce score de la liste pour ne pas le retrouver au tour suivant.\n    scores_a_traiter.remove(score_maximum)\n\n# --- Étape 3 : Inverser la liste pour avoir le podium dans l'ordre croissant des scores ---\n# podium_ordre_inverse contient [liste_score_25, liste_score_22, liste_score_18]\n# L'énoncé veut [liste_score_18, liste_score_22, liste_score_25]\n\npodium_final = []\n# On parcourt la liste temporaire de la fin vers le début.\nfor i in range(len(podium_ordre_inverse) - 1, -1, -1):\n    podium_final.append(podium_ordre_inverse[i])\n\n# Affichage du podium final\nprint(podium_final)\n# Affiche : [['Agricola', 'Puerto Rico', 'Caylus'], ['Codenames', 'Dominion'], ['Terraforming Mars']]"
  },
  {
    "objectID": "posts/2025-06-23-NSIMetropoleJ2/index.html#exercice-3-8-points",
    "href": "posts/2025-06-23-NSIMetropoleJ2/index.html#exercice-3-8-points",
    "title": "Corrigé du sujet de NSI du baccalauréat 2025 - Métropole Jour 2",
    "section": "Exercice 3 (8 points)",
    "text": "Exercice 3 (8 points)\nCet exercice porte sur la programmation Python, la sécurisation des communications et les réseaux.\n\nPartie A - La méthode du masque jetable\n\nPour chiffrer le message LIBRE avec la clé EYQMT, on suit la méthode décrite :\n\nConvertir les lettres en rangs (de 0 à 25).\nAdditionner les rangs du message et de la clé.\nAppliquer le modulo 26 au résultat.\nReconvertir les rangs obtenus en lettres.\n\n\n\n\n\nOpération\nL\nI\nB\nR\nE\n\n\n\n\nRang du message\n11\n8\n1\n17\n4\n\n\nClé\nE\nY\nQ\nM\nT\n\n\nRang de la clé\n4\n24\n16\n12\n19\n\n\nSomme\n15\n32\n17\n29\n23\n\n\nSomme mod 26\n15\n6\n17\n3\n23\n\n\nLettre chiffrée\nP\nG\nR\nD\nX\n\n\n\nLe message chiffré est PGRDX.\n\nLa fonction indice peut être écrite en utilisant la méthode .index() des listes en Python.\ndef indice(element, L):\n    \"\"\"\n    Renvoie l'indice de element dans la liste L.\n    \"\"\"\n    return L.index(element)\nAutre solution possible, plus simple :\ndef indice(element, L):\n    \"\"\"\n    Renvoie l'indice de element dans la liste L.\n    \"\"\"\n    for i in range(len(L)):\n        if L[i] == element:\n            return i\n    return -1  # Si l'élément n'est pas trouvé, on renvoie -1.\nLa fonction lettres_vers_indices parcourt la chaîne de caractères et utilise la liste globale alphabet pour trouver l’indice de chaque lettre.\n# On suppose que la variable 'alphabet' est définie globalement.\nalphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', \n            'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n\ndef lettres_vers_indices(chaine):\n    \"\"\"\n    Renvoie la liste des indices des caractères de la chaîne.\n    \"\"\"\n    indices = []\n    for caractere in chaine:\n        indices.append(indice(caractere, alphabet))\n    return indices\n\n# Une version plus concise avec une liste en compréhension :\n# def lettres_vers_indices(chaine):\n#     return [indice(c, alphabet) for c in chaine]\nVoici le code complété de la fonction chiffrement.\ndef chiffrement(msg, cle):\n    assert len(cle) &gt;= len(msg), 'impossible'\n    indices_msg = lettres_vers_indices(msg)\n    indices_cle = lettres_vers_indices(cle)\n    n = len(msg)\n    indices_msg_chiffre = []\n    for k in range(n):\n        # Ligne 8 : Addition des indices du message et de la clé\n        ind = indices_msg[k] + indices_cle[k]\n        # Ligne 9 : Application du modulo 26 si nécessaire\n        if ind &gt;= 26:\n            # Ligne 10 : L'opération est une soustraction de 26\n            ind = ind - 26\n        indices_msg_chiffre.append(ind)\n    # Ligne 12 : Conversion de la liste d'indices en chaîne de caractères\n    msg_chiffre = indices_vers_lettres(indices_msg_chiffre)\n    # Ligne 13\n    return msg_chiffre\nLors de l’appel chiffrement('RESEAU', 'GFTZ'), la condition de l’instruction assert est évaluée. len('RESEAU') vaut 6 et len('GFTZ') vaut 4. La condition len(cle) &gt;= len(msg) (soit 4 &gt;= 6) est fausse.\nL’exécution du programme s’arrête et une erreur de type AssertionError est levée, affichant le message 'impossible'.\nPour déchiffrer GMEDH avec la clé FVEIT, on effectue l’opération inverse : la soustraction modulo 26. \\(C_{dechiffré} = (C_{chiffré} - C_{clé}) \\pmod{26}\\).\n\n\n\n\nOpération\nG\nM\nE\nD\nH\n\n\n\n\nRang chiffré\n6\n12\n4\n3\n7\n\n\nClé\nF\nV\nE\nI\nT\n\n\nRang de la clé\n5\n21\n4\n8\n19\n\n\nDifférence\n1\n-9\n0\n-5\n-12\n\n\nDifférence mod 26\n1\n17\n0\n21\n14\n\n\nLettre déchiffrée\nB\nR\nA\nV\nO\n\n\n\nLe message déchiffré est BRAVO.\n\nPour déchiffrer un message, il faut effectuer l’opération mathématique inverse de celle du chiffrement. Le chiffrement est une addition modulo 26. Son inverse est donc une soustraction modulo 26.\nPour chaque caractère, on soustrait le rang de la lettre de la clé au rang de la lettre du message chiffré, et on prend le résultat modulo 26.\nMathématiquement : si \\(Chiffré = (Message + Clé) \\pmod{26}\\), alors \\(Message = (Chiffré - Clé) \\pmod{26}\\).\nPour obtenir la fonction dechiffrement, on adapte la fonction chiffrement en remplaçant l’addition par une soustraction.\ndef dechiffrement(msg_chiffre, cle):\n    assert len(cle) &gt;= len(msg_chiffre), 'impossible'\n    indices_msg = lettres_vers_indices(msg_chiffre)\n    indices_cle = lettres_vers_indices(cle)\n    n = len(msg_chiffre)\n    # Ligne 6 adaptée\n    indices_msg_dechiffre = []\n    for k in range(n):\n        # Ligne 8 adaptée : Soustraction des indices\n        ind = indices_msg[k] - indices_cle[k]\n        # Ligne 9 adaptée : Gestion des résultats négatifs\n        if ind &lt; 0:\n            # Ligne 10 adaptée : Ajout de 26\n            ind = ind + 26\n        indices_msg_dechiffre.append(ind)\n    # Ligne 12 adaptée\n    msg_dechiffre = indices_vers_lettres(indices_msg_dechiffre)\n    # Ligne 13 adaptée\n    return msg_dechiffre\n\n\n\nPartie B - Sécurisation des communications\n\nLa différence fondamentale entre un algorithme de chiffrement symétrique et asymétrique réside dans la gestion des clés :\n\nChiffrement symétrique : utilise une seule et même clé secrète pour chiffrer et déchiffrer le message. Cette clé doit être partagée de manière sécurisée entre l’émetteur et le destinataire avant la communication.\nChiffrement asymétrique : utilise une paire de clés pour chaque utilisateur : une clé publique, que l’on peut distribuer librement, et une clé privée, qui doit rester secrète. Ce qui est chiffré avec la clé publique ne peut être déchiffré qu’avec la clé privée correspondante.\n\nAlice chiffre son message avec la clé publique de Bob. Pour déchiffrer le message reçu, Bob utilise sa clé privée, qui est la seule capable d’inverser l’opération de chiffrement effectuée par sa clé publique.\nDans le scénario décrit, n’importe qui (une tierce personne, Eve par exemple) peut obtenir la clé publique de Bob. Eve peut alors chiffrer un message avec cette clé et l’envoyer à Bob en se faisant passer pour Alice. Bob pourra déchiffrer le message, mais n’aura aucun moyen de vérifier que l’expéditeur est bien Alice. Ce protocole simple ne garantit pas l’authentification de l’émetteur.\nHTTPS (HyperText Transfer Protocol Secure) est la version sécurisée du protocole HTTP. Il combine HTTP avec un protocole de sécurité comme TLS (Transport Layer Security). HTTPS assure trois garanties de sécurité principales :\n\nConfidentialité : Les données échangées sont chiffrées, les rendant illisibles pour un attaquant qui les intercepterait.\nIntégrité : Les données ne peuvent pas être modifiées durant leur transit sans que la modification soit détectée.\nAuthentification : Il permet de vérifier l’identité du serveur web auquel on se connecte, grâce à un système de certificats numériques.\n\nOn utilise le protocole HTTPS (qui est un système hybride) plutôt qu’un chiffrement purement asymétrique pour des raisons de performance. Le chiffrement asymétrique est beaucoup plus lent et gourmand en ressources de calcul que le chiffrement symétrique. Il est donc mal adapté pour chiffrer de grandes quantités de données. HTTPS utilise le chiffrement asymétrique uniquement au début de la connexion pour authentifier le serveur et négocier une clé de session secrète. Ensuite, toute la communication est chiffrée avec un algorithme symétrique, beaucoup plus rapide, utilisant cette clé de session.\n\n\n\nPartie C - Réseaux\n\nL’affichage 100% packet loss indique que la machine de Marc a envoyé 4 paquets ping à l’adresse IP 192.168.100.115, mais n’a reçu aucune réponse. L’erreur de Marc est une faute de frappe dans l’adresse IP du poste de Bob. L’adresse correcte est 192.168.110.115. Marc a tapé 100 au lieu de 110 dans le troisième octet. Il a donc tenté de contacter une machine sur un autre réseau (192.168.100.0/24), qui est probablement inaccessible depuis son poste.\nPour obtenir la représentation décimale du masque 11111111.11111111.11111111.11100000, on convertit chaque octet binaire en décimal :\n\n11111111 en binaire correspond à \\(2^8-1 = 255\\) en décimal.\n11100000 en binaire correspond à \\(1 \\times 2^7 + 1 \\times 2^6 + 1 \\times 2^5 = 128 + 64 + 32 = 224\\) en décimal.\n\nLe masque de sous-réseau en décimal est 255.255.255.224.\nLe masque 255.255.255.224 a 27 bits à 1 pour la partie réseau (\\(8+8+8+3=27\\)). La partie hôte est donc sur les \\(32 - 27 = 5\\) bits restants. Le nombre total d’adresses IPv4 sur ce sous-réseau est \\(2^5 = \\textbf{32}\\).\n(Note : parmi ces 32 adresses, 2 sont réservées : l’adresse du sous-réseau lui-même et l’adresse de diffusion. Il y a donc \\(32 - 2 = 30\\) adresses attribuables à des hôtes).\nPour convertir le nombre 134 en binaire, on utilise la méthode des divisions successives par 2 ou par décomposition en puissances de 2. \\(134 = 128 + 6 = 128 + 4 + 2 = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0\\).\nLa représentation binaire de 134 sur un octet est 10000110.\nPour savoir quelle commande a fonctionné, il faut déterminer si les machines cibles sont dans le même sous-réseau que Zoé. Deux machines peuvent communiquer directement si elles sont sur le même sous-réseau.\n\nMasque : 255.255.255.224 (11100000 pour le dernier octet).\nIP de Zoé : 192.168.110.134 (10000110 pour le dernier octet).\n\nAdresse du sous-réseau de Zoé : 134 ET 224 -&gt; 10000110 ET 11100000 = 10000000 (soit 128). Le sous-réseau est 192.168.110.128.\n\nCommande n°1 : ping 192.168.110.115 (Bob)\n\nLe dernier octet de l’IP de Bob est 115 (01110011).\nAdresse du sous-réseau de Bob : 115 ET 224 -&gt; 01110011 ET 11100000 = 01100000 (soit 96). Le sous-réseau est 192.168.110.96.\n\nCommande n°2 : ping 192.168.110.153 (Marc)\n\nLe dernier octet de l’IP de Marc est 153 (10011001).\nAdresse du sous-réseau de Marc : 153 ET 224 -&gt; 10011001 ET 11100000 = 10000000 (soit 128). Le sous-réseau est 192.168.110.128.\n\n\nConclusion : Zoé et Marc sont sur le même sous-réseau (192.168.110.128), alors que Bob est sur un sous-réseau différent (192.168.110.96). La communication directe est possible entre Zoé et Marc.\nC’est donc la commande n°2 qui a produit l’affichage indiquant une réussite de la communication."
  }
]